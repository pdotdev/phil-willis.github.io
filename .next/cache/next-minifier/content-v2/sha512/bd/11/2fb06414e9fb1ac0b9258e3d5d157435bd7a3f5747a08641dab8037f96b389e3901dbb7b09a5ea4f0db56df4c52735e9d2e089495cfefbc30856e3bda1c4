{"code":"(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[5],{GGH7:function(t,e,s){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});const i=!0,r=!0,a=!0,n=!0;class o{constructor(t,e={}){this.label=void 0,this.keyword=void 0,this.beforeExpr=void 0,this.startsExpr=void 0,this.rightAssociative=void 0,this.isLoop=void 0,this.isAssign=void 0,this.prefix=void 0,this.postfix=void 0,this.binop=void 0,this.updateContext=void 0,this.label=t,this.keyword=e.keyword,this.beforeExpr=!!e.beforeExpr,this.startsExpr=!!e.startsExpr,this.rightAssociative=!!e.rightAssociative,this.isLoop=!!e.isLoop,this.isAssign=!!e.isAssign,this.prefix=!!e.prefix,this.postfix=!!e.postfix,this.binop=null!=e.binop?e.binop:null,this.updateContext=null}}const h=new Map;function p(t,e={}){e.keyword=t;const s=new o(t,e);return h.set(t,s),s}function c(t,e){return new o(t,{beforeExpr:i,binop:e})}const l={num:new o(\"num\",{startsExpr:r}),bigint:new o(\"bigint\",{startsExpr:r}),decimal:new o(\"decimal\",{startsExpr:r}),regexp:new o(\"regexp\",{startsExpr:r}),string:new o(\"string\",{startsExpr:r}),name:new o(\"name\",{startsExpr:r}),eof:new o(\"eof\"),bracketL:new o(\"[\",{beforeExpr:i,startsExpr:r}),bracketHashL:new o(\"#[\",{beforeExpr:i,startsExpr:r}),bracketBarL:new o(\"[|\",{beforeExpr:i,startsExpr:r}),bracketR:new o(\"]\"),bracketBarR:new o(\"|]\"),braceL:new o(\"{\",{beforeExpr:i,startsExpr:r}),braceBarL:new o(\"{|\",{beforeExpr:i,startsExpr:r}),braceHashL:new o(\"#{\",{beforeExpr:i,startsExpr:r}),braceR:new o(\"}\"),braceBarR:new o(\"|}\"),parenL:new o(\"(\",{beforeExpr:i,startsExpr:r}),parenR:new o(\")\"),comma:new o(\",\",{beforeExpr:i}),semi:new o(\";\",{beforeExpr:i}),colon:new o(\":\",{beforeExpr:i}),doubleColon:new o(\"::\",{beforeExpr:i}),dot:new o(\".\"),question:new o(\"?\",{beforeExpr:i}),questionDot:new o(\"?.\"),arrow:new o(\"=>\",{beforeExpr:i}),template:new o(\"template\"),ellipsis:new o(\"...\",{beforeExpr:i}),backQuote:new o(\"`\",{startsExpr:r}),dollarBraceL:new o(\"${\",{beforeExpr:i,startsExpr:r}),at:new o(\"@\"),hash:new o(\"#\",{startsExpr:r}),interpreterDirective:new o(\"#!...\"),eq:new o(\"=\",{beforeExpr:i,isAssign:true}),assign:new o(\"_=\",{beforeExpr:i,isAssign:true}),incDec:new o(\"++/--\",{prefix:n,postfix:!0,startsExpr:r}),bang:new o(\"!\",{beforeExpr:i,prefix:n,startsExpr:r}),tilde:new o(\"~\",{beforeExpr:i,prefix:n,startsExpr:r}),pipeline:c(\"|>\",0),nullishCoalescing:c(\"??\",1),logicalOR:c(\"||\",1),logicalAND:c(\"&&\",2),bitwiseOR:c(\"|\",3),bitwiseXOR:c(\"^\",4),bitwiseAND:c(\"&\",5),equality:c(\"==/!=/===/!==\",6),relational:c(\"</>/<=/>=\",7),bitShift:c(\"<</>>/>>>\",8),plusMin:new o(\"+/-\",{beforeExpr:i,binop:9,prefix:n,startsExpr:r}),modulo:new o(\"%\",{beforeExpr:i,binop:10,startsExpr:r}),star:new o(\"*\",{binop:10}),slash:c(\"/\",10),exponent:new o(\"**\",{beforeExpr:i,binop:11,rightAssociative:!0}),_break:p(\"break\"),_case:p(\"case\",{beforeExpr:i}),_catch:p(\"catch\"),_continue:p(\"continue\"),_debugger:p(\"debugger\"),_default:p(\"default\",{beforeExpr:i}),_do:p(\"do\",{isLoop:a,beforeExpr:i}),_else:p(\"else\",{beforeExpr:i}),_finally:p(\"finally\"),_for:p(\"for\",{isLoop:a}),_function:p(\"function\",{startsExpr:r}),_if:p(\"if\"),_return:p(\"return\",{beforeExpr:i}),_switch:p(\"switch\"),_throw:p(\"throw\",{beforeExpr:i,prefix:n,startsExpr:r}),_try:p(\"try\"),_var:p(\"var\"),_const:p(\"const\"),_while:p(\"while\",{isLoop:a}),_with:p(\"with\"),_new:p(\"new\",{beforeExpr:i,startsExpr:r}),_this:p(\"this\",{startsExpr:r}),_super:p(\"super\",{startsExpr:r}),_class:p(\"class\",{startsExpr:r}),_extends:p(\"extends\",{beforeExpr:i}),_export:p(\"export\"),_import:p(\"import\",{startsExpr:r}),_null:p(\"null\",{startsExpr:r}),_true:p(\"true\",{startsExpr:r}),_false:p(\"false\",{startsExpr:r}),_in:p(\"in\",{beforeExpr:i,binop:7}),_instanceof:p(\"instanceof\",{beforeExpr:i,binop:7}),_typeof:p(\"typeof\",{beforeExpr:i,prefix:n,startsExpr:r}),_void:p(\"void\",{beforeExpr:i,prefix:n,startsExpr:r}),_delete:p(\"delete\",{beforeExpr:i,prefix:n,startsExpr:r})},u=/\\r\\n?|[\\n\\u2028\\u2029]/,d=new RegExp(u.source,\"g\");function m(t){switch(t){case 10:case 13:case 8232:case 8233:return!0;default:return!1}}const f=/(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;function y(t){switch(t){case 9:case 11:case 12:case 32:case 160:case 5760:case 8192:case 8193:case 8194:case 8195:case 8196:case 8197:case 8198:case 8199:case 8200:case 8201:case 8202:case 8239:case 8287:case 12288:case 65279:return!0;default:return!1}}class x{constructor(t,e){this.line=void 0,this.column=void 0,this.line=t,this.column=e}}class P{constructor(t,e){this.start=void 0,this.end=void 0,this.filename=void 0,this.identifierName=void 0,this.start=t,this.end=e}}function g(t){return t[t.length-1]}const b=Object.freeze({AccessorIsGenerator:\"A %0ter cannot be a generator\",ArgumentsInClass:\"'arguments' is only allowed in functions and class methods\",AsyncFunctionInSingleStatementContext:\"Async functions can only be declared at the top level or inside a block\",AwaitBindingIdentifier:\"Can not use 'await' as identifier inside an async function\",AwaitBindingIdentifierInStaticBlock:\"Can not use 'await' as identifier inside a static block\",AwaitExpressionFormalParameter:\"await is not allowed in async function parameters\",AwaitNotInAsyncContext:\"'await' is only allowed within async functions and at the top levels of modules\",AwaitNotInAsyncFunction:\"'await' is only allowed within async functions\",BadGetterArity:\"getter must not have any formal parameters\",BadSetterArity:\"setter must have exactly one formal parameter\",BadSetterRestParameter:\"setter function argument must not be a rest parameter\",ConstructorClassField:\"Classes may not have a field named 'constructor'\",ConstructorClassPrivateField:\"Classes may not have a private field named '#constructor'\",ConstructorIsAccessor:\"Class constructor may not be an accessor\",ConstructorIsAsync:\"Constructor can't be an async function\",ConstructorIsGenerator:\"Constructor can't be a generator\",DeclarationMissingInitializer:\"%0 require an initialization value\",DecoratorBeforeExport:\"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\",DecoratorConstructor:\"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",DecoratorExportClass:\"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",DecoratorSemicolon:\"Decorators must not be followed by a semicolon\",DecoratorStaticBlock:\"Decorators can't be used with a static block\",DeletePrivateField:\"Deleting a private field is not allowed\",DestructureNamedImport:\"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",DuplicateConstructor:\"Duplicate constructor in the same class\",DuplicateDefaultExport:\"Only one default export allowed per module.\",DuplicateExport:\"`%0` has already been exported. Exported identifiers must be unique.\",DuplicateProto:\"Redefinition of __proto__ property\",DuplicateRegExpFlags:\"Duplicate regular expression flag\",DuplicateStaticBlock:\"Duplicate static block in the same class\",ElementAfterRest:\"Rest element must be last element\",EscapedCharNotAnIdentifier:\"Invalid Unicode escape\",ExportBindingIsString:\"A string literal cannot be used as an exported binding without `from`.\\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?\",ExportDefaultFromAsIdentifier:\"'from' is not allowed as an identifier after 'export default'\",ForInOfLoopInitializer:\"%0 loop variable declaration may not have an initializer\",GeneratorInSingleStatementContext:\"Generators can only be declared at the top level or inside a block\",IllegalBreakContinue:\"Unsyntactic %0\",IllegalLanguageModeDirective:\"Illegal 'use strict' directive in function with non-simple parameter list\",IllegalReturn:\"'return' outside of function\",ImportBindingIsString:'A string literal cannot be used as an imported binding.\\n- Did you mean `import { \"%0\" as foo }`?',ImportCallArgumentTrailingComma:\"Trailing comma is disallowed inside import(...) arguments\",ImportCallArity:\"import() requires exactly %0\",ImportCallNotNewExpression:\"Cannot use new with import(...)\",ImportCallSpreadArgument:\"... is not allowed in import()\",ImportMetaOutsideModule:\"import.meta may appear only with 'sourceType: \\\"module\\\"'\",ImportOutsideModule:\"'import' and 'export' may appear only with 'sourceType: \\\"module\\\"'\",InvalidBigIntLiteral:\"Invalid BigIntLiteral\",InvalidCodePoint:\"Code point out of bounds\",InvalidDecimal:\"Invalid decimal\",InvalidDigit:\"Expected number in radix %0\",InvalidEscapeSequence:\"Bad character escape sequence\",InvalidEscapeSequenceTemplate:\"Invalid escape sequence in template\",InvalidEscapedReservedWord:\"Escape sequence in keyword %0\",InvalidIdentifier:\"Invalid identifier %0\",InvalidLhs:\"Invalid left-hand side in %0\",InvalidLhsBinding:\"Binding invalid left-hand side in %0\",InvalidNumber:\"Invalid number\",InvalidOrMissingExponent:\"Floating-point numbers require a valid exponent after the 'e'\",InvalidOrUnexpectedToken:\"Unexpected character '%0'\",InvalidParenthesizedAssignment:\"Invalid parenthesized assignment pattern\",InvalidPrivateFieldResolution:\"Private name #%0 is not defined\",InvalidPropertyBindingPattern:\"Binding member expression\",InvalidRecordProperty:\"Only properties and spread elements are allowed in record definitions\",InvalidRestAssignmentPattern:\"Invalid rest operator's argument\",LabelRedeclaration:\"Label '%0' is already declared\",LetInLexicalBinding:\"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",LineTerminatorBeforeArrow:\"No line break is allowed before '=>'\",MalformedRegExpFlags:\"Invalid regular expression flag\",MissingClassName:\"A class name is required\",MissingEqInAssignment:\"Only '=' operator can be used for specifying default value.\",MissingSemicolon:\"Missing semicolon\",MissingUnicodeEscape:\"Expecting Unicode escape sequence \\\\uXXXX\",MixingCoalesceWithLogical:\"Nullish coalescing operator(??) requires parens when mixing with logical operators\",ModuleAttributeDifferentFromType:\"The only accepted module attribute is `type`\",ModuleAttributeInvalidValue:\"Only string literals are allowed as module attribute values\",ModuleAttributesWithDuplicateKeys:'Duplicate key \"%0\" is not allowed in module attributes',ModuleExportNameHasLoneSurrogate:\"An export name cannot include a lone surrogate, found '\\\\u%0'\",ModuleExportUndefined:\"Export '%0' is not defined\",MultipleDefaultsInSwitch:\"Multiple default clauses\",NewlineAfterThrow:\"Illegal newline after throw\",NoCatchOrFinally:\"Missing catch or finally clause\",NumberIdentifier:\"Identifier directly after number\",NumericSeparatorInEscapeSequence:\"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\",ObsoleteAwaitStar:\"await* has been removed from the async functions proposal. Use Promise.all() instead.\",OptionalChainingNoNew:\"constructors in/after an Optional Chain are not allowed\",OptionalChainingNoTemplate:\"Tagged Template Literals are not allowed in optionalChain\",ParamDupe:\"Argument name clash\",PatternHasAccessor:\"Object pattern can't contain getter or setter\",PatternHasMethod:\"Object pattern can't contain methods\",PipelineBodyNoArrow:'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized',PipelineBodySequenceExpression:\"Pipeline body may not be a comma-separated sequence expression\",PipelineHeadSequenceExpression:\"Pipeline head should not be a comma-separated sequence expression\",PipelineTopicUnused:\"Pipeline is in topic style but does not use topic reference\",PrimaryTopicNotAllowed:\"Topic reference was used in a lexical context without topic binding\",PrimaryTopicRequiresSmartPipeline:\"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",PrivateInExpectedIn:\"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)\",PrivateNameRedeclaration:\"Duplicate private name #%0\",RecordExpressionBarIncorrectEndSyntaxType:\"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",RecordExpressionBarIncorrectStartSyntaxType:\"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",RecordExpressionHashIncorrectStartSyntaxType:\"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",RecordNoProto:\"'__proto__' is not allowed in Record expressions\",RestTrailingComma:\"Unexpected trailing comma after rest element\",SloppyFunction:\"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement\",StaticPrototype:\"Classes may not have static property named prototype\",StrictDelete:\"Deleting local variable in strict mode\",StrictEvalArguments:\"Assigning to '%0' in strict mode\",StrictEvalArgumentsBinding:\"Binding '%0' in strict mode\",StrictFunction:\"In strict mode code, functions can only be declared at top level or inside a block\",StrictNumericEscape:\"The only valid numeric escape in strict mode is '\\\\0'\",StrictOctalLiteral:\"Legacy octal literals are not allowed in strict mode\",StrictWith:\"'with' in strict mode\",SuperNotAllowed:\"super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",SuperPrivateField:\"Private fields can't be accessed on super\",TrailingDecorator:\"Decorators must be attached to a class element\",TupleExpressionBarIncorrectEndSyntaxType:\"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",TupleExpressionBarIncorrectStartSyntaxType:\"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",TupleExpressionHashIncorrectStartSyntaxType:\"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",UnexpectedArgumentPlaceholder:\"Unexpected argument placeholder\",UnexpectedAwaitAfterPipelineBody:'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal',UnexpectedDigitAfterHash:\"Unexpected digit after hash token\",UnexpectedImportExport:\"'import' and 'export' may only appear at the top level\",UnexpectedKeyword:\"Unexpected keyword '%0'\",UnexpectedLeadingDecorator:\"Leading decorators must be attached to a class declaration\",UnexpectedLexicalDeclaration:\"Lexical declaration cannot appear in a single-statement context\",UnexpectedNewTarget:\"new.target can only be used in functions\",UnexpectedNumericSeparator:\"A numeric separator is only allowed between two digits\",UnexpectedPrivateField:\"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",UnexpectedReservedWord:\"Unexpected reserved word '%0'\",UnexpectedSuper:\"super is only allowed in object methods and classes\",UnexpectedToken:\"Unexpected token '%0'\",UnexpectedTokenUnaryExponentiation:\"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",UnsupportedBind:\"Binding should be performed on object property.\",UnsupportedDecoratorExport:\"A decorated export must export a class declaration\",UnsupportedDefaultExport:\"Only expressions, functions or classes are allowed as the `default` export.\",UnsupportedImport:\"import can only be used in import() or import.meta\",UnsupportedMetaProperty:\"The only valid meta property for %0 is %0.%1\",UnsupportedParameterDecorator:\"Decorators cannot be used to decorate parameters\",UnsupportedPropertyDecorator:\"Decorators cannot be used to decorate object literal properties\",UnsupportedSuper:\"super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])\",UnterminatedComment:\"Unterminated comment\",UnterminatedRegExp:\"Unterminated regular expression\",UnterminatedString:\"Unterminated string constant\",UnterminatedTemplate:\"Unterminated template\",VarRedeclaration:\"Identifier '%0' has already been declared\",YieldBindingIdentifier:\"Can not use 'yield' as identifier inside a generator\",YieldInParameter:\"Yield expression is not allowed in formal parameters\",ZeroDigitNumericSeparator:\"Numeric separator can not be used after leading 0\"});class T{constructor(t,e,s,i){this.token=void 0,this.isExpr=void 0,this.preserveSpace=void 0,this.override=void 0,this.token=t,this.isExpr=!!e,this.preserveSpace=!!s,this.override=i}}const A={braceStatement:new T(\"{\",!1),braceExpression:new T(\"{\",!0),recordExpression:new T(\"#{\",!0),templateQuasi:new T(\"${\",!1),parenStatement:new T(\"(\",!1),parenExpression:new T(\"(\",!0),template:new T(\"`\",!0,!0,(t=>t.readTmplToken())),functionExpression:new T(\"function\",!0),functionStatement:new T(\"function\",!1)};l.parenR.updateContext=l.braceR.updateContext=function(){if(1===this.state.context.length)return void(this.state.exprAllowed=!0);let t=this.state.context.pop();t===A.braceStatement&&\"function\"===this.curContext().token&&(t=this.state.context.pop()),this.state.exprAllowed=!t.isExpr},l.name.updateContext=function(t){let e=!1;t!==l.dot&&(\"of\"!==this.state.value||this.state.exprAllowed||t===l._function||t===l._class||(e=!0)),this.state.exprAllowed=e,this.state.isIterator&&(this.state.isIterator=!1)},l.braceL.updateContext=function(t){this.state.context.push(this.braceIsBlock(t)?A.braceStatement:A.braceExpression),this.state.exprAllowed=!0},l.dollarBraceL.updateContext=function(){this.state.context.push(A.templateQuasi),this.state.exprAllowed=!0},l.parenL.updateContext=function(t){const e=t===l._if||t===l._for||t===l._with||t===l._while;this.state.context.push(e?A.parenStatement:A.parenExpression),this.state.exprAllowed=!0},l.incDec.updateContext=function(){},l._function.updateContext=l._class.updateContext=function(t){!t.beforeExpr||t===l.semi||t===l._else||t===l._return&&this.hasPrecedingLineBreak()||(t===l.colon||t===l.braceL)&&this.curContext()===A.b_stat?this.state.context.push(A.functionStatement):this.state.context.push(A.functionExpression),this.state.exprAllowed=!1},l.backQuote.updateContext=function(){this.curContext()===A.template?this.state.context.pop():this.state.context.push(A.template),this.state.exprAllowed=!1},l.braceHashL.updateContext=function(){this.state.context.push(A.recordExpression),this.state.exprAllowed=!0};let w=\"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\",E=\"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";const S=new RegExp(\"[\"+w+\"]\"),C=new RegExp(\"[\"+w+E+\"]\");w=E=null;const N=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938],k=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];function I(t,e){let s=65536;for(let i=0,r=e.length;i<r;i+=2){if(s+=e[i],s>t)return!1;if(s+=e[i+1],s>=t)return!0}return!1}function v(t){return t<65?36===t:t<=90||(t<97?95===t:t<=122||(t<=65535?t>=170&&S.test(String.fromCharCode(t)):I(t,N)))}function L(t){return t<48?36===t:t<58||!(t<65)&&(t<=90||(t<97?95===t:t<=122||(t<=65535?t>=170&&C.test(String.fromCharCode(t)):I(t,N)||I(t,k))))}const D=[\"implements\",\"interface\",\"let\",\"package\",\"private\",\"protected\",\"public\",\"static\",\"yield\"],M=[\"eval\",\"arguments\"],R=new Set([\"break\",\"case\",\"catch\",\"continue\",\"debugger\",\"default\",\"do\",\"else\",\"finally\",\"for\",\"function\",\"if\",\"return\",\"switch\",\"throw\",\"try\",\"var\",\"const\",\"while\",\"with\",\"new\",\"this\",\"super\",\"class\",\"extends\",\"export\",\"import\",\"null\",\"true\",\"false\",\"in\",\"instanceof\",\"typeof\",\"void\",\"delete\"]),O=new Set(D),F=new Set(M);function B(t,e){return e&&\"await\"===t||\"enum\"===t}function _(t,e){return B(t,e)||O.has(t)}function j(t){return F.has(t)}function U(t,e){return _(t,e)||j(t)}function q(t){return R.has(t)}const V=/^in(stanceof)?$/;const z=256,H=128,K=1024,W=2048;class J{constructor(t){this.flags=void 0,this.var=[],this.lexical=[],this.functions=[],this.flags=t}}class X{constructor(t,e){this.scopeStack=[],this.undefinedExports=new Map,this.undefinedPrivateNames=new Map,this.raise=t,this.inModule=e}get inFunction(){return(2&this.currentVarScope().flags)>0}get allowSuper(){return(16&this.currentThisScope().flags)>0}get allowDirectSuper(){return(32&this.currentThisScope().flags)>0}get inClass(){return(64&this.currentThisScope().flags)>0}get inStaticBlock(){return(128&this.currentThisScope().flags)>0}get inNonArrowFunction(){return(2&this.currentThisScope().flags)>0}get treatFunctionsAsVar(){return this.treatFunctionsAsVarInScope(this.currentScope())}createScope(t){return new J(t)}enter(t){this.scopeStack.push(this.createScope(t))}exit(){this.scopeStack.pop()}treatFunctionsAsVarInScope(t){return!!(2&t.flags||!this.inModule&&1&t.flags)}declareName(t,e,s){let i=this.currentScope();if(8&e||16&e)this.checkRedeclarationInScope(i,t,e,s),16&e?i.functions.push(t):i.lexical.push(t),8&e&&this.maybeExportDefined(i,t);else if(4&e)for(let r=this.scopeStack.length-1;r>=0&&(i=this.scopeStack[r],this.checkRedeclarationInScope(i,t,e,s),i.var.push(t),this.maybeExportDefined(i,t),!(259&i.flags));--r);this.inModule&&1&i.flags&&this.undefinedExports.delete(t)}maybeExportDefined(t,e){this.inModule&&1&t.flags&&this.undefinedExports.delete(e)}checkRedeclarationInScope(t,e,s,i){this.isRedeclaredInScope(t,e,s)&&this.raise(i,b.VarRedeclaration,e)}isRedeclaredInScope(t,e,s){return!!(1&s)&&(8&s?t.lexical.indexOf(e)>-1||t.functions.indexOf(e)>-1||t.var.indexOf(e)>-1:16&s?t.lexical.indexOf(e)>-1||!this.treatFunctionsAsVarInScope(t)&&t.var.indexOf(e)>-1:t.lexical.indexOf(e)>-1&&!(8&t.flags&&t.lexical[0]===e)||!this.treatFunctionsAsVarInScope(t)&&t.functions.indexOf(e)>-1)}checkLocalExport(t){-1===this.scopeStack[0].lexical.indexOf(t.name)&&-1===this.scopeStack[0].var.indexOf(t.name)&&-1===this.scopeStack[0].functions.indexOf(t.name)&&this.undefinedExports.set(t.name,t.start)}currentScope(){return this.scopeStack[this.scopeStack.length-1]}currentVarScope(){for(let t=this.scopeStack.length-1;;t--){const e=this.scopeStack[t];if(259&e.flags)return e}}currentThisScope(){for(let t=this.scopeStack.length-1;;t--){const e=this.scopeStack[t];if((259&e.flags||64&e.flags)&&!(4&e.flags))return e}}}class G extends J{constructor(...t){super(...t),this.declareFunctions=[]}}class Q extends X{createScope(t){return new G(t)}declareName(t,e,s){const i=this.currentScope();if(e&W)return this.checkRedeclarationInScope(i,t,e,s),this.maybeExportDefined(i,t),void i.declareFunctions.push(t);super.declareName(...arguments)}isRedeclaredInScope(t,e,s){return!!super.isRedeclaredInScope(...arguments)||!!(s&W)&&(!t.declareFunctions.includes(e)&&(t.lexical.includes(e)||t.functions.includes(e)))}checkLocalExport(t){-1===this.scopeStack[0].declareFunctions.indexOf(t.name)&&super.checkLocalExport(t)}}const Y=new Set([\"_\",\"any\",\"bool\",\"boolean\",\"empty\",\"extends\",\"false\",\"interface\",\"mixed\",\"null\",\"number\",\"static\",\"string\",\"true\",\"typeof\",\"void\"]),$=Object.freeze({AmbiguousConditionalArrow:\"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",AmbiguousDeclareModuleKind:\"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\",AssignReservedType:\"Cannot overwrite reserved type %0\",DeclareClassElement:\"The `declare` modifier can only appear on class fields.\",DeclareClassFieldInitializer:\"Initializers are not allowed in fields with the `declare` modifier.\",DuplicateDeclareModuleExports:\"Duplicate `declare module.exports` statement\",EnumBooleanMemberNotInitialized:\"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",EnumDuplicateMemberName:\"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",EnumInconsistentMemberValues:\"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",EnumInvalidExplicitType:\"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",EnumInvalidExplicitTypeUnknownSupplied:\"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",EnumInvalidMemberInitializerPrimaryType:\"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",EnumInvalidMemberInitializerSymbolType:\"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",EnumInvalidMemberInitializerUnknownType:\"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",EnumInvalidMemberName:\"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",EnumNumberMemberNotInitialized:\"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",EnumStringMemberInconsistentlyInitailized:\"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",ImportTypeShorthandOnlyInPureImport:\"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\",InexactInsideExact:\"Explicit inexact syntax cannot appear inside an explicit exact object type\",InexactInsideNonObject:\"Explicit inexact syntax cannot appear in class or interface definitions\",InexactVariance:\"Explicit inexact syntax cannot have variance\",InvalidNonTypeImportInDeclareModule:\"Imports within a `declare module` body must always be `import type` or `import typeof`\",MissingTypeParamDefault:\"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",NestedDeclareModule:\"`declare module` cannot be used inside another `declare module`\",NestedFlowComment:\"Cannot have a flow comment inside another flow comment\",OptionalBindingPattern:\"A binding pattern parameter cannot be optional in an implementation signature.\",SpreadVariance:\"Spread properties cannot have variance\",TypeBeforeInitializer:\"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",TypeCastInPattern:\"The type cast expression is expected to be wrapped with parenthesis\",UnexpectedExplicitInexactInObject:\"Explicit inexact syntax must appear at the end of an inexact object\",UnexpectedReservedType:\"Unexpected reserved type %0\",UnexpectedReservedUnderscore:\"`_` is only allowed as a type argument to call or new\",UnexpectedSpaceBetweenModuloChecks:\"Spaces between `%` and `checks` are not allowed here.\",UnexpectedSpreadType:\"Spread operator cannot appear in class or interface definitions\",UnexpectedSubtractionOperand:'Unexpected token, expected \"number\" or \"bigint\"',UnexpectedTokenAfterTypeParameter:\"Expected an arrow function after this type parameter declaration\",UnexpectedTypeParameterBeforeAsyncArrowFunction:\"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",UnsupportedDeclareExportKind:\"`declare export %0` is not supported. Use `%1` instead\",UnsupportedStatementInDeclareModule:\"Only declares and type imports are allowed inside declare module\",UnterminatedFlowComment:\"Unterminated flow-comment\"});function Z(t){return\"type\"===t.importKind||\"typeof\"===t.importKind}function tt(t){return(t.type===l.name||!!t.type.keyword)&&\"from\"!==t.value}const et={const:\"declare export var\",let:\"declare export var\",type:\"export type\",interface:\"export interface\"};const st=/\\*?\\s*@((?:no)?flow)\\b/;const it={quot:'\"',amp:\"&\",apos:\"'\",lt:\"<\",gt:\">\",nbsp:\"\\xa0\",iexcl:\"\\xa1\",cent:\"\\xa2\",pound:\"\\xa3\",curren:\"\\xa4\",yen:\"\\xa5\",brvbar:\"\\xa6\",sect:\"\\xa7\",uml:\"\\xa8\",copy:\"\\xa9\",ordf:\"\\xaa\",laquo:\"\\xab\",not:\"\\xac\",shy:\"\\xad\",reg:\"\\xae\",macr:\"\\xaf\",deg:\"\\xb0\",plusmn:\"\\xb1\",sup2:\"\\xb2\",sup3:\"\\xb3\",acute:\"\\xb4\",micro:\"\\xb5\",para:\"\\xb6\",middot:\"\\xb7\",cedil:\"\\xb8\",sup1:\"\\xb9\",ordm:\"\\xba\",raquo:\"\\xbb\",frac14:\"\\xbc\",frac12:\"\\xbd\",frac34:\"\\xbe\",iquest:\"\\xbf\",Agrave:\"\\xc0\",Aacute:\"\\xc1\",Acirc:\"\\xc2\",Atilde:\"\\xc3\",Auml:\"\\xc4\",Aring:\"\\xc5\",AElig:\"\\xc6\",Ccedil:\"\\xc7\",Egrave:\"\\xc8\",Eacute:\"\\xc9\",Ecirc:\"\\xca\",Euml:\"\\xcb\",Igrave:\"\\xcc\",Iacute:\"\\xcd\",Icirc:\"\\xce\",Iuml:\"\\xcf\",ETH:\"\\xd0\",Ntilde:\"\\xd1\",Ograve:\"\\xd2\",Oacute:\"\\xd3\",Ocirc:\"\\xd4\",Otilde:\"\\xd5\",Ouml:\"\\xd6\",times:\"\\xd7\",Oslash:\"\\xd8\",Ugrave:\"\\xd9\",Uacute:\"\\xda\",Ucirc:\"\\xdb\",Uuml:\"\\xdc\",Yacute:\"\\xdd\",THORN:\"\\xde\",szlig:\"\\xdf\",agrave:\"\\xe0\",aacute:\"\\xe1\",acirc:\"\\xe2\",atilde:\"\\xe3\",auml:\"\\xe4\",aring:\"\\xe5\",aelig:\"\\xe6\",ccedil:\"\\xe7\",egrave:\"\\xe8\",eacute:\"\\xe9\",ecirc:\"\\xea\",euml:\"\\xeb\",igrave:\"\\xec\",iacute:\"\\xed\",icirc:\"\\xee\",iuml:\"\\xef\",eth:\"\\xf0\",ntilde:\"\\xf1\",ograve:\"\\xf2\",oacute:\"\\xf3\",ocirc:\"\\xf4\",otilde:\"\\xf5\",ouml:\"\\xf6\",divide:\"\\xf7\",oslash:\"\\xf8\",ugrave:\"\\xf9\",uacute:\"\\xfa\",ucirc:\"\\xfb\",uuml:\"\\xfc\",yacute:\"\\xfd\",thorn:\"\\xfe\",yuml:\"\\xff\",OElig:\"\\u0152\",oelig:\"\\u0153\",Scaron:\"\\u0160\",scaron:\"\\u0161\",Yuml:\"\\u0178\",fnof:\"\\u0192\",circ:\"\\u02c6\",tilde:\"\\u02dc\",Alpha:\"\\u0391\",Beta:\"\\u0392\",Gamma:\"\\u0393\",Delta:\"\\u0394\",Epsilon:\"\\u0395\",Zeta:\"\\u0396\",Eta:\"\\u0397\",Theta:\"\\u0398\",Iota:\"\\u0399\",Kappa:\"\\u039a\",Lambda:\"\\u039b\",Mu:\"\\u039c\",Nu:\"\\u039d\",Xi:\"\\u039e\",Omicron:\"\\u039f\",Pi:\"\\u03a0\",Rho:\"\\u03a1\",Sigma:\"\\u03a3\",Tau:\"\\u03a4\",Upsilon:\"\\u03a5\",Phi:\"\\u03a6\",Chi:\"\\u03a7\",Psi:\"\\u03a8\",Omega:\"\\u03a9\",alpha:\"\\u03b1\",beta:\"\\u03b2\",gamma:\"\\u03b3\",delta:\"\\u03b4\",epsilon:\"\\u03b5\",zeta:\"\\u03b6\",eta:\"\\u03b7\",theta:\"\\u03b8\",iota:\"\\u03b9\",kappa:\"\\u03ba\",lambda:\"\\u03bb\",mu:\"\\u03bc\",nu:\"\\u03bd\",xi:\"\\u03be\",omicron:\"\\u03bf\",pi:\"\\u03c0\",rho:\"\\u03c1\",sigmaf:\"\\u03c2\",sigma:\"\\u03c3\",tau:\"\\u03c4\",upsilon:\"\\u03c5\",phi:\"\\u03c6\",chi:\"\\u03c7\",psi:\"\\u03c8\",omega:\"\\u03c9\",thetasym:\"\\u03d1\",upsih:\"\\u03d2\",piv:\"\\u03d6\",ensp:\"\\u2002\",emsp:\"\\u2003\",thinsp:\"\\u2009\",zwnj:\"\\u200c\",zwj:\"\\u200d\",lrm:\"\\u200e\",rlm:\"\\u200f\",ndash:\"\\u2013\",mdash:\"\\u2014\",lsquo:\"\\u2018\",rsquo:\"\\u2019\",sbquo:\"\\u201a\",ldquo:\"\\u201c\",rdquo:\"\\u201d\",bdquo:\"\\u201e\",dagger:\"\\u2020\",Dagger:\"\\u2021\",bull:\"\\u2022\",hellip:\"\\u2026\",permil:\"\\u2030\",prime:\"\\u2032\",Prime:\"\\u2033\",lsaquo:\"\\u2039\",rsaquo:\"\\u203a\",oline:\"\\u203e\",frasl:\"\\u2044\",euro:\"\\u20ac\",image:\"\\u2111\",weierp:\"\\u2118\",real:\"\\u211c\",trade:\"\\u2122\",alefsym:\"\\u2135\",larr:\"\\u2190\",uarr:\"\\u2191\",rarr:\"\\u2192\",darr:\"\\u2193\",harr:\"\\u2194\",crarr:\"\\u21b5\",lArr:\"\\u21d0\",uArr:\"\\u21d1\",rArr:\"\\u21d2\",dArr:\"\\u21d3\",hArr:\"\\u21d4\",forall:\"\\u2200\",part:\"\\u2202\",exist:\"\\u2203\",empty:\"\\u2205\",nabla:\"\\u2207\",isin:\"\\u2208\",notin:\"\\u2209\",ni:\"\\u220b\",prod:\"\\u220f\",sum:\"\\u2211\",minus:\"\\u2212\",lowast:\"\\u2217\",radic:\"\\u221a\",prop:\"\\u221d\",infin:\"\\u221e\",ang:\"\\u2220\",and:\"\\u2227\",or:\"\\u2228\",cap:\"\\u2229\",cup:\"\\u222a\",int:\"\\u222b\",there4:\"\\u2234\",sim:\"\\u223c\",cong:\"\\u2245\",asymp:\"\\u2248\",ne:\"\\u2260\",equiv:\"\\u2261\",le:\"\\u2264\",ge:\"\\u2265\",sub:\"\\u2282\",sup:\"\\u2283\",nsub:\"\\u2284\",sube:\"\\u2286\",supe:\"\\u2287\",oplus:\"\\u2295\",otimes:\"\\u2297\",perp:\"\\u22a5\",sdot:\"\\u22c5\",lceil:\"\\u2308\",rceil:\"\\u2309\",lfloor:\"\\u230a\",rfloor:\"\\u230b\",lang:\"\\u2329\",rang:\"\\u232a\",loz:\"\\u25ca\",spades:\"\\u2660\",clubs:\"\\u2663\",hearts:\"\\u2665\",diams:\"\\u2666\"},rt=/^[\\da-fA-F]+$/,at=/^\\d+$/,nt=Object.freeze({AttributeIsEmpty:\"JSX attributes must only be assigned a non-empty expression\",MissingClosingTagFragment:\"Expected corresponding JSX closing tag for <>\",MissingClosingTagElement:\"Expected corresponding JSX closing tag for <%0>\",UnexpectedSequenceExpression:\"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",UnsupportedJsxValue:\"JSX value should be either an expression or a quoted JSX text\",UnterminatedJsxContent:\"Unterminated JSX contents\",UnwrappedAdjacentJSXElements:\"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"});function ot(t){return!!t&&(\"JSXOpeningFragment\"===t.type||\"JSXClosingFragment\"===t.type)}function ht(t){if(\"JSXIdentifier\"===t.type)return t.name;if(\"JSXNamespacedName\"===t.type)return t.namespace.name+\":\"+t.name.name;if(\"JSXMemberExpression\"===t.type)return ht(t.object)+\".\"+ht(t.property);throw new Error(\"Node had unexpected type: \"+t.type)}A.j_oTag=new T(\"<tag\",!1),A.j_cTag=new T(\"</tag\",!1),A.j_expr=new T(\"<tag>...</tag>\",!0,!0),l.jsxName=new o(\"jsxName\"),l.jsxText=new o(\"jsxText\",{beforeExpr:!0}),l.jsxTagStart=new o(\"jsxTagStart\",{startsExpr:!0}),l.jsxTagEnd=new o(\"jsxTagEnd\"),l.jsxTagStart.updateContext=function(){this.state.context.push(A.j_expr),this.state.context.push(A.j_oTag),this.state.exprAllowed=!1},l.jsxTagEnd.updateContext=function(t){const e=this.state.context.pop();e===A.j_oTag&&t===l.slash||e===A.j_cTag?(this.state.context.pop(),this.state.exprAllowed=this.curContext()===A.j_expr):this.state.exprAllowed=!0};class pt extends J{constructor(...t){super(...t),this.types=[],this.enums=[],this.constEnums=[],this.classes=[],this.exportOnlyBindings=[]}}class ct extends X{createScope(t){return new pt(t)}declareName(t,e,s){const i=this.currentScope();if(e&K)return this.maybeExportDefined(i,t),void i.exportOnlyBindings.push(t);super.declareName(...arguments),2&e&&(1&e||(this.checkRedeclarationInScope(i,t,e,s),this.maybeExportDefined(i,t)),i.types.push(t)),256&e&&i.enums.push(t),512&e&&i.constEnums.push(t),e&H&&i.classes.push(t)}isRedeclaredInScope(t,e,s){if(t.enums.indexOf(e)>-1){if(256&s){return!!(512&s)!==t.constEnums.indexOf(e)>-1}return!0}return s&H&&t.classes.indexOf(e)>-1?t.lexical.indexOf(e)>-1&&!!(1&s):!!(2&s&&t.types.indexOf(e)>-1)||super.isRedeclaredInScope(...arguments)}checkLocalExport(t){-1===this.scopeStack[0].types.indexOf(t.name)&&-1===this.scopeStack[0].exportOnlyBindings.indexOf(t.name)&&super.checkLocalExport(t)}}class lt{constructor(){this.stacks=[]}enter(t){this.stacks.push(t)}exit(){this.stacks.pop()}currentFlags(){return this.stacks[this.stacks.length-1]}get hasAwait(){return(2&this.currentFlags())>0}get hasYield(){return(1&this.currentFlags())>0}get hasReturn(){return(4&this.currentFlags())>0}get hasIn(){return(8&this.currentFlags())>0}}function ut(t,e){return(t?2:0)|(e?1:0)}function dt(t){if(null==t)throw new Error(`Unexpected ${t} value.`);return t}function mt(t){if(!t)throw new Error(\"Assert fail\")}const ft=Object.freeze({ClassMethodHasDeclare:\"Class methods cannot have the 'declare' modifier\",ClassMethodHasReadonly:\"Class methods cannot have the 'readonly' modifier\",ConstructorHasTypeParameters:\"Type parameters cannot appear on a constructor declaration.\",DeclareClassFieldHasInitializer:\"Initializers are not allowed in ambient contexts.\",DeclareFunctionHasImplementation:\"An implementation cannot be declared in ambient contexts.\",DuplicateModifier:\"Duplicate modifier: '%0'\",DuplicateAccessibilityModifier:\"Accessibility modifier already seen.\",EmptyHeritageClauseType:\"'%0' list cannot be empty.\",EmptyTypeArguments:\"Type argument list cannot be empty.\",EmptyTypeParameters:\"Type parameter list cannot be empty.\",ExpectedAmbientAfterExportDeclare:\"'export declare' must be followed by an ambient declaration.\",IndexSignatureHasAbstract:\"Index signatures cannot have the 'abstract' modifier\",IndexSignatureHasAccessibility:\"Index signatures cannot have an accessibility modifier ('%0')\",IndexSignatureHasStatic:\"Index signatures cannot have the 'static' modifier\",IndexSignatureHasDeclare:\"Index signatures cannot have the 'declare' modifier\",InvalidModifierOnTypeMember:\"'%0' modifier cannot appear on a type member.\",InvalidTupleMemberLabel:\"Tuple members must be labeled with a simple identifier.\",MixedLabeledAndUnlabeledElements:\"Tuple members must all have names or all not have names.\",NonAbstractClassHasAbstractMethod:\"Abstract methods can only appear within an abstract class.\",NonClassMethodPropertyHasAbstractModifer:\"'abstract' modifier can only appear on a class, method, or property declaration.\",OptionalTypeBeforeRequired:\"A required element cannot follow an optional element.\",PatternIsOptional:\"A binding pattern parameter cannot be optional in an implementation signature.\",PrivateElementHasAbstract:\"Private elements cannot have the 'abstract' modifier.\",PrivateElementHasAccessibility:\"Private elements cannot have an accessibility modifier ('%0')\",ReadonlyForMethodSignature:\"'readonly' modifier can only appear on a property declaration or index signature.\",TypeAnnotationAfterAssign:\"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",UnexpectedParameterModifier:\"A parameter property is only allowed in a constructor implementation.\",UnexpectedReadonly:\"'readonly' type modifier is only permitted on array and tuple literal types.\",UnexpectedTypeAnnotation:\"Did not expect a type annotation here.\",UnexpectedTypeCastInParameter:\"Unexpected type cast in parameter position.\",UnsupportedImportTypeArgument:\"Argument in a type import must be a string literal\",UnsupportedParameterPropertyKind:\"A parameter property may not be declared using a binding pattern.\",UnsupportedSignatureParameterKind:\"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0\"});function yt(t){return\"private\"===t||\"public\"===t||\"protected\"===t}l.placeholder=new o(\"%%\",{startsExpr:!0});function xt(t,e){return t.some((t=>Array.isArray(t)?t[0]===e:t===e))}function Pt(t,e,s){const i=t.find((t=>Array.isArray(t)?t[0]===e:t===e));return i&&Array.isArray(i)?i[1][s]:null}const gt=[\"minimal\",\"smart\",\"fsharp\"],bt=[\"hash\",\"bar\"];const Tt={estree:t=>class extends t{estreeParseRegExpLiteral({pattern:t,flags:e}){let s=null;try{s=new RegExp(t,e)}catch(r){}const i=this.estreeParseLiteral(s);return i.regex={pattern:t,flags:e},i}estreeParseBigIntLiteral(t){let e;try{e=BigInt(t)}catch(i){e=null}const s=this.estreeParseLiteral(e);return s.bigint=String(s.value||t),s}estreeParseDecimalLiteral(t){const e=this.estreeParseLiteral(null);return e.decimal=String(e.value||t),e}estreeParseLiteral(t){return this.parseLiteral(t,\"Literal\")}directiveToStmt(t){const e=t.value,s=this.startNodeAt(t.start,t.loc.start),i=this.startNodeAt(e.start,e.loc.start);return i.value=e.extra.expressionValue,i.raw=e.extra.raw,s.expression=this.finishNodeAt(i,\"Literal\",e.end,e.loc.end),s.directive=e.extra.raw.slice(1,-1),this.finishNodeAt(s,\"ExpressionStatement\",t.end,t.loc.end)}initFunction(t,e){super.initFunction(t,e),t.expression=!1}checkDeclaration(t){null!=t&&this.isObjectProperty(t)?this.checkDeclaration(t.value):super.checkDeclaration(t)}getObjectOrClassMethodParams(t){return t.value.params}isValidDirective(t){var e;return\"ExpressionStatement\"===t.type&&\"Literal\"===t.expression.type&&\"string\"===typeof t.expression.value&&!(null==(e=t.expression.extra)?void 0:e.parenthesized)}stmtToDirective(t){const e=super.stmtToDirective(t),s=t.expression.value;return this.addExtra(e.value,\"expressionValue\",s),e}parseBlockBody(t,...e){super.parseBlockBody(t,...e);const s=t.directives.map((t=>this.directiveToStmt(t)));t.body=s.concat(t.body),delete t.directives}pushClassMethod(t,e,s,i,r,a){this.parseMethod(e,s,i,r,a,\"ClassMethod\",!0),e.typeParameters&&(e.value.typeParameters=e.typeParameters,delete e.typeParameters),t.body.push(e)}parseExprAtom(t){switch(this.state.type){case l.num:case l.string:return this.estreeParseLiteral(this.state.value);case l.regexp:return this.estreeParseRegExpLiteral(this.state.value);case l.bigint:return this.estreeParseBigIntLiteral(this.state.value);case l.decimal:return this.estreeParseDecimalLiteral(this.state.value);case l._null:return this.estreeParseLiteral(null);case l._true:return this.estreeParseLiteral(!0);case l._false:return this.estreeParseLiteral(!1);default:return super.parseExprAtom(t)}}parseLiteral(t,e,s,i){const r=super.parseLiteral(t,e,s,i);return r.raw=r.extra.raw,delete r.extra,r}parseFunctionBody(t,e,s=!1){super.parseFunctionBody(t,e,s),t.expression=\"BlockStatement\"!==t.body.type}parseMethod(t,e,s,i,r,a,n=!1){let o=this.startNode();return o.kind=t.kind,o=super.parseMethod(o,e,s,i,r,a,n),o.type=\"FunctionExpression\",delete o.kind,t.value=o,a=\"ClassMethod\"===a?\"MethodDefinition\":a,this.finishNode(t,a)}parseObjectMethod(t,e,s,i,r){const a=super.parseObjectMethod(t,e,s,i,r);return a&&(a.type=\"Property\",\"method\"===a.kind&&(a.kind=\"init\"),a.shorthand=!1),a}parseObjectProperty(t,e,s,i,r){const a=super.parseObjectProperty(t,e,s,i,r);return a&&(a.kind=\"init\",a.type=\"Property\"),a}toAssignable(t,e=!1){return null!=t&&this.isObjectProperty(t)?(this.toAssignable(t.value,e),t):super.toAssignable(t,e)}toAssignableObjectExpressionProp(t,...e){\"get\"===t.kind||\"set\"===t.kind?this.raise(t.key.start,b.PatternHasAccessor):t.method?this.raise(t.key.start,b.PatternHasMethod):super.toAssignableObjectExpressionProp(t,...e)}finishCallExpression(t,e){return super.finishCallExpression(t,e),\"Import\"===t.callee.type&&(t.type=\"ImportExpression\",t.source=t.arguments[0],delete t.arguments,delete t.callee),t}toReferencedArguments(t){\"ImportExpression\"!==t.type&&super.toReferencedArguments(t)}parseExport(t){switch(super.parseExport(t),t.type){case\"ExportAllDeclaration\":t.exported=null;break;case\"ExportNamedDeclaration\":1===t.specifiers.length&&\"ExportNamespaceSpecifier\"===t.specifiers[0].type&&(t.type=\"ExportAllDeclaration\",t.exported=t.specifiers[0].exported,delete t.specifiers)}return t}parseSubscript(t,e,s,i,r){const a=super.parseSubscript(t,e,s,i,r);if(r.optionalChainMember){if(\"OptionalMemberExpression\"!==a.type&&\"OptionalCallExpression\"!==a.type||(a.type=a.type.substring(8)),r.stop){const t=this.startNodeAtNode(a);return t.expression=a,this.finishNode(t,\"ChainExpression\")}}else\"MemberExpression\"!==a.type&&\"CallExpression\"!==a.type||(a.optional=!1);return a}hasPropertyAsPrivateName(t){return\"ChainExpression\"===t.type&&(t=t.expression),super.hasPropertyAsPrivateName(t)}isOptionalChain(t){return\"ChainExpression\"===t.type}isObjectProperty(t){return\"Property\"===t.type&&\"init\"===t.kind&&!t.method}isObjectMethod(t){return t.method||\"get\"===t.kind||\"set\"===t.kind}},jsx:t=>class extends t{jsxReadToken(){let t=\"\",e=this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,nt.UnterminatedJsxContent);const s=this.input.charCodeAt(this.state.pos);switch(s){case 60:case 123:return this.state.pos===this.state.start?60===s&&this.state.exprAllowed?(++this.state.pos,this.finishToken(l.jsxTagStart)):super.getTokenFromCode(s):(t+=this.input.slice(e,this.state.pos),this.finishToken(l.jsxText,t));case 38:t+=this.input.slice(e,this.state.pos),t+=this.jsxReadEntity(),e=this.state.pos;break;case 62:case 125:default:m(s)?(t+=this.input.slice(e,this.state.pos),t+=this.jsxReadNewLine(!0),e=this.state.pos):++this.state.pos}}}jsxReadNewLine(t){const e=this.input.charCodeAt(this.state.pos);let s;return++this.state.pos,13===e&&10===this.input.charCodeAt(this.state.pos)?(++this.state.pos,s=t?\"\\n\":\"\\r\\n\"):s=String.fromCharCode(e),++this.state.curLine,this.state.lineStart=this.state.pos,s}jsxReadString(t){let e=\"\",s=++this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,b.UnterminatedString);const i=this.input.charCodeAt(this.state.pos);if(i===t)break;38===i?(e+=this.input.slice(s,this.state.pos),e+=this.jsxReadEntity(),s=this.state.pos):m(i)?(e+=this.input.slice(s,this.state.pos),e+=this.jsxReadNewLine(!1),s=this.state.pos):++this.state.pos}return e+=this.input.slice(s,this.state.pos++),this.finishToken(l.string,e)}jsxReadEntity(){let t,e=\"\",s=0,i=this.input[this.state.pos];const r=++this.state.pos;for(;this.state.pos<this.length&&s++<10;){if(i=this.input[this.state.pos++],\";\"===i){\"#\"===e[0]?\"x\"===e[1]?(e=e.substr(2),rt.test(e)&&(t=String.fromCodePoint(parseInt(e,16)))):(e=e.substr(1),at.test(e)&&(t=String.fromCodePoint(parseInt(e,10)))):t=it[e];break}e+=i}return t||(this.state.pos=r,\"&\")}jsxReadWord(){let t;const e=this.state.pos;do{t=this.input.charCodeAt(++this.state.pos)}while(L(t)||45===t);return this.finishToken(l.jsxName,this.input.slice(e,this.state.pos))}jsxParseIdentifier(){const t=this.startNode();return this.match(l.jsxName)?t.name=this.state.value:this.state.type.keyword?t.name=this.state.type.keyword:this.unexpected(),this.next(),this.finishNode(t,\"JSXIdentifier\")}jsxParseNamespacedName(){const t=this.state.start,e=this.state.startLoc,s=this.jsxParseIdentifier();if(!this.eat(l.colon))return s;const i=this.startNodeAt(t,e);return i.namespace=s,i.name=this.jsxParseIdentifier(),this.finishNode(i,\"JSXNamespacedName\")}jsxParseElementName(){const t=this.state.start,e=this.state.startLoc;let s=this.jsxParseNamespacedName();if(\"JSXNamespacedName\"===s.type)return s;for(;this.eat(l.dot);){const i=this.startNodeAt(t,e);i.object=s,i.property=this.jsxParseIdentifier(),s=this.finishNode(i,\"JSXMemberExpression\")}return s}jsxParseAttributeValue(){let t;switch(this.state.type){case l.braceL:return t=this.startNode(),this.next(),t=this.jsxParseExpressionContainer(t),\"JSXEmptyExpression\"===t.expression.type&&this.raise(t.start,nt.AttributeIsEmpty),t;case l.jsxTagStart:case l.string:return this.parseExprAtom();default:throw this.raise(this.state.start,nt.UnsupportedJsxValue)}}jsxParseEmptyExpression(){const t=this.startNodeAt(this.state.lastTokEnd,this.state.lastTokEndLoc);return this.finishNodeAt(t,\"JSXEmptyExpression\",this.state.start,this.state.startLoc)}jsxParseSpreadChild(t){return this.next(),t.expression=this.parseExpression(),this.expect(l.braceR),this.finishNode(t,\"JSXSpreadChild\")}jsxParseExpressionContainer(t){if(this.match(l.braceR))t.expression=this.jsxParseEmptyExpression();else{const e=this.parseExpression();t.expression=e}return this.expect(l.braceR),this.finishNode(t,\"JSXExpressionContainer\")}jsxParseAttribute(){const t=this.startNode();return this.eat(l.braceL)?(this.expect(l.ellipsis),t.argument=this.parseMaybeAssignAllowIn(),this.expect(l.braceR),this.finishNode(t,\"JSXSpreadAttribute\")):(t.name=this.jsxParseNamespacedName(),t.value=this.eat(l.eq)?this.jsxParseAttributeValue():null,this.finishNode(t,\"JSXAttribute\"))}jsxParseOpeningElementAt(t,e){const s=this.startNodeAt(t,e);return this.match(l.jsxTagEnd)?(this.expect(l.jsxTagEnd),this.finishNode(s,\"JSXOpeningFragment\")):(s.name=this.jsxParseElementName(),this.jsxParseOpeningElementAfterName(s))}jsxParseOpeningElementAfterName(t){const e=[];for(;!this.match(l.slash)&&!this.match(l.jsxTagEnd);)e.push(this.jsxParseAttribute());return t.attributes=e,t.selfClosing=this.eat(l.slash),this.expect(l.jsxTagEnd),this.finishNode(t,\"JSXOpeningElement\")}jsxParseClosingElementAt(t,e){const s=this.startNodeAt(t,e);return this.match(l.jsxTagEnd)?(this.expect(l.jsxTagEnd),this.finishNode(s,\"JSXClosingFragment\")):(s.name=this.jsxParseElementName(),this.expect(l.jsxTagEnd),this.finishNode(s,\"JSXClosingElement\"))}jsxParseElementAt(t,e){const s=this.startNodeAt(t,e),i=[],r=this.jsxParseOpeningElementAt(t,e);let a=null;if(!r.selfClosing){t:for(;;)switch(this.state.type){case l.jsxTagStart:if(t=this.state.start,e=this.state.startLoc,this.next(),this.eat(l.slash)){a=this.jsxParseClosingElementAt(t,e);break t}i.push(this.jsxParseElementAt(t,e));break;case l.jsxText:i.push(this.parseExprAtom());break;case l.braceL:{const t=this.startNode();this.next(),this.match(l.ellipsis)?i.push(this.jsxParseSpreadChild(t)):i.push(this.jsxParseExpressionContainer(t));break}default:throw this.unexpected()}ot(r)&&!ot(a)?this.raise(a.start,nt.MissingClosingTagFragment):!ot(r)&&ot(a)?this.raise(a.start,nt.MissingClosingTagElement,ht(r.name)):ot(r)||ot(a)||ht(a.name)!==ht(r.name)&&this.raise(a.start,nt.MissingClosingTagElement,ht(r.name))}if(ot(r)?(s.openingFragment=r,s.closingFragment=a):(s.openingElement=r,s.closingElement=a),s.children=i,this.isRelational(\"<\"))throw this.raise(this.state.start,nt.UnwrappedAdjacentJSXElements);return ot(r)?this.finishNode(s,\"JSXFragment\"):this.finishNode(s,\"JSXElement\")}jsxParseElement(){const t=this.state.start,e=this.state.startLoc;return this.next(),this.jsxParseElementAt(t,e)}parseExprAtom(t){return this.match(l.jsxText)?this.parseLiteral(this.state.value,\"JSXText\"):this.match(l.jsxTagStart)?this.jsxParseElement():this.isRelational(\"<\")&&33!==this.input.charCodeAt(this.state.pos)?(this.finishToken(l.jsxTagStart),this.jsxParseElement()):super.parseExprAtom(t)}getTokenFromCode(t){if(this.state.inPropertyName)return super.getTokenFromCode(t);const e=this.curContext();if(e===A.j_expr)return this.jsxReadToken();if(e===A.j_oTag||e===A.j_cTag){if(v(t))return this.jsxReadWord();if(62===t)return++this.state.pos,this.finishToken(l.jsxTagEnd);if((34===t||39===t)&&e===A.j_oTag)return this.jsxReadString(t)}return 60===t&&this.state.exprAllowed&&33!==this.input.charCodeAt(this.state.pos+1)?(++this.state.pos,this.finishToken(l.jsxTagStart)):super.getTokenFromCode(t)}updateContext(t){if(this.match(l.braceL)){const e=this.curContext();e===A.j_oTag?this.state.context.push(A.braceExpression):e===A.j_expr?this.state.context.push(A.templateQuasi):super.updateContext(t),this.state.exprAllowed=!0}else{if(!this.match(l.slash)||t!==l.jsxTagStart)return super.updateContext(t);this.state.context.length-=2,this.state.context.push(A.j_cTag),this.state.exprAllowed=!1}}},flow:t=>class extends t{constructor(...t){super(...t),this.flowPragma=void 0}getScopeHandler(){return Q}shouldParseTypes(){return this.getPluginOption(\"flow\",\"all\")||\"flow\"===this.flowPragma}shouldParseEnums(){return!!this.getPluginOption(\"flow\",\"enums\")}finishToken(t,e){return t!==l.string&&t!==l.semi&&t!==l.interpreterDirective&&void 0===this.flowPragma&&(this.flowPragma=null),super.finishToken(t,e)}addComment(t){if(void 0===this.flowPragma){const e=st.exec(t.value);if(e)if(\"flow\"===e[1])this.flowPragma=\"flow\";else{if(\"noflow\"!==e[1])throw new Error(\"Unexpected flow pragma\");this.flowPragma=\"noflow\"}else;}return super.addComment(t)}flowParseTypeInitialiser(t){const e=this.state.inType;this.state.inType=!0,this.expect(t||l.colon);const s=this.flowParseType();return this.state.inType=e,s}flowParsePredicate(){const t=this.startNode(),e=this.state.startLoc,s=this.state.start;this.expect(l.modulo);const i=this.state.startLoc;return this.expectContextual(\"checks\"),e.line===i.line&&e.column===i.column-1||this.raise(s,$.UnexpectedSpaceBetweenModuloChecks),this.eat(l.parenL)?(t.value=this.parseExpression(),this.expect(l.parenR),this.finishNode(t,\"DeclaredPredicate\")):this.finishNode(t,\"InferredPredicate\")}flowParseTypeAndPredicateInitialiser(){const t=this.state.inType;this.state.inType=!0,this.expect(l.colon);let e=null,s=null;return this.match(l.modulo)?(this.state.inType=t,s=this.flowParsePredicate()):(e=this.flowParseType(),this.state.inType=t,this.match(l.modulo)&&(s=this.flowParsePredicate())),[e,s]}flowParseDeclareClass(t){return this.next(),this.flowParseInterfaceish(t,!0),this.finishNode(t,\"DeclareClass\")}flowParseDeclareFunction(t){this.next();const e=t.id=this.parseIdentifier(),s=this.startNode(),i=this.startNode();this.isRelational(\"<\")?s.typeParameters=this.flowParseTypeParameterDeclaration():s.typeParameters=null,this.expect(l.parenL);const r=this.flowParseFunctionTypeParams();return s.params=r.params,s.rest=r.rest,this.expect(l.parenR),[s.returnType,t.predicate]=this.flowParseTypeAndPredicateInitialiser(),i.typeAnnotation=this.finishNode(s,\"FunctionTypeAnnotation\"),e.typeAnnotation=this.finishNode(i,\"TypeAnnotation\"),this.resetEndLocation(e),this.semicolon(),this.scope.declareName(t.id.name,2048,t.id.start),this.finishNode(t,\"DeclareFunction\")}flowParseDeclare(t,e){if(this.match(l._class))return this.flowParseDeclareClass(t);if(this.match(l._function))return this.flowParseDeclareFunction(t);if(this.match(l._var))return this.flowParseDeclareVariable(t);if(this.eatContextual(\"module\"))return this.match(l.dot)?this.flowParseDeclareModuleExports(t):(e&&this.raise(this.state.lastTokStart,$.NestedDeclareModule),this.flowParseDeclareModule(t));if(this.isContextual(\"type\"))return this.flowParseDeclareTypeAlias(t);if(this.isContextual(\"opaque\"))return this.flowParseDeclareOpaqueType(t);if(this.isContextual(\"interface\"))return this.flowParseDeclareInterface(t);if(this.match(l._export))return this.flowParseDeclareExportDeclaration(t,e);throw this.unexpected()}flowParseDeclareVariable(t){return this.next(),t.id=this.flowParseTypeAnnotatableIdentifier(!0),this.scope.declareName(t.id.name,5,t.id.start),this.semicolon(),this.finishNode(t,\"DeclareVariable\")}flowParseDeclareModule(t){this.scope.enter(0),this.match(l.string)?t.id=this.parseExprAtom():t.id=this.parseIdentifier();const e=t.body=this.startNode(),s=e.body=[];for(this.expect(l.braceL);!this.match(l.braceR);){let t=this.startNode();this.match(l._import)?(this.next(),this.isContextual(\"type\")||this.match(l._typeof)||this.raise(this.state.lastTokStart,$.InvalidNonTypeImportInDeclareModule),this.parseImport(t)):(this.expectContextual(\"declare\",$.UnsupportedStatementInDeclareModule),t=this.flowParseDeclare(t,!0)),s.push(t)}this.scope.exit(),this.expect(l.braceR),this.finishNode(e,\"BlockStatement\");let i=null,r=!1;return s.forEach((t=>{!function(t){return\"DeclareExportAllDeclaration\"===t.type||\"DeclareExportDeclaration\"===t.type&&(!t.declaration||\"TypeAlias\"!==t.declaration.type&&\"InterfaceDeclaration\"!==t.declaration.type)}(t)?\"DeclareModuleExports\"===t.type&&(r&&this.raise(t.start,$.DuplicateDeclareModuleExports),\"ES\"===i&&this.raise(t.start,$.AmbiguousDeclareModuleKind),i=\"CommonJS\",r=!0):(\"CommonJS\"===i&&this.raise(t.start,$.AmbiguousDeclareModuleKind),i=\"ES\")})),t.kind=i||\"CommonJS\",this.finishNode(t,\"DeclareModule\")}flowParseDeclareExportDeclaration(t,e){if(this.expect(l._export),this.eat(l._default))return this.match(l._function)||this.match(l._class)?t.declaration=this.flowParseDeclare(this.startNode()):(t.declaration=this.flowParseType(),this.semicolon()),t.default=!0,this.finishNode(t,\"DeclareExportDeclaration\");if(this.match(l._const)||this.isLet()||(this.isContextual(\"type\")||this.isContextual(\"interface\"))&&!e){const t=this.state.value,e=et[t];throw this.raise(this.state.start,$.UnsupportedDeclareExportKind,t,e)}if(this.match(l._var)||this.match(l._function)||this.match(l._class)||this.isContextual(\"opaque\"))return t.declaration=this.flowParseDeclare(this.startNode()),t.default=!1,this.finishNode(t,\"DeclareExportDeclaration\");if(this.match(l.star)||this.match(l.braceL)||this.isContextual(\"interface\")||this.isContextual(\"type\")||this.isContextual(\"opaque\"))return\"ExportNamedDeclaration\"===(t=this.parseExport(t)).type&&(t.type=\"ExportDeclaration\",t.default=!1,delete t.exportKind),t.type=\"Declare\"+t.type,t;throw this.unexpected()}flowParseDeclareModuleExports(t){return this.next(),this.expectContextual(\"exports\"),t.typeAnnotation=this.flowParseTypeAnnotation(),this.semicolon(),this.finishNode(t,\"DeclareModuleExports\")}flowParseDeclareTypeAlias(t){return this.next(),this.flowParseTypeAlias(t),t.type=\"DeclareTypeAlias\",t}flowParseDeclareOpaqueType(t){return this.next(),this.flowParseOpaqueType(t,!0),t.type=\"DeclareOpaqueType\",t}flowParseDeclareInterface(t){return this.next(),this.flowParseInterfaceish(t),this.finishNode(t,\"DeclareInterface\")}flowParseInterfaceish(t,e=!1){if(t.id=this.flowParseRestrictedIdentifier(!e,!0),this.scope.declareName(t.id.name,e?17:9,t.id.start),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterDeclaration():t.typeParameters=null,t.extends=[],t.implements=[],t.mixins=[],this.eat(l._extends))do{t.extends.push(this.flowParseInterfaceExtends())}while(!e&&this.eat(l.comma));if(this.isContextual(\"mixins\")){this.next();do{t.mixins.push(this.flowParseInterfaceExtends())}while(this.eat(l.comma))}if(this.isContextual(\"implements\")){this.next();do{t.implements.push(this.flowParseInterfaceExtends())}while(this.eat(l.comma))}t.body=this.flowParseObjectType({allowStatic:e,allowExact:!1,allowSpread:!1,allowProto:e,allowInexact:!1})}flowParseInterfaceExtends(){const t=this.startNode();return t.id=this.flowParseQualifiedTypeIdentifier(),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterInstantiation():t.typeParameters=null,this.finishNode(t,\"InterfaceExtends\")}flowParseInterface(t){return this.flowParseInterfaceish(t),this.finishNode(t,\"InterfaceDeclaration\")}checkNotUnderscore(t){\"_\"===t&&this.raise(this.state.start,$.UnexpectedReservedUnderscore)}checkReservedType(t,e,s){Y.has(t)&&this.raise(e,s?$.AssignReservedType:$.UnexpectedReservedType,t)}flowParseRestrictedIdentifier(t,e){return this.checkReservedType(this.state.value,this.state.start,e),this.parseIdentifier(t)}flowParseTypeAlias(t){return t.id=this.flowParseRestrictedIdentifier(!1,!0),this.scope.declareName(t.id.name,9,t.id.start),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterDeclaration():t.typeParameters=null,t.right=this.flowParseTypeInitialiser(l.eq),this.semicolon(),this.finishNode(t,\"TypeAlias\")}flowParseOpaqueType(t,e){return this.expectContextual(\"type\"),t.id=this.flowParseRestrictedIdentifier(!0,!0),this.scope.declareName(t.id.name,9,t.id.start),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterDeclaration():t.typeParameters=null,t.supertype=null,this.match(l.colon)&&(t.supertype=this.flowParseTypeInitialiser(l.colon)),t.impltype=null,e||(t.impltype=this.flowParseTypeInitialiser(l.eq)),this.semicolon(),this.finishNode(t,\"OpaqueType\")}flowParseTypeParameter(t=!1){const e=this.state.start,s=this.startNode(),i=this.flowParseVariance(),r=this.flowParseTypeAnnotatableIdentifier();return s.name=r.name,s.variance=i,s.bound=r.typeAnnotation,this.match(l.eq)?(this.eat(l.eq),s.default=this.flowParseType()):t&&this.raise(e,$.MissingTypeParamDefault),this.finishNode(s,\"TypeParameter\")}flowParseTypeParameterDeclaration(){const t=this.state.inType,e=this.startNode();e.params=[],this.state.inType=!0,this.isRelational(\"<\")||this.match(l.jsxTagStart)?this.next():this.unexpected();let s=!1;do{const t=this.flowParseTypeParameter(s);e.params.push(t),t.default&&(s=!0),this.isRelational(\">\")||this.expect(l.comma)}while(!this.isRelational(\">\"));return this.expectRelational(\">\"),this.state.inType=t,this.finishNode(e,\"TypeParameterDeclaration\")}flowParseTypeParameterInstantiation(){const t=this.startNode(),e=this.state.inType;t.params=[],this.state.inType=!0,this.expectRelational(\"<\");const s=this.state.noAnonFunctionType;for(this.state.noAnonFunctionType=!1;!this.isRelational(\">\");)t.params.push(this.flowParseType()),this.isRelational(\">\")||this.expect(l.comma);return this.state.noAnonFunctionType=s,this.expectRelational(\">\"),this.state.inType=e,this.finishNode(t,\"TypeParameterInstantiation\")}flowParseTypeParameterInstantiationCallOrNew(){const t=this.startNode(),e=this.state.inType;for(t.params=[],this.state.inType=!0,this.expectRelational(\"<\");!this.isRelational(\">\");)t.params.push(this.flowParseTypeOrImplicitInstantiation()),this.isRelational(\">\")||this.expect(l.comma);return this.expectRelational(\">\"),this.state.inType=e,this.finishNode(t,\"TypeParameterInstantiation\")}flowParseInterfaceType(){const t=this.startNode();if(this.expectContextual(\"interface\"),t.extends=[],this.eat(l._extends))do{t.extends.push(this.flowParseInterfaceExtends())}while(this.eat(l.comma));return t.body=this.flowParseObjectType({allowStatic:!1,allowExact:!1,allowSpread:!1,allowProto:!1,allowInexact:!1}),this.finishNode(t,\"InterfaceTypeAnnotation\")}flowParseObjectPropertyKey(){return this.match(l.num)||this.match(l.string)?this.parseExprAtom():this.parseIdentifier(!0)}flowParseObjectTypeIndexer(t,e,s){return t.static=e,this.lookahead().type===l.colon?(t.id=this.flowParseObjectPropertyKey(),t.key=this.flowParseTypeInitialiser()):(t.id=null,t.key=this.flowParseType()),this.expect(l.bracketR),t.value=this.flowParseTypeInitialiser(),t.variance=s,this.finishNode(t,\"ObjectTypeIndexer\")}flowParseObjectTypeInternalSlot(t,e){return t.static=e,t.id=this.flowParseObjectPropertyKey(),this.expect(l.bracketR),this.expect(l.bracketR),this.isRelational(\"<\")||this.match(l.parenL)?(t.method=!0,t.optional=!1,t.value=this.flowParseObjectTypeMethodish(this.startNodeAt(t.start,t.loc.start))):(t.method=!1,this.eat(l.question)&&(t.optional=!0),t.value=this.flowParseTypeInitialiser()),this.finishNode(t,\"ObjectTypeInternalSlot\")}flowParseObjectTypeMethodish(t){for(t.params=[],t.rest=null,t.typeParameters=null,this.isRelational(\"<\")&&(t.typeParameters=this.flowParseTypeParameterDeclaration()),this.expect(l.parenL);!this.match(l.parenR)&&!this.match(l.ellipsis);)t.params.push(this.flowParseFunctionTypeParam()),this.match(l.parenR)||this.expect(l.comma);return this.eat(l.ellipsis)&&(t.rest=this.flowParseFunctionTypeParam()),this.expect(l.parenR),t.returnType=this.flowParseTypeInitialiser(),this.finishNode(t,\"FunctionTypeAnnotation\")}flowParseObjectTypeCallProperty(t,e){const s=this.startNode();return t.static=e,t.value=this.flowParseObjectTypeMethodish(s),this.finishNode(t,\"ObjectTypeCallProperty\")}flowParseObjectType({allowStatic:t,allowExact:e,allowSpread:s,allowProto:i,allowInexact:r}){const a=this.state.inType;this.state.inType=!0;const n=this.startNode();let o,h;n.callProperties=[],n.properties=[],n.indexers=[],n.internalSlots=[];let p=!1;for(e&&this.match(l.braceBarL)?(this.expect(l.braceBarL),o=l.braceBarR,h=!0):(this.expect(l.braceL),o=l.braceR,h=!1),n.exact=h;!this.match(o);){let e=!1,a=null,o=null;const c=this.startNode();if(i&&this.isContextual(\"proto\")){const e=this.lookahead();e.type!==l.colon&&e.type!==l.question&&(this.next(),a=this.state.start,t=!1)}if(t&&this.isContextual(\"static\")){const t=this.lookahead();t.type!==l.colon&&t.type!==l.question&&(this.next(),e=!0)}const u=this.flowParseVariance();if(this.eat(l.bracketL))null!=a&&this.unexpected(a),this.eat(l.bracketL)?(u&&this.unexpected(u.start),n.internalSlots.push(this.flowParseObjectTypeInternalSlot(c,e))):n.indexers.push(this.flowParseObjectTypeIndexer(c,e,u));else if(this.match(l.parenL)||this.isRelational(\"<\"))null!=a&&this.unexpected(a),u&&this.unexpected(u.start),n.callProperties.push(this.flowParseObjectTypeCallProperty(c,e));else{let t=\"init\";if(this.isContextual(\"get\")||this.isContextual(\"set\")){const e=this.lookahead();e.type!==l.name&&e.type!==l.string&&e.type!==l.num||(t=this.state.value,this.next())}const i=this.flowParseObjectTypeProperty(c,e,a,u,t,s,null!=r?r:!h);null===i?(p=!0,o=this.state.lastTokStart):n.properties.push(i)}this.flowObjectTypeSemicolon(),!o||this.match(l.braceR)||this.match(l.braceBarR)||this.raise(o,$.UnexpectedExplicitInexactInObject)}this.expect(o),s&&(n.inexact=p);const c=this.finishNode(n,\"ObjectTypeAnnotation\");return this.state.inType=a,c}flowParseObjectTypeProperty(t,e,s,i,r,a,n){if(this.eat(l.ellipsis)){return this.match(l.comma)||this.match(l.semi)||this.match(l.braceR)||this.match(l.braceBarR)?(a?n||this.raise(this.state.lastTokStart,$.InexactInsideExact):this.raise(this.state.lastTokStart,$.InexactInsideNonObject),i&&this.raise(i.start,$.InexactVariance),null):(a||this.raise(this.state.lastTokStart,$.UnexpectedSpreadType),null!=s&&this.unexpected(s),i&&this.raise(i.start,$.SpreadVariance),t.argument=this.flowParseType(),this.finishNode(t,\"ObjectTypeSpreadProperty\"))}{t.key=this.flowParseObjectPropertyKey(),t.static=e,t.proto=null!=s,t.kind=r;let a=!1;return this.isRelational(\"<\")||this.match(l.parenL)?(t.method=!0,null!=s&&this.unexpected(s),i&&this.unexpected(i.start),t.value=this.flowParseObjectTypeMethodish(this.startNodeAt(t.start,t.loc.start)),\"get\"!==r&&\"set\"!==r||this.flowCheckGetterSetterParams(t)):(\"init\"!==r&&this.unexpected(),t.method=!1,this.eat(l.question)&&(a=!0),t.value=this.flowParseTypeInitialiser(),t.variance=i),t.optional=a,this.finishNode(t,\"ObjectTypeProperty\")}}flowCheckGetterSetterParams(t){const e=\"get\"===t.kind?0:1,s=t.start;t.value.params.length+(t.value.rest?1:0)!==e&&(\"get\"===t.kind?this.raise(s,b.BadGetterArity):this.raise(s,b.BadSetterArity)),\"set\"===t.kind&&t.value.rest&&this.raise(s,b.BadSetterRestParameter)}flowObjectTypeSemicolon(){this.eat(l.semi)||this.eat(l.comma)||this.match(l.braceR)||this.match(l.braceBarR)||this.unexpected()}flowParseQualifiedTypeIdentifier(t,e,s){t=t||this.state.start,e=e||this.state.startLoc;let i=s||this.flowParseRestrictedIdentifier(!0);for(;this.eat(l.dot);){const s=this.startNodeAt(t,e);s.qualification=i,s.id=this.flowParseRestrictedIdentifier(!0),i=this.finishNode(s,\"QualifiedTypeIdentifier\")}return i}flowParseGenericType(t,e,s){const i=this.startNodeAt(t,e);return i.typeParameters=null,i.id=this.flowParseQualifiedTypeIdentifier(t,e,s),this.isRelational(\"<\")&&(i.typeParameters=this.flowParseTypeParameterInstantiation()),this.finishNode(i,\"GenericTypeAnnotation\")}flowParseTypeofType(){const t=this.startNode();return this.expect(l._typeof),t.argument=this.flowParsePrimaryType(),this.finishNode(t,\"TypeofTypeAnnotation\")}flowParseTupleType(){const t=this.startNode();for(t.types=[],this.expect(l.bracketL);this.state.pos<this.length&&!this.match(l.bracketR)&&(t.types.push(this.flowParseType()),!this.match(l.bracketR));)this.expect(l.comma);return this.expect(l.bracketR),this.finishNode(t,\"TupleTypeAnnotation\")}flowParseFunctionTypeParam(){let t=null,e=!1,s=null;const i=this.startNode(),r=this.lookahead();return r.type===l.colon||r.type===l.question?(t=this.parseIdentifier(),this.eat(l.question)&&(e=!0),s=this.flowParseTypeInitialiser()):s=this.flowParseType(),i.name=t,i.optional=e,i.typeAnnotation=s,this.finishNode(i,\"FunctionTypeParam\")}reinterpretTypeAsFunctionTypeParam(t){const e=this.startNodeAt(t.start,t.loc.start);return e.name=null,e.optional=!1,e.typeAnnotation=t,this.finishNode(e,\"FunctionTypeParam\")}flowParseFunctionTypeParams(t=[]){let e=null;for(;!this.match(l.parenR)&&!this.match(l.ellipsis);)t.push(this.flowParseFunctionTypeParam()),this.match(l.parenR)||this.expect(l.comma);return this.eat(l.ellipsis)&&(e=this.flowParseFunctionTypeParam()),{params:t,rest:e}}flowIdentToTypeAnnotation(t,e,s,i){switch(i.name){case\"any\":return this.finishNode(s,\"AnyTypeAnnotation\");case\"bool\":case\"boolean\":return this.finishNode(s,\"BooleanTypeAnnotation\");case\"mixed\":return this.finishNode(s,\"MixedTypeAnnotation\");case\"empty\":return this.finishNode(s,\"EmptyTypeAnnotation\");case\"number\":return this.finishNode(s,\"NumberTypeAnnotation\");case\"string\":return this.finishNode(s,\"StringTypeAnnotation\");case\"symbol\":return this.finishNode(s,\"SymbolTypeAnnotation\");default:return this.checkNotUnderscore(i.name),this.flowParseGenericType(t,e,i)}}flowParsePrimaryType(){const t=this.state.start,e=this.state.startLoc,s=this.startNode();let i,r,a=!1;const n=this.state.noAnonFunctionType;switch(this.state.type){case l.name:return this.isContextual(\"interface\")?this.flowParseInterfaceType():this.flowIdentToTypeAnnotation(t,e,s,this.parseIdentifier());case l.braceL:return this.flowParseObjectType({allowStatic:!1,allowExact:!1,allowSpread:!0,allowProto:!1,allowInexact:!0});case l.braceBarL:return this.flowParseObjectType({allowStatic:!1,allowExact:!0,allowSpread:!0,allowProto:!1,allowInexact:!1});case l.bracketL:return this.state.noAnonFunctionType=!1,r=this.flowParseTupleType(),this.state.noAnonFunctionType=n,r;case l.relational:if(\"<\"===this.state.value)return s.typeParameters=this.flowParseTypeParameterDeclaration(),this.expect(l.parenL),i=this.flowParseFunctionTypeParams(),s.params=i.params,s.rest=i.rest,this.expect(l.parenR),this.expect(l.arrow),s.returnType=this.flowParseType(),this.finishNode(s,\"FunctionTypeAnnotation\");break;case l.parenL:if(this.next(),!this.match(l.parenR)&&!this.match(l.ellipsis))if(this.match(l.name)){const t=this.lookahead().type;a=t!==l.question&&t!==l.colon}else a=!0;if(a){if(this.state.noAnonFunctionType=!1,r=this.flowParseType(),this.state.noAnonFunctionType=n,this.state.noAnonFunctionType||!(this.match(l.comma)||this.match(l.parenR)&&this.lookahead().type===l.arrow))return this.expect(l.parenR),r;this.eat(l.comma)}return i=r?this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r)]):this.flowParseFunctionTypeParams(),s.params=i.params,s.rest=i.rest,this.expect(l.parenR),this.expect(l.arrow),s.returnType=this.flowParseType(),s.typeParameters=null,this.finishNode(s,\"FunctionTypeAnnotation\");case l.string:return this.parseLiteral(this.state.value,\"StringLiteralTypeAnnotation\");case l._true:case l._false:return s.value=this.match(l._true),this.next(),this.finishNode(s,\"BooleanLiteralTypeAnnotation\");case l.plusMin:if(\"-\"===this.state.value){if(this.next(),this.match(l.num))return this.parseLiteral(-this.state.value,\"NumberLiteralTypeAnnotation\",s.start,s.loc.start);if(this.match(l.bigint))return this.parseLiteral(-this.state.value,\"BigIntLiteralTypeAnnotation\",s.start,s.loc.start);throw this.raise(this.state.start,$.UnexpectedSubtractionOperand)}throw this.unexpected();case l.num:return this.parseLiteral(this.state.value,\"NumberLiteralTypeAnnotation\");case l.bigint:return this.parseLiteral(this.state.value,\"BigIntLiteralTypeAnnotation\");case l._void:return this.next(),this.finishNode(s,\"VoidTypeAnnotation\");case l._null:return this.next(),this.finishNode(s,\"NullLiteralTypeAnnotation\");case l._this:return this.next(),this.finishNode(s,\"ThisTypeAnnotation\");case l.star:return this.next(),this.finishNode(s,\"ExistsTypeAnnotation\");default:if(\"typeof\"===this.state.type.keyword)return this.flowParseTypeofType();if(this.state.type.keyword){const t=this.state.type.label;return this.next(),super.createIdentifier(s,t)}}throw this.unexpected()}flowParsePostfixType(){const t=this.state.start,e=this.state.startLoc;let s=this.flowParsePrimaryType();for(;this.match(l.bracketL)&&!this.canInsertSemicolon();){const i=this.startNodeAt(t,e);i.elementType=s,this.expect(l.bracketL),this.expect(l.bracketR),s=this.finishNode(i,\"ArrayTypeAnnotation\")}return s}flowParsePrefixType(){const t=this.startNode();return this.eat(l.question)?(t.typeAnnotation=this.flowParsePrefixType(),this.finishNode(t,\"NullableTypeAnnotation\")):this.flowParsePostfixType()}flowParseAnonFunctionWithoutParens(){const t=this.flowParsePrefixType();if(!this.state.noAnonFunctionType&&this.eat(l.arrow)){const e=this.startNodeAt(t.start,t.loc.start);return e.params=[this.reinterpretTypeAsFunctionTypeParam(t)],e.rest=null,e.returnType=this.flowParseType(),e.typeParameters=null,this.finishNode(e,\"FunctionTypeAnnotation\")}return t}flowParseIntersectionType(){const t=this.startNode();this.eat(l.bitwiseAND);const e=this.flowParseAnonFunctionWithoutParens();for(t.types=[e];this.eat(l.bitwiseAND);)t.types.push(this.flowParseAnonFunctionWithoutParens());return 1===t.types.length?e:this.finishNode(t,\"IntersectionTypeAnnotation\")}flowParseUnionType(){const t=this.startNode();this.eat(l.bitwiseOR);const e=this.flowParseIntersectionType();for(t.types=[e];this.eat(l.bitwiseOR);)t.types.push(this.flowParseIntersectionType());return 1===t.types.length?e:this.finishNode(t,\"UnionTypeAnnotation\")}flowParseType(){const t=this.state.inType;this.state.inType=!0;const e=this.flowParseUnionType();return this.state.inType=t,this.state.exprAllowed=this.state.exprAllowed||this.state.noAnonFunctionType,e}flowParseTypeOrImplicitInstantiation(){if(this.state.type===l.name&&\"_\"===this.state.value){const t=this.state.start,e=this.state.startLoc,s=this.parseIdentifier();return this.flowParseGenericType(t,e,s)}return this.flowParseType()}flowParseTypeAnnotation(){const t=this.startNode();return t.typeAnnotation=this.flowParseTypeInitialiser(),this.finishNode(t,\"TypeAnnotation\")}flowParseTypeAnnotatableIdentifier(t){const e=t?this.parseIdentifier():this.flowParseRestrictedIdentifier();return this.match(l.colon)&&(e.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(e)),e}typeCastToParameter(t){return t.expression.typeAnnotation=t.typeAnnotation,this.resetEndLocation(t.expression,t.typeAnnotation.end,t.typeAnnotation.loc.end),t.expression}flowParseVariance(){let t=null;return this.match(l.plusMin)&&(t=this.startNode(),\"+\"===this.state.value?t.kind=\"plus\":t.kind=\"minus\",this.next(),this.finishNode(t,\"Variance\")),t}parseFunctionBody(t,e,s=!1){return e?this.forwardNoArrowParamsConversionAt(t,(()=>super.parseFunctionBody(t,!0,s))):super.parseFunctionBody(t,!1,s)}parseFunctionBodyAndFinish(t,e,s=!1){if(this.match(l.colon)){const e=this.startNode();[e.typeAnnotation,t.predicate]=this.flowParseTypeAndPredicateInitialiser(),t.returnType=e.typeAnnotation?this.finishNode(e,\"TypeAnnotation\"):null}super.parseFunctionBodyAndFinish(t,e,s)}parseStatement(t,e){if(this.state.strict&&this.match(l.name)&&\"interface\"===this.state.value){const t=this.lookahead();if(t.type===l.name||q(t.value)){const t=this.startNode();return this.next(),this.flowParseInterface(t)}}else if(this.shouldParseEnums()&&this.isContextual(\"enum\")){const t=this.startNode();return this.next(),this.flowParseEnumDeclaration(t)}const s=super.parseStatement(t,e);return void 0!==this.flowPragma||this.isValidDirective(s)||(this.flowPragma=null),s}parseExpressionStatement(t,e){if(\"Identifier\"===e.type)if(\"declare\"===e.name){if(this.match(l._class)||this.match(l.name)||this.match(l._function)||this.match(l._var)||this.match(l._export))return this.flowParseDeclare(t)}else if(this.match(l.name)){if(\"interface\"===e.name)return this.flowParseInterface(t);if(\"type\"===e.name)return this.flowParseTypeAlias(t);if(\"opaque\"===e.name)return this.flowParseOpaqueType(t,!1)}return super.parseExpressionStatement(t,e)}shouldParseExportDeclaration(){return this.isContextual(\"type\")||this.isContextual(\"interface\")||this.isContextual(\"opaque\")||this.shouldParseEnums()&&this.isContextual(\"enum\")||super.shouldParseExportDeclaration()}isExportDefaultSpecifier(){return(!this.match(l.name)||!(\"type\"===this.state.value||\"interface\"===this.state.value||\"opaque\"===this.state.value||this.shouldParseEnums()&&\"enum\"===this.state.value))&&super.isExportDefaultSpecifier()}parseExportDefaultExpression(){if(this.shouldParseEnums()&&this.isContextual(\"enum\")){const t=this.startNode();return this.next(),this.flowParseEnumDeclaration(t)}return super.parseExportDefaultExpression()}parseConditional(t,e,s,i){if(!this.match(l.question))return t;if(i){const r=this.tryParse((()=>super.parseConditional(t,e,s)));return r.node?(r.error&&(this.state=r.failState),r.node):(i.start=r.error.pos||this.state.start,t)}this.expect(l.question);const r=this.state.clone(),a=this.state.noArrowAt,n=this.startNodeAt(e,s);let{consequent:o,failed:h}=this.tryParseConditionalConsequent(),[p,c]=this.getArrowLikeExpressions(o);if(h||c.length>0){const t=[...a];if(c.length>0){this.state=r,this.state.noArrowAt=t;for(let e=0;e<c.length;e++)t.push(c[e].start);({consequent:o,failed:h}=this.tryParseConditionalConsequent()),[p,c]=this.getArrowLikeExpressions(o)}h&&p.length>1&&this.raise(r.start,$.AmbiguousConditionalArrow),h&&1===p.length&&(this.state=r,this.state.noArrowAt=t.concat(p[0].start),({consequent:o,failed:h}=this.tryParseConditionalConsequent()))}return this.getArrowLikeExpressions(o,!0),this.state.noArrowAt=a,this.expect(l.colon),n.test=t,n.consequent=o,n.alternate=this.forwardNoArrowParamsConversionAt(n,(()=>this.parseMaybeAssign(void 0,void 0,void 0))),this.finishNode(n,\"ConditionalExpression\")}tryParseConditionalConsequent(){this.state.noArrowParamsConversionAt.push(this.state.start);const t=this.parseMaybeAssignAllowIn(),e=!this.match(l.colon);return this.state.noArrowParamsConversionAt.pop(),{consequent:t,failed:e}}getArrowLikeExpressions(t,e){const s=[t],i=[];for(;0!==s.length;){const t=s.pop();\"ArrowFunctionExpression\"===t.type?(t.typeParameters||!t.returnType?this.finishArrowValidation(t):i.push(t),s.push(t.body)):\"ConditionalExpression\"===t.type&&(s.push(t.consequent),s.push(t.alternate))}return e?(i.forEach((t=>this.finishArrowValidation(t))),[i,[]]):function(t,e){const s=[],i=[];for(let r=0;r<t.length;r++)(e(t[r],r,t)?s:i).push(t[r]);return[s,i]}(i,(t=>t.params.every((t=>this.isAssignable(t,!0)))))}finishArrowValidation(t){var e;this.toAssignableList(t.params,null==(e=t.extra)?void 0:e.trailingComma,!1),this.scope.enter(6),super.checkParams(t,!1,!0),this.scope.exit()}forwardNoArrowParamsConversionAt(t,e){let s;return-1!==this.state.noArrowParamsConversionAt.indexOf(t.start)?(this.state.noArrowParamsConversionAt.push(this.state.start),s=e(),this.state.noArrowParamsConversionAt.pop()):s=e(),s}parseParenItem(t,e,s){if(t=super.parseParenItem(t,e,s),this.eat(l.question)&&(t.optional=!0,this.resetEndLocation(t)),this.match(l.colon)){const i=this.startNodeAt(e,s);return i.expression=t,i.typeAnnotation=this.flowParseTypeAnnotation(),this.finishNode(i,\"TypeCastExpression\")}return t}assertModuleNodeAllowed(t){\"ImportDeclaration\"===t.type&&(\"type\"===t.importKind||\"typeof\"===t.importKind)||\"ExportNamedDeclaration\"===t.type&&\"type\"===t.exportKind||\"ExportAllDeclaration\"===t.type&&\"type\"===t.exportKind||super.assertModuleNodeAllowed(t)}parseExport(t){const e=super.parseExport(t);return\"ExportNamedDeclaration\"!==e.type&&\"ExportAllDeclaration\"!==e.type||(e.exportKind=e.exportKind||\"value\"),e}parseExportDeclaration(t){if(this.isContextual(\"type\")){t.exportKind=\"type\";const e=this.startNode();return this.next(),this.match(l.braceL)?(t.specifiers=this.parseExportSpecifiers(),this.parseExportFrom(t),null):this.flowParseTypeAlias(e)}if(this.isContextual(\"opaque\")){t.exportKind=\"type\";const e=this.startNode();return this.next(),this.flowParseOpaqueType(e,!1)}if(this.isContextual(\"interface\")){t.exportKind=\"type\";const e=this.startNode();return this.next(),this.flowParseInterface(e)}if(this.shouldParseEnums()&&this.isContextual(\"enum\")){t.exportKind=\"value\";const e=this.startNode();return this.next(),this.flowParseEnumDeclaration(e)}return super.parseExportDeclaration(t)}eatExportStar(t){return!!super.eatExportStar(...arguments)||!(!this.isContextual(\"type\")||this.lookahead().type!==l.star)&&(t.exportKind=\"type\",this.next(),this.next(),!0)}maybeParseExportNamespaceSpecifier(t){const e=this.state.start,s=super.maybeParseExportNamespaceSpecifier(t);return s&&\"type\"===t.exportKind&&this.unexpected(e),s}parseClassId(t,e,s){super.parseClassId(t,e,s),this.isRelational(\"<\")&&(t.typeParameters=this.flowParseTypeParameterDeclaration())}parseClassMember(t,e,s){const i=this.state.start;if(this.isContextual(\"declare\")){if(this.parseClassMemberFromModifier(t,e))return;e.declare=!0}super.parseClassMember(t,e,s),e.declare&&(\"ClassProperty\"!==e.type&&\"ClassPrivateProperty\"!==e.type?this.raise(i,$.DeclareClassElement):e.value&&this.raise(e.value.start,$.DeclareClassFieldInitializer))}getTokenFromCode(t){const e=this.input.charCodeAt(this.state.pos+1);return 123===t&&124===e?this.finishOp(l.braceBarL,2):!this.state.inType||62!==t&&60!==t?this.state.inType&&63===t?this.finishOp(l.question,1):function(t,e){return 64===t&&64===e}(t,e)?(this.state.isIterator=!0,super.readWord()):super.getTokenFromCode(t):this.finishOp(l.relational,1)}isAssignable(t,e){switch(t.type){case\"Identifier\":case\"ObjectPattern\":case\"ArrayPattern\":case\"AssignmentPattern\":return!0;case\"ObjectExpression\":{const e=t.properties.length-1;return t.properties.every(((t,s)=>\"ObjectMethod\"!==t.type&&(s===e||\"SpreadElement\"===t.type)&&this.isAssignable(t)))}case\"ObjectProperty\":return this.isAssignable(t.value);case\"SpreadElement\":return this.isAssignable(t.argument);case\"ArrayExpression\":return t.elements.every((t=>this.isAssignable(t)));case\"AssignmentExpression\":return\"=\"===t.operator;case\"ParenthesizedExpression\":case\"TypeCastExpression\":return this.isAssignable(t.expression);case\"MemberExpression\":case\"OptionalMemberExpression\":return!e;default:return!1}}toAssignable(t,e=!1){return\"TypeCastExpression\"===t.type?super.toAssignable(this.typeCastToParameter(t),e):super.toAssignable(t,e)}toAssignableList(t,e,s){for(let i=0;i<t.length;i++){const e=t[i];\"TypeCastExpression\"===(null==e?void 0:e.type)&&(t[i]=this.typeCastToParameter(e))}return super.toAssignableList(t,e,s)}toReferencedList(t,e){for(let i=0;i<t.length;i++){var s;const r=t[i];r&&\"TypeCastExpression\"===r.type&&!(null==(s=r.extra)?void 0:s.parenthesized)&&(t.length>1||!e)&&this.raise(r.typeAnnotation.start,$.TypeCastInPattern)}return t}parseArrayLike(t,e,s,i){const r=super.parseArrayLike(t,e,s,i);return e&&!this.state.maybeInArrowParameters&&this.toReferencedList(r.elements),r}checkLVal(t,...e){if(\"TypeCastExpression\"!==t.type)return super.checkLVal(t,...e)}parseClassProperty(t){return this.match(l.colon)&&(t.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassProperty(t)}parseClassPrivateProperty(t){return this.match(l.colon)&&(t.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassPrivateProperty(t)}isClassMethod(){return this.isRelational(\"<\")||super.isClassMethod()}isClassProperty(){return this.match(l.colon)||super.isClassProperty()}isNonstaticConstructor(t){return!this.match(l.colon)&&super.isNonstaticConstructor(t)}pushClassMethod(t,e,s,i,r,a){e.variance&&this.unexpected(e.variance.start),delete e.variance,this.isRelational(\"<\")&&(e.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassMethod(t,e,s,i,r,a)}pushClassPrivateMethod(t,e,s,i){e.variance&&this.unexpected(e.variance.start),delete e.variance,this.isRelational(\"<\")&&(e.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassPrivateMethod(t,e,s,i)}parseClassSuper(t){if(super.parseClassSuper(t),t.superClass&&this.isRelational(\"<\")&&(t.superTypeParameters=this.flowParseTypeParameterInstantiation()),this.isContextual(\"implements\")){this.next();const e=t.implements=[];do{const t=this.startNode();t.id=this.flowParseRestrictedIdentifier(!0),this.isRelational(\"<\")?t.typeParameters=this.flowParseTypeParameterInstantiation():t.typeParameters=null,e.push(this.finishNode(t,\"ClassImplements\"))}while(this.eat(l.comma))}}parsePropertyName(t,e){const s=this.flowParseVariance(),i=super.parsePropertyName(t,e);return t.variance=s,i}parseObjPropValue(t,e,s,i,r,a,n,o){let h;t.variance&&this.unexpected(t.variance.start),delete t.variance,this.isRelational(\"<\")&&!n&&(h=this.flowParseTypeParameterDeclaration(),this.match(l.parenL)||this.unexpected()),super.parseObjPropValue(t,e,s,i,r,a,n,o),h&&((t.value||t).typeParameters=h)}parseAssignableListItemTypes(t){return this.eat(l.question)&&(\"Identifier\"!==t.type&&this.raise(t.start,$.OptionalBindingPattern),t.optional=!0),this.match(l.colon)&&(t.typeAnnotation=this.flowParseTypeAnnotation()),this.resetEndLocation(t),t}parseMaybeDefault(t,e,s){const i=super.parseMaybeDefault(t,e,s);return\"AssignmentPattern\"===i.type&&i.typeAnnotation&&i.right.start<i.typeAnnotation.start&&this.raise(i.typeAnnotation.start,$.TypeBeforeInitializer),i}shouldParseDefaultImport(t){return Z(t)?tt(this.state):super.shouldParseDefaultImport(t)}parseImportSpecifierLocal(t,e,s,i){e.local=Z(t)?this.flowParseRestrictedIdentifier(!0,!0):this.parseIdentifier(),this.checkLVal(e.local,i,9),t.specifiers.push(this.finishNode(e,s))}maybeParseDefaultImportSpecifier(t){t.importKind=\"value\";let e=null;if(this.match(l._typeof)?e=\"typeof\":this.isContextual(\"type\")&&(e=\"type\"),e){const s=this.lookahead();\"type\"===e&&s.type===l.star&&this.unexpected(s.start),(tt(s)||s.type===l.braceL||s.type===l.star)&&(this.next(),t.importKind=e)}return super.maybeParseDefaultImportSpecifier(t)}parseImportSpecifier(t){const e=this.startNode(),s=this.state.start,i=this.parseModuleExportName();let r=null;\"Identifier\"===i.type&&(\"type\"===i.name?r=\"type\":\"typeof\"===i.name&&(r=\"typeof\"));let a=!1;if(this.isContextual(\"as\")&&!this.isLookaheadContextual(\"as\")){const t=this.parseIdentifier(!0);null===r||this.match(l.name)||this.state.type.keyword?(e.imported=i,e.importKind=null,e.local=this.parseIdentifier()):(e.imported=t,e.importKind=r,e.local=t.__clone())}else if(null!==r&&(this.match(l.name)||this.state.type.keyword))e.imported=this.parseIdentifier(!0),e.importKind=r,this.eatContextual(\"as\")?e.local=this.parseIdentifier():(a=!0,e.local=e.imported.__clone());else{if(\"StringLiteral\"===i.type)throw this.raise(e.start,b.ImportBindingIsString,i.value);a=!0,e.imported=i,e.importKind=null,e.local=e.imported.__clone()}const n=Z(t),o=Z(e);n&&o&&this.raise(s,$.ImportTypeShorthandOnlyInPureImport),(n||o)&&this.checkReservedType(e.local.name,e.local.start,!0),!a||n||o||this.checkReservedWord(e.local.name,e.start,!0,!0),this.checkLVal(e.local,\"import specifier\",9),t.specifiers.push(this.finishNode(e,\"ImportSpecifier\"))}parseFunctionParams(t,e){const s=t.kind;\"get\"!==s&&\"set\"!==s&&this.isRelational(\"<\")&&(t.typeParameters=this.flowParseTypeParameterDeclaration()),super.parseFunctionParams(t,e)}parseVarId(t,e){super.parseVarId(t,e),this.match(l.colon)&&(t.id.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(t.id))}parseAsyncArrowFromCallExpression(t,e){if(this.match(l.colon)){const e=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0,t.returnType=this.flowParseTypeAnnotation(),this.state.noAnonFunctionType=e}return super.parseAsyncArrowFromCallExpression(t,e)}shouldParseAsyncArrow(){return this.match(l.colon)||super.shouldParseAsyncArrow()}parseMaybeAssign(t,e,s){var i;let r,a=null;if(this.hasPlugin(\"jsx\")&&(this.match(l.jsxTagStart)||this.isRelational(\"<\"))){if(a=this.state.clone(),r=this.tryParse((()=>super.parseMaybeAssign(t,e,s)),a),!r.error)return r.node;const{context:i}=this.state;i[i.length-1]===A.j_oTag?i.length-=2:i[i.length-1]===A.j_expr&&(i.length-=1)}if((null==(i=r)?void 0:i.error)||this.isRelational(\"<\")){var n,o;let i;a=a||this.state.clone();const h=this.tryParse((r=>{var a;i=this.flowParseTypeParameterDeclaration();const n=this.forwardNoArrowParamsConversionAt(i,(()=>{const r=super.parseMaybeAssign(t,e,s);return this.resetStartLocationFromNode(r,i),r}));\"ArrowFunctionExpression\"!==n.type&&(null==(a=n.extra)?void 0:a.parenthesized)&&r();const o=this.maybeUnwrapTypeCastExpression(n);return o.typeParameters=i,this.resetStartLocationFromNode(o,i),n}),a);let p=null;if(h.node&&\"ArrowFunctionExpression\"===this.maybeUnwrapTypeCastExpression(h.node).type){if(!h.error&&!h.aborted)return h.node.async&&this.raise(i.start,$.UnexpectedTypeParameterBeforeAsyncArrowFunction),h.node;p=h.node}if(null==(n=r)?void 0:n.node)return this.state=r.failState,r.node;if(p)return this.state=h.failState,p;if(null==(o=r)?void 0:o.thrown)throw r.error;if(h.thrown)throw h.error;throw this.raise(i.start,$.UnexpectedTokenAfterTypeParameter)}return super.parseMaybeAssign(t,e,s)}parseArrow(t){if(this.match(l.colon)){const e=this.tryParse((()=>{const e=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0;const s=this.startNode();return[s.typeAnnotation,t.predicate]=this.flowParseTypeAndPredicateInitialiser(),this.state.noAnonFunctionType=e,this.canInsertSemicolon()&&this.unexpected(),this.match(l.arrow)||this.unexpected(),s}));if(e.thrown)return null;e.error&&(this.state=e.failState),t.returnType=e.node.typeAnnotation?this.finishNode(e.node,\"TypeAnnotation\"):null}return super.parseArrow(t)}shouldParseArrow(){return this.match(l.colon)||super.shouldParseArrow()}setArrowFunctionParameters(t,e){-1!==this.state.noArrowParamsConversionAt.indexOf(t.start)?t.params=e:super.setArrowFunctionParameters(t,e)}checkParams(t,e,s){if(!s||-1===this.state.noArrowParamsConversionAt.indexOf(t.start))return super.checkParams(...arguments)}parseParenAndDistinguishExpression(t){return super.parseParenAndDistinguishExpression(t&&-1===this.state.noArrowAt.indexOf(this.state.start))}parseSubscripts(t,e,s,i){if(\"Identifier\"===t.type&&\"async\"===t.name&&-1!==this.state.noArrowAt.indexOf(e)){this.next();const i=this.startNodeAt(e,s);i.callee=t,i.arguments=this.parseCallExpressionArguments(l.parenR,!1),t=this.finishNode(i,\"CallExpression\")}else if(\"Identifier\"===t.type&&\"async\"===t.name&&this.isRelational(\"<\")){const r=this.state.clone(),a=this.tryParse((t=>this.parseAsyncArrowWithTypeParameters(e,s)||t()),r);if(!a.error&&!a.aborted)return a.node;const n=this.tryParse((()=>super.parseSubscripts(t,e,s,i)),r);if(n.node&&!n.error)return n.node;if(a.node)return this.state=a.failState,a.node;if(n.node)return this.state=n.failState,n.node;throw a.error||n.error}return super.parseSubscripts(t,e,s,i)}parseSubscript(t,e,s,i,r){if(this.match(l.questionDot)&&this.isLookaheadToken_lt()){if(r.optionalChainMember=!0,i)return r.stop=!0,t;this.next();const a=this.startNodeAt(e,s);return a.callee=t,a.typeArguments=this.flowParseTypeParameterInstantiation(),this.expect(l.parenL),a.arguments=this.parseCallExpressionArguments(l.parenR,!1),a.optional=!0,this.finishCallExpression(a,!0)}if(!i&&this.shouldParseTypes()&&this.isRelational(\"<\")){const i=this.startNodeAt(e,s);i.callee=t;const a=this.tryParse((()=>(i.typeArguments=this.flowParseTypeParameterInstantiationCallOrNew(),this.expect(l.parenL),i.arguments=this.parseCallExpressionArguments(l.parenR,!1),r.optionalChainMember&&(i.optional=!1),this.finishCallExpression(i,r.optionalChainMember))));if(a.node)return a.error&&(this.state=a.failState),a.node}return super.parseSubscript(t,e,s,i,r)}parseNewArguments(t){let e=null;this.shouldParseTypes()&&this.isRelational(\"<\")&&(e=this.tryParse((()=>this.flowParseTypeParameterInstantiationCallOrNew())).node),t.typeArguments=e,super.parseNewArguments(t)}parseAsyncArrowWithTypeParameters(t,e){const s=this.startNodeAt(t,e);if(this.parseFunctionParams(s),this.parseArrow(s))return this.parseArrowExpression(s,void 0,!0)}readToken_mult_modulo(t){const e=this.input.charCodeAt(this.state.pos+1);if(42===t&&47===e&&this.state.hasFlowComment)return this.state.hasFlowComment=!1,this.state.pos+=2,void this.nextToken();super.readToken_mult_modulo(t)}readToken_pipe_amp(t){const e=this.input.charCodeAt(this.state.pos+1);124!==t||125!==e?super.readToken_pipe_amp(t):this.finishOp(l.braceBarR,2)}parseTopLevel(t,e){const s=super.parseTopLevel(t,e);return this.state.hasFlowComment&&this.raise(this.state.pos,$.UnterminatedFlowComment),s}skipBlockComment(){if(this.hasPlugin(\"flowComments\")&&this.skipFlowComment())return this.state.hasFlowComment&&this.unexpected(null,$.NestedFlowComment),this.hasFlowCommentCompletion(),this.state.pos+=this.skipFlowComment(),void(this.state.hasFlowComment=!0);if(this.state.hasFlowComment){const t=this.input.indexOf(\"*-/\",this.state.pos+=2);if(-1===t)throw this.raise(this.state.pos-2,b.UnterminatedComment);this.state.pos=t+3}else super.skipBlockComment()}skipFlowComment(){const{pos:t}=this.state;let e=2;for(;[32,9].includes(this.input.charCodeAt(t+e));)e++;const s=this.input.charCodeAt(e+t),i=this.input.charCodeAt(e+t+1);return 58===s&&58===i?e+2:\"flow-include\"===this.input.slice(e+t,e+t+12)?e+12:58===s&&58!==i&&e}hasFlowCommentCompletion(){if(-1===this.input.indexOf(\"*/\",this.state.pos))throw this.raise(this.state.pos,b.UnterminatedComment)}flowEnumErrorBooleanMemberNotInitialized(t,{enumName:e,memberName:s}){this.raise(t,$.EnumBooleanMemberNotInitialized,s,e)}flowEnumErrorInvalidMemberName(t,{enumName:e,memberName:s}){const i=s[0].toUpperCase()+s.slice(1);this.raise(t,$.EnumInvalidMemberName,s,i,e)}flowEnumErrorDuplicateMemberName(t,{enumName:e,memberName:s}){this.raise(t,$.EnumDuplicateMemberName,s,e)}flowEnumErrorInconsistentMemberValues(t,{enumName:e}){this.raise(t,$.EnumInconsistentMemberValues,e)}flowEnumErrorInvalidExplicitType(t,{enumName:e,suppliedType:s}){return this.raise(t,null===s?$.EnumInvalidExplicitTypeUnknownSupplied:$.EnumInvalidExplicitType,e,s)}flowEnumErrorInvalidMemberInitializer(t,{enumName:e,explicitType:s,memberName:i}){let r=null;switch(s){case\"boolean\":case\"number\":case\"string\":r=$.EnumInvalidMemberInitializerPrimaryType;break;case\"symbol\":r=$.EnumInvalidMemberInitializerSymbolType;break;default:r=$.EnumInvalidMemberInitializerUnknownType}return this.raise(t,r,e,i,s)}flowEnumErrorNumberMemberNotInitialized(t,{enumName:e,memberName:s}){this.raise(t,$.EnumNumberMemberNotInitialized,e,s)}flowEnumErrorStringMemberInconsistentlyInitailized(t,{enumName:e}){this.raise(t,$.EnumStringMemberInconsistentlyInitailized,e)}flowEnumMemberInit(){const t=this.state.start,e=()=>this.match(l.comma)||this.match(l.braceR);switch(this.state.type){case l.num:{const s=this.parseLiteral(this.state.value,\"NumericLiteral\");return e()?{type:\"number\",pos:s.start,value:s}:{type:\"invalid\",pos:t}}case l.string:{const s=this.parseLiteral(this.state.value,\"StringLiteral\");return e()?{type:\"string\",pos:s.start,value:s}:{type:\"invalid\",pos:t}}case l._true:case l._false:{const s=this.parseBooleanLiteral();return e()?{type:\"boolean\",pos:s.start,value:s}:{type:\"invalid\",pos:t}}default:return{type:\"invalid\",pos:t}}}flowEnumMemberRaw(){const t=this.state.start;return{id:this.parseIdentifier(!0),init:this.eat(l.eq)?this.flowEnumMemberInit():{type:\"none\",pos:t}}}flowEnumCheckExplicitTypeMismatch(t,e,s){const{explicitType:i}=e;null!==i&&i!==s&&this.flowEnumErrorInvalidMemberInitializer(t,e)}flowEnumMembers({enumName:t,explicitType:e}){const s=new Set,i={booleanMembers:[],numberMembers:[],stringMembers:[],defaultedMembers:[]};for(;!this.match(l.braceR);){const r=this.startNode(),{id:a,init:n}=this.flowEnumMemberRaw(),o=a.name;if(\"\"===o)continue;/^[a-z]/.test(o)&&this.flowEnumErrorInvalidMemberName(a.start,{enumName:t,memberName:o}),s.has(o)&&this.flowEnumErrorDuplicateMemberName(a.start,{enumName:t,memberName:o}),s.add(o);const h={enumName:t,explicitType:e,memberName:o};switch(r.id=a,n.type){case\"boolean\":this.flowEnumCheckExplicitTypeMismatch(n.pos,h,\"boolean\"),r.init=n.value,i.booleanMembers.push(this.finishNode(r,\"EnumBooleanMember\"));break;case\"number\":this.flowEnumCheckExplicitTypeMismatch(n.pos,h,\"number\"),r.init=n.value,i.numberMembers.push(this.finishNode(r,\"EnumNumberMember\"));break;case\"string\":this.flowEnumCheckExplicitTypeMismatch(n.pos,h,\"string\"),r.init=n.value,i.stringMembers.push(this.finishNode(r,\"EnumStringMember\"));break;case\"invalid\":throw this.flowEnumErrorInvalidMemberInitializer(n.pos,h);case\"none\":switch(e){case\"boolean\":this.flowEnumErrorBooleanMemberNotInitialized(n.pos,h);break;case\"number\":this.flowEnumErrorNumberMemberNotInitialized(n.pos,h);break;default:i.defaultedMembers.push(this.finishNode(r,\"EnumDefaultedMember\"))}}this.match(l.braceR)||this.expect(l.comma)}return i}flowEnumStringMembers(t,e,{enumName:s}){if(0===t.length)return e;if(0===e.length)return t;if(e.length>t.length){for(let e=0;e<t.length;e++){const i=t[e];this.flowEnumErrorStringMemberInconsistentlyInitailized(i.start,{enumName:s})}return e}for(let i=0;i<e.length;i++){const t=e[i];this.flowEnumErrorStringMemberInconsistentlyInitailized(t.start,{enumName:s})}return t}flowEnumParseExplicitType({enumName:t}){if(this.eatContextual(\"of\")){if(!this.match(l.name))throw this.flowEnumErrorInvalidExplicitType(this.state.start,{enumName:t,suppliedType:null});const{value:e}=this.state;return this.next(),\"boolean\"!==e&&\"number\"!==e&&\"string\"!==e&&\"symbol\"!==e&&this.flowEnumErrorInvalidExplicitType(this.state.start,{enumName:t,suppliedType:e}),e}return null}flowEnumBody(t,{enumName:e,nameLoc:s}){const i=this.flowEnumParseExplicitType({enumName:e});this.expect(l.braceL);const r=this.flowEnumMembers({enumName:e,explicitType:i});switch(i){case\"boolean\":return t.explicitType=!0,t.members=r.booleanMembers,this.expect(l.braceR),this.finishNode(t,\"EnumBooleanBody\");case\"number\":return t.explicitType=!0,t.members=r.numberMembers,this.expect(l.braceR),this.finishNode(t,\"EnumNumberBody\");case\"string\":return t.explicitType=!0,t.members=this.flowEnumStringMembers(r.stringMembers,r.defaultedMembers,{enumName:e}),this.expect(l.braceR),this.finishNode(t,\"EnumStringBody\");case\"symbol\":return t.members=r.defaultedMembers,this.expect(l.braceR),this.finishNode(t,\"EnumSymbolBody\");default:{const i=()=>(t.members=[],this.expect(l.braceR),this.finishNode(t,\"EnumStringBody\"));t.explicitType=!1;const a=r.booleanMembers.length,n=r.numberMembers.length,o=r.stringMembers.length,h=r.defaultedMembers.length;if(a||n||o||h){if(a||n){if(!n&&!o&&a>=h){for(let t=0,s=r.defaultedMembers;t<s.length;t++){const i=s[t];this.flowEnumErrorBooleanMemberNotInitialized(i.start,{enumName:e,memberName:i.id.name})}return t.members=r.booleanMembers,this.expect(l.braceR),this.finishNode(t,\"EnumBooleanBody\")}if(!a&&!o&&n>=h){for(let t=0,s=r.defaultedMembers;t<s.length;t++){const i=s[t];this.flowEnumErrorNumberMemberNotInitialized(i.start,{enumName:e,memberName:i.id.name})}return t.members=r.numberMembers,this.expect(l.braceR),this.finishNode(t,\"EnumNumberBody\")}return this.flowEnumErrorInconsistentMemberValues(s,{enumName:e}),i()}return t.members=this.flowEnumStringMembers(r.stringMembers,r.defaultedMembers,{enumName:e}),this.expect(l.braceR),this.finishNode(t,\"EnumStringBody\")}return i()}}}flowParseEnumDeclaration(t){const e=this.parseIdentifier();return t.id=e,t.body=this.flowEnumBody(this.startNode(),{enumName:e.name,nameLoc:e.start}),this.finishNode(t,\"EnumDeclaration\")}updateContext(t){this.match(l.name)&&\"of\"===this.state.value&&t===l.name&&\"interface\"===this.input.slice(this.state.lastTokStart,this.state.lastTokEnd)?this.state.exprAllowed=!1:super.updateContext(t)}isLookaheadToken_lt(){const t=this.nextTokenStart();if(60===this.input.charCodeAt(t)){const e=this.input.charCodeAt(t+1);return 60!==e&&61!==e}return!1}maybeUnwrapTypeCastExpression(t){return\"TypeCastExpression\"===t.type?t.expression:t}},typescript:t=>class extends t{getScopeHandler(){return ct}tsIsIdentifier(){return this.match(l.name)}tsNextTokenCanFollowModifier(){return this.next(),(this.match(l.bracketL)||this.match(l.braceL)||this.match(l.star)||this.match(l.ellipsis)||this.match(l.hash)||this.isLiteralPropertyName())&&!this.hasPrecedingLineBreak()}tsParseModifier(t){if(!this.match(l.name))return;const e=this.state.value;return-1!==t.indexOf(e)&&this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))?e:void 0}tsParseModifiers(t,e,s,i){for(;;){const r=this.state.start,a=this.tsParseModifier(e.concat(null!=s?s:[]));if(!a)break;yt(a)?t.accessibility?this.raise(r,ft.DuplicateAccessibilityModifier):t.accessibility=a:(Object.hasOwnProperty.call(t,a)&&this.raise(r,ft.DuplicateModifier,a),t[a]=!0),(null==s?void 0:s.includes(a))&&this.raise(r,i,a)}}tsIsListTerminator(t){switch(t){case\"EnumMembers\":case\"TypeMembers\":return this.match(l.braceR);case\"HeritageClauseElement\":return this.match(l.braceL);case\"TupleElementTypes\":return this.match(l.bracketR);case\"TypeParametersOrArguments\":return this.isRelational(\">\")}throw new Error(\"Unreachable\")}tsParseList(t,e){const s=[];for(;!this.tsIsListTerminator(t);)s.push(e());return s}tsParseDelimitedList(t,e){return dt(this.tsParseDelimitedListWorker(t,e,!0))}tsParseDelimitedListWorker(t,e,s){const i=[];for(;!this.tsIsListTerminator(t);){const r=e();if(null==r)return;if(i.push(r),!this.eat(l.comma)){if(this.tsIsListTerminator(t))break;return void(s&&this.expect(l.comma))}}return i}tsParseBracketedList(t,e,s,i){i||(s?this.expect(l.bracketL):this.expectRelational(\"<\"));const r=this.tsParseDelimitedList(t,e);return s?this.expect(l.bracketR):this.expectRelational(\">\"),r}tsParseImportType(){const t=this.startNode();return this.expect(l._import),this.expect(l.parenL),this.match(l.string)||this.raise(this.state.start,ft.UnsupportedImportTypeArgument),t.argument=this.parseExprAtom(),this.expect(l.parenR),this.eat(l.dot)&&(t.qualifier=this.tsParseEntityName(!0)),this.isRelational(\"<\")&&(t.typeParameters=this.tsParseTypeArguments()),this.finishNode(t,\"TSImportType\")}tsParseEntityName(t){let e=this.parseIdentifier();for(;this.eat(l.dot);){const s=this.startNodeAtNode(e);s.left=e,s.right=this.parseIdentifier(t),e=this.finishNode(s,\"TSQualifiedName\")}return e}tsParseTypeReference(){const t=this.startNode();return t.typeName=this.tsParseEntityName(!1),!this.hasPrecedingLineBreak()&&this.isRelational(\"<\")&&(t.typeParameters=this.tsParseTypeArguments()),this.finishNode(t,\"TSTypeReference\")}tsParseThisTypePredicate(t){this.next();const e=this.startNodeAtNode(t);return e.parameterName=t,e.typeAnnotation=this.tsParseTypeAnnotation(!1),e.asserts=!1,this.finishNode(e,\"TSTypePredicate\")}tsParseThisTypeNode(){const t=this.startNode();return this.next(),this.finishNode(t,\"TSThisType\")}tsParseTypeQuery(){const t=this.startNode();return this.expect(l._typeof),this.match(l._import)?t.exprName=this.tsParseImportType():t.exprName=this.tsParseEntityName(!0),this.finishNode(t,\"TSTypeQuery\")}tsParseTypeParameter(){const t=this.startNode();return t.name=this.parseIdentifierName(t.start),t.constraint=this.tsEatThenParseType(l._extends),t.default=this.tsEatThenParseType(l.eq),this.finishNode(t,\"TSTypeParameter\")}tsTryParseTypeParameters(){if(this.isRelational(\"<\"))return this.tsParseTypeParameters()}tsParseTypeParameters(){const t=this.startNode();return this.isRelational(\"<\")||this.match(l.jsxTagStart)?this.next():this.unexpected(),t.params=this.tsParseBracketedList(\"TypeParametersOrArguments\",this.tsParseTypeParameter.bind(this),!1,!0),0===t.params.length&&this.raise(t.start,ft.EmptyTypeParameters),this.finishNode(t,\"TSTypeParameterDeclaration\")}tsTryNextParseConstantContext(){return this.lookahead().type===l._const?(this.next(),this.tsParseTypeReference()):null}tsFillSignature(t,e){const s=t===l.arrow;e.typeParameters=this.tsTryParseTypeParameters(),this.expect(l.parenL),e.parameters=this.tsParseBindingListForSignature(),(s||this.match(t))&&(e.typeAnnotation=this.tsParseTypeOrTypePredicateAnnotation(t))}tsParseBindingListForSignature(){return this.parseBindingList(l.parenR,41).map((t=>(\"Identifier\"!==t.type&&\"RestElement\"!==t.type&&\"ObjectPattern\"!==t.type&&\"ArrayPattern\"!==t.type&&this.raise(t.start,ft.UnsupportedSignatureParameterKind,t.type),t)))}tsParseTypeMemberSemicolon(){this.eat(l.comma)||this.semicolon()}tsParseSignatureMember(t,e){return this.tsFillSignature(l.colon,e),this.tsParseTypeMemberSemicolon(),this.finishNode(e,t)}tsIsUnambiguouslyIndexSignature(){return this.next(),this.eat(l.name)&&this.match(l.colon)}tsTryParseIndexSignature(t){if(!this.match(l.bracketL)||!this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))return;this.expect(l.bracketL);const e=this.parseIdentifier();e.typeAnnotation=this.tsParseTypeAnnotation(),this.resetEndLocation(e),this.expect(l.bracketR),t.parameters=[e];const s=this.tsTryParseTypeAnnotation();return s&&(t.typeAnnotation=s),this.tsParseTypeMemberSemicolon(),this.finishNode(t,\"TSIndexSignature\")}tsParsePropertyOrMethodSignature(t,e){this.eat(l.question)&&(t.optional=!0);const s=t;if(this.match(l.parenL)||this.isRelational(\"<\")){e&&this.raise(t.start,ft.ReadonlyForMethodSignature);const i=s;return this.tsFillSignature(l.colon,i),this.tsParseTypeMemberSemicolon(),this.finishNode(i,\"TSMethodSignature\")}{const t=s;e&&(t.readonly=!0);const i=this.tsTryParseTypeAnnotation();return i&&(t.typeAnnotation=i),this.tsParseTypeMemberSemicolon(),this.finishNode(t,\"TSPropertySignature\")}}tsParseTypeMember(){const t=this.startNode();if(this.match(l.parenL)||this.isRelational(\"<\"))return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\",t);if(this.match(l._new)){const e=this.startNode();return this.next(),this.match(l.parenL)||this.isRelational(\"<\")?this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\",t):(t.key=this.createIdentifier(e,\"new\"),this.tsParsePropertyOrMethodSignature(t,!1))}this.tsParseModifiers(t,[\"readonly\"],[\"declare\",\"abstract\",\"private\",\"protected\",\"public\",\"static\"],ft.InvalidModifierOnTypeMember);const e=this.tsTryParseIndexSignature(t);return e||(this.parsePropertyName(t,!1),this.tsParsePropertyOrMethodSignature(t,!!t.readonly))}tsParseTypeLiteral(){const t=this.startNode();return t.members=this.tsParseObjectTypeMembers(),this.finishNode(t,\"TSTypeLiteral\")}tsParseObjectTypeMembers(){this.expect(l.braceL);const t=this.tsParseList(\"TypeMembers\",this.tsParseTypeMember.bind(this));return this.expect(l.braceR),t}tsIsStartOfMappedType(){return this.next(),this.eat(l.plusMin)?this.isContextual(\"readonly\"):(this.isContextual(\"readonly\")&&this.next(),!!this.match(l.bracketL)&&(this.next(),!!this.tsIsIdentifier()&&(this.next(),this.match(l._in))))}tsParseMappedTypeParameter(){const t=this.startNode();return t.name=this.parseIdentifierName(t.start),t.constraint=this.tsExpectThenParseType(l._in),this.finishNode(t,\"TSTypeParameter\")}tsParseMappedType(){const t=this.startNode();return this.expect(l.braceL),this.match(l.plusMin)?(t.readonly=this.state.value,this.next(),this.expectContextual(\"readonly\")):this.eatContextual(\"readonly\")&&(t.readonly=!0),this.expect(l.bracketL),t.typeParameter=this.tsParseMappedTypeParameter(),t.nameType=this.eatContextual(\"as\")?this.tsParseType():null,this.expect(l.bracketR),this.match(l.plusMin)?(t.optional=this.state.value,this.next(),this.expect(l.question)):this.eat(l.question)&&(t.optional=!0),t.typeAnnotation=this.tsTryParseType(),this.semicolon(),this.expect(l.braceR),this.finishNode(t,\"TSMappedType\")}tsParseTupleType(){const t=this.startNode();t.elementTypes=this.tsParseBracketedList(\"TupleElementTypes\",this.tsParseTupleElementType.bind(this),!0,!1);let e=!1,s=null;return t.elementTypes.forEach((t=>{var i;let{type:r}=t;!e||\"TSRestType\"===r||\"TSOptionalType\"===r||\"TSNamedTupleMember\"===r&&t.optional||this.raise(t.start,ft.OptionalTypeBeforeRequired),e=e||\"TSNamedTupleMember\"===r&&t.optional||\"TSOptionalType\"===r,\"TSRestType\"===r&&(r=(t=t.typeAnnotation).type);const a=\"TSNamedTupleMember\"===r;s=null!=(i=s)?i:a,s!==a&&this.raise(t.start,ft.MixedLabeledAndUnlabeledElements)})),this.finishNode(t,\"TSTupleType\")}tsParseTupleElementType(){const{start:t,startLoc:e}=this.state,s=this.eat(l.ellipsis);let i=this.tsParseType();const r=this.eat(l.question);if(this.eat(l.colon)){const t=this.startNodeAtNode(i);t.optional=r,\"TSTypeReference\"!==i.type||i.typeParameters||\"Identifier\"!==i.typeName.type?(this.raise(i.start,ft.InvalidTupleMemberLabel),t.label=i):t.label=i.typeName,t.elementType=this.tsParseType(),i=this.finishNode(t,\"TSNamedTupleMember\")}else if(r){const t=this.startNodeAtNode(i);t.typeAnnotation=i,i=this.finishNode(t,\"TSOptionalType\")}if(s){const s=this.startNodeAt(t,e);s.typeAnnotation=i,i=this.finishNode(s,\"TSRestType\")}return i}tsParseParenthesizedType(){const t=this.startNode();return this.expect(l.parenL),t.typeAnnotation=this.tsParseType(),this.expect(l.parenR),this.finishNode(t,\"TSParenthesizedType\")}tsParseFunctionOrConstructorType(t){const e=this.startNode();return\"TSConstructorType\"===t&&this.expect(l._new),this.tsFillSignature(l.arrow,e),this.finishNode(e,t)}tsParseLiteralTypeNode(){const t=this.startNode();return t.literal=(()=>{switch(this.state.type){case l.num:case l.bigint:case l.string:case l._true:case l._false:return this.parseExprAtom();default:throw this.unexpected()}})(),this.finishNode(t,\"TSLiteralType\")}tsParseTemplateLiteralType(){const t=this.startNode();return t.literal=this.parseTemplate(!1),this.finishNode(t,\"TSLiteralType\")}parseTemplateSubstitution(){return this.state.inType?this.tsParseType():super.parseTemplateSubstitution()}tsParseThisTypeOrThisTypePredicate(){const t=this.tsParseThisTypeNode();return this.isContextual(\"is\")&&!this.hasPrecedingLineBreak()?this.tsParseThisTypePredicate(t):t}tsParseNonArrayType(){switch(this.state.type){case l.name:case l._void:case l._null:{const t=this.match(l._void)?\"TSVoidKeyword\":this.match(l._null)?\"TSNullKeyword\":function(t){switch(t){case\"any\":return\"TSAnyKeyword\";case\"boolean\":return\"TSBooleanKeyword\";case\"bigint\":return\"TSBigIntKeyword\";case\"never\":return\"TSNeverKeyword\";case\"number\":return\"TSNumberKeyword\";case\"object\":return\"TSObjectKeyword\";case\"string\":return\"TSStringKeyword\";case\"symbol\":return\"TSSymbolKeyword\";case\"undefined\":return\"TSUndefinedKeyword\";case\"unknown\":return\"TSUnknownKeyword\";default:return}}(this.state.value);if(void 0!==t&&46!==this.lookaheadCharCode()){const e=this.startNode();return this.next(),this.finishNode(e,t)}return this.tsParseTypeReference()}case l.string:case l.num:case l.bigint:case l._true:case l._false:return this.tsParseLiteralTypeNode();case l.plusMin:if(\"-\"===this.state.value){const t=this.startNode(),e=this.lookahead();if(e.type!==l.num&&e.type!==l.bigint)throw this.unexpected();return t.literal=this.parseMaybeUnary(),this.finishNode(t,\"TSLiteralType\")}break;case l._this:return this.tsParseThisTypeOrThisTypePredicate();case l._typeof:return this.tsParseTypeQuery();case l._import:return this.tsParseImportType();case l.braceL:return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))?this.tsParseMappedType():this.tsParseTypeLiteral();case l.bracketL:return this.tsParseTupleType();case l.parenL:return this.tsParseParenthesizedType();case l.backQuote:return this.tsParseTemplateLiteralType()}throw this.unexpected()}tsParseArrayTypeOrHigher(){let t=this.tsParseNonArrayType();for(;!this.hasPrecedingLineBreak()&&this.eat(l.bracketL);)if(this.match(l.bracketR)){const e=this.startNodeAtNode(t);e.elementType=t,this.expect(l.bracketR),t=this.finishNode(e,\"TSArrayType\")}else{const e=this.startNodeAtNode(t);e.objectType=t,e.indexType=this.tsParseType(),this.expect(l.bracketR),t=this.finishNode(e,\"TSIndexedAccessType\")}return t}tsParseTypeOperator(t){const e=this.startNode();return this.expectContextual(t),e.operator=t,e.typeAnnotation=this.tsParseTypeOperatorOrHigher(),\"readonly\"===t&&this.tsCheckTypeAnnotationForReadOnly(e),this.finishNode(e,\"TSTypeOperator\")}tsCheckTypeAnnotationForReadOnly(t){switch(t.typeAnnotation.type){case\"TSTupleType\":case\"TSArrayType\":return;default:this.raise(t.start,ft.UnexpectedReadonly)}}tsParseInferType(){const t=this.startNode();this.expectContextual(\"infer\");const e=this.startNode();return e.name=this.parseIdentifierName(e.start),t.typeParameter=this.finishNode(e,\"TSTypeParameter\"),this.finishNode(t,\"TSInferType\")}tsParseTypeOperatorOrHigher(){const t=[\"keyof\",\"unique\",\"readonly\"].find((t=>this.isContextual(t)));return t?this.tsParseTypeOperator(t):this.isContextual(\"infer\")?this.tsParseInferType():this.tsParseArrayTypeOrHigher()}tsParseUnionOrIntersectionType(t,e,s){const i=this.startNode(),r=this.eat(s),a=[];do{a.push(e())}while(this.eat(s));return 1!==a.length||r?(i.types=a,this.finishNode(i,t)):a[0]}tsParseIntersectionTypeOrHigher(){return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\",this.tsParseTypeOperatorOrHigher.bind(this),l.bitwiseAND)}tsParseUnionTypeOrHigher(){return this.tsParseUnionOrIntersectionType(\"TSUnionType\",this.tsParseIntersectionTypeOrHigher.bind(this),l.bitwiseOR)}tsIsStartOfFunctionType(){return!!this.isRelational(\"<\")||this.match(l.parenL)&&this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))}tsSkipParameterStart(){if(this.match(l.name)||this.match(l._this))return this.next(),!0;if(this.match(l.braceL)){let t=1;for(this.next();t>0;)this.match(l.braceL)?++t:this.match(l.braceR)&&--t,this.next();return!0}if(this.match(l.bracketL)){let t=1;for(this.next();t>0;)this.match(l.bracketL)?++t:this.match(l.bracketR)&&--t,this.next();return!0}return!1}tsIsUnambiguouslyStartOfFunctionType(){if(this.next(),this.match(l.parenR)||this.match(l.ellipsis))return!0;if(this.tsSkipParameterStart()){if(this.match(l.colon)||this.match(l.comma)||this.match(l.question)||this.match(l.eq))return!0;if(this.match(l.parenR)&&(this.next(),this.match(l.arrow)))return!0}return!1}tsParseTypeOrTypePredicateAnnotation(t){return this.tsInType((()=>{const e=this.startNode();this.expect(t);const s=this.startNode(),i=!!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));if(i&&this.match(l._this)){let t=this.tsParseThisTypeOrThisTypePredicate();return\"TSThisType\"===t.type?(s.parameterName=t,s.asserts=!0,t=this.finishNode(s,\"TSTypePredicate\")):(this.resetStartLocationFromNode(t,s),t.asserts=!0),e.typeAnnotation=t,this.finishNode(e,\"TSTypeAnnotation\")}const r=this.tsIsIdentifier()&&this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));if(!r)return i?(s.parameterName=this.parseIdentifier(),s.asserts=i,e.typeAnnotation=this.finishNode(s,\"TSTypePredicate\"),this.finishNode(e,\"TSTypeAnnotation\")):this.tsParseTypeAnnotation(!1,e);const a=this.tsParseTypeAnnotation(!1);return s.parameterName=r,s.typeAnnotation=a,s.asserts=i,e.typeAnnotation=this.finishNode(s,\"TSTypePredicate\"),this.finishNode(e,\"TSTypeAnnotation\")}))}tsTryParseTypeOrTypePredicateAnnotation(){return this.match(l.colon)?this.tsParseTypeOrTypePredicateAnnotation(l.colon):void 0}tsTryParseTypeAnnotation(){return this.match(l.colon)?this.tsParseTypeAnnotation():void 0}tsTryParseType(){return this.tsEatThenParseType(l.colon)}tsParseTypePredicatePrefix(){const t=this.parseIdentifier();if(this.isContextual(\"is\")&&!this.hasPrecedingLineBreak())return this.next(),t}tsParseTypePredicateAsserts(){if(!this.match(l.name)||\"asserts\"!==this.state.value||this.hasPrecedingLineBreak())return!1;const t=this.state.containsEsc;return this.next(),!(!this.match(l.name)&&!this.match(l._this))&&(t&&this.raise(this.state.lastTokStart,b.InvalidEscapedReservedWord,\"asserts\"),!0)}tsParseTypeAnnotation(t=!0,e=this.startNode()){return this.tsInType((()=>{t&&this.expect(l.colon),e.typeAnnotation=this.tsParseType()})),this.finishNode(e,\"TSTypeAnnotation\")}tsParseType(){mt(this.state.inType);const t=this.tsParseNonConditionalType();if(this.hasPrecedingLineBreak()||!this.eat(l._extends))return t;const e=this.startNodeAtNode(t);return e.checkType=t,e.extendsType=this.tsParseNonConditionalType(),this.expect(l.question),e.trueType=this.tsParseType(),this.expect(l.colon),e.falseType=this.tsParseType(),this.finishNode(e,\"TSConditionalType\")}tsParseNonConditionalType(){return this.tsIsStartOfFunctionType()?this.tsParseFunctionOrConstructorType(\"TSFunctionType\"):this.match(l._new)?this.tsParseFunctionOrConstructorType(\"TSConstructorType\"):this.tsParseUnionTypeOrHigher()}tsParseTypeAssertion(){const t=this.startNode(),e=this.tsTryNextParseConstantContext();return t.typeAnnotation=e||this.tsNextThenParseType(),this.expectRelational(\">\"),t.expression=this.parseMaybeUnary(),this.finishNode(t,\"TSTypeAssertion\")}tsParseHeritageClause(t){const e=this.state.start,s=this.tsParseDelimitedList(\"HeritageClauseElement\",this.tsParseExpressionWithTypeArguments.bind(this));return s.length||this.raise(e,ft.EmptyHeritageClauseType,t),s}tsParseExpressionWithTypeArguments(){const t=this.startNode();return t.expression=this.tsParseEntityName(!1),this.isRelational(\"<\")&&(t.typeParameters=this.tsParseTypeArguments()),this.finishNode(t,\"TSExpressionWithTypeArguments\")}tsParseInterfaceDeclaration(t){t.id=this.parseIdentifier(),this.checkLVal(t.id,\"typescript interface declaration\",130),t.typeParameters=this.tsTryParseTypeParameters(),this.eat(l._extends)&&(t.extends=this.tsParseHeritageClause(\"extends\"));const e=this.startNode();return e.body=this.tsInType(this.tsParseObjectTypeMembers.bind(this)),t.body=this.finishNode(e,\"TSInterfaceBody\"),this.finishNode(t,\"TSInterfaceDeclaration\")}tsParseTypeAliasDeclaration(t){return t.id=this.parseIdentifier(),this.checkLVal(t.id,\"typescript type alias\",2),t.typeParameters=this.tsTryParseTypeParameters(),t.typeAnnotation=this.tsInType((()=>{if(this.expect(l.eq),this.isContextual(\"intrinsic\")&&this.lookahead().type!==l.dot){const t=this.startNode();return this.next(),this.finishNode(t,\"TSIntrinsicKeyword\")}return this.tsParseType()})),this.semicolon(),this.finishNode(t,\"TSTypeAliasDeclaration\")}tsInNoContext(t){const e=this.state.context;this.state.context=[e[0]];try{return t()}finally{this.state.context=e}}tsInType(t){const e=this.state.inType;this.state.inType=!0;try{return t()}finally{this.state.inType=e}}tsEatThenParseType(t){return this.match(t)?this.tsNextThenParseType():void 0}tsExpectThenParseType(t){return this.tsDoThenParseType((()=>this.expect(t)))}tsNextThenParseType(){return this.tsDoThenParseType((()=>this.next()))}tsDoThenParseType(t){return this.tsInType((()=>(t(),this.tsParseType())))}tsParseEnumMember(){const t=this.startNode();return t.id=this.match(l.string)?this.parseExprAtom():this.parseIdentifier(!0),this.eat(l.eq)&&(t.initializer=this.parseMaybeAssignAllowIn()),this.finishNode(t,\"TSEnumMember\")}tsParseEnumDeclaration(t,e){return e&&(t.const=!0),t.id=this.parseIdentifier(),this.checkLVal(t.id,\"typescript enum declaration\",e?779:267),this.expect(l.braceL),t.members=this.tsParseDelimitedList(\"EnumMembers\",this.tsParseEnumMember.bind(this)),this.expect(l.braceR),this.finishNode(t,\"TSEnumDeclaration\")}tsParseModuleBlock(){const t=this.startNode();return this.scope.enter(0),this.expect(l.braceL),this.parseBlockOrModuleBlockBody(t.body=[],void 0,!0,l.braceR),this.scope.exit(),this.finishNode(t,\"TSModuleBlock\")}tsParseModuleOrNamespaceDeclaration(t,e=!1){if(t.id=this.parseIdentifier(),e||this.checkLVal(t.id,\"module or namespace declaration\",1024),this.eat(l.dot)){const e=this.startNode();this.tsParseModuleOrNamespaceDeclaration(e,!0),t.body=e}else this.scope.enter(z),this.prodParam.enter(0),t.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit();return this.finishNode(t,\"TSModuleDeclaration\")}tsParseAmbientExternalModuleDeclaration(t){return this.isContextual(\"global\")?(t.global=!0,t.id=this.parseIdentifier()):this.match(l.string)?t.id=this.parseExprAtom():this.unexpected(),this.match(l.braceL)?(this.scope.enter(z),this.prodParam.enter(0),t.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit()):this.semicolon(),this.finishNode(t,\"TSModuleDeclaration\")}tsParseImportEqualsDeclaration(t,e){return t.isExport=e||!1,t.id=this.parseIdentifier(),this.checkLVal(t.id,\"import equals declaration\",9),this.expect(l.eq),t.moduleReference=this.tsParseModuleReference(),this.semicolon(),this.finishNode(t,\"TSImportEqualsDeclaration\")}tsIsExternalModuleReference(){return this.isContextual(\"require\")&&40===this.lookaheadCharCode()}tsParseModuleReference(){return this.tsIsExternalModuleReference()?this.tsParseExternalModuleReference():this.tsParseEntityName(!1)}tsParseExternalModuleReference(){const t=this.startNode();if(this.expectContextual(\"require\"),this.expect(l.parenL),!this.match(l.string))throw this.unexpected();return t.expression=this.parseExprAtom(),this.expect(l.parenR),this.finishNode(t,\"TSExternalModuleReference\")}tsLookAhead(t){const e=this.state.clone(),s=t();return this.state=e,s}tsTryParseAndCatch(t){const e=this.tryParse((e=>t()||e()));if(!e.aborted&&e.node)return e.error&&(this.state=e.failState),e.node}tsTryParse(t){const e=this.state.clone(),s=t();return void 0!==s&&!1!==s?s:void(this.state=e)}tsTryParseDeclare(t){if(this.isLineTerminator())return;let e,s=this.state.type;return this.isContextual(\"let\")&&(s=l._var,e=\"let\"),this.tsInDeclareContext((()=>{switch(s){case l._function:return t.declare=!0,this.parseFunctionStatement(t,!1,!0);case l._class:return t.declare=!0,this.parseClass(t,!0,!1);case l._const:if(this.match(l._const)&&this.isLookaheadContextual(\"enum\"))return this.expect(l._const),this.expectContextual(\"enum\"),this.tsParseEnumDeclaration(t,!0);case l._var:return e=e||this.state.value,this.parseVarStatement(t,e);case l.name:{const e=this.state.value;return\"global\"===e?this.tsParseAmbientExternalModuleDeclaration(t):this.tsParseDeclaration(t,e,!0)}}}))}tsTryParseExportDeclaration(){return this.tsParseDeclaration(this.startNode(),this.state.value,!0)}tsParseExpressionStatement(t,e){switch(e.name){case\"declare\":{const e=this.tsTryParseDeclare(t);if(e)return e.declare=!0,e;break}case\"global\":if(this.match(l.braceL)){this.scope.enter(z),this.prodParam.enter(0);const s=t;return s.global=!0,s.id=e,s.body=this.tsParseModuleBlock(),this.scope.exit(),this.prodParam.exit(),this.finishNode(s,\"TSModuleDeclaration\")}break;default:return this.tsParseDeclaration(t,e.name,!1)}}tsParseDeclaration(t,e,s){switch(e){case\"abstract\":if(this.tsCheckLineTerminator(s)&&(this.match(l._class)||this.match(l.name)))return this.tsParseAbstractDeclaration(t);break;case\"enum\":if(s||this.match(l.name))return s&&this.next(),this.tsParseEnumDeclaration(t,!1);break;case\"interface\":if(this.tsCheckLineTerminator(s)&&this.match(l.name))return this.tsParseInterfaceDeclaration(t);break;case\"module\":if(this.tsCheckLineTerminator(s)){if(this.match(l.string))return this.tsParseAmbientExternalModuleDeclaration(t);if(this.match(l.name))return this.tsParseModuleOrNamespaceDeclaration(t)}break;case\"namespace\":if(this.tsCheckLineTerminator(s)&&this.match(l.name))return this.tsParseModuleOrNamespaceDeclaration(t);break;case\"type\":if(this.tsCheckLineTerminator(s)&&this.match(l.name))return this.tsParseTypeAliasDeclaration(t)}}tsCheckLineTerminator(t){return t?!this.hasFollowingLineBreak()&&(this.next(),!0):!this.isLineTerminator()}tsTryParseGenericAsyncArrowFunction(t,e){if(!this.isRelational(\"<\"))return;const s=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=!0;const i=this.tsTryParseAndCatch((()=>{const s=this.startNodeAt(t,e);return s.typeParameters=this.tsParseTypeParameters(),super.parseFunctionParams(s),s.returnType=this.tsTryParseTypeOrTypePredicateAnnotation(),this.expect(l.arrow),s}));return this.state.maybeInArrowParameters=s,i?this.parseArrowExpression(i,null,!0):void 0}tsParseTypeArguments(){const t=this.startNode();return t.params=this.tsInType((()=>this.tsInNoContext((()=>(this.expectRelational(\"<\"),this.tsParseDelimitedList(\"TypeParametersOrArguments\",this.tsParseType.bind(this))))))),0===t.params.length&&this.raise(t.start,ft.EmptyTypeArguments),this.state.exprAllowed=!1,this.expectRelational(\">\"),this.finishNode(t,\"TSTypeParameterInstantiation\")}tsIsDeclarationStart(){if(this.match(l.name))switch(this.state.value){case\"abstract\":case\"declare\":case\"enum\":case\"interface\":case\"module\":case\"namespace\":case\"type\":return!0}return!1}isExportDefaultSpecifier(){return!this.tsIsDeclarationStart()&&super.isExportDefaultSpecifier()}parseAssignableListItem(t,e){const s=this.state.start,i=this.state.startLoc;let r,a=!1;void 0!==t&&(r=this.parseAccessModifier(),a=!!this.tsParseModifier([\"readonly\"]),!1===t&&(r||a)&&this.raise(s,ft.UnexpectedParameterModifier));const n=this.parseMaybeDefault();this.parseAssignableListItemTypes(n);const o=this.parseMaybeDefault(n.start,n.loc.start,n);if(r||a){const t=this.startNodeAt(s,i);return e.length&&(t.decorators=e),r&&(t.accessibility=r),a&&(t.readonly=a),\"Identifier\"!==o.type&&\"AssignmentPattern\"!==o.type&&this.raise(t.start,ft.UnsupportedParameterPropertyKind),t.parameter=o,this.finishNode(t,\"TSParameterProperty\")}return e.length&&(n.decorators=e),o}parseFunctionBodyAndFinish(t,e,s=!1){this.match(l.colon)&&(t.returnType=this.tsParseTypeOrTypePredicateAnnotation(l.colon));const i=\"FunctionDeclaration\"===e?\"TSDeclareFunction\":\"ClassMethod\"===e?\"TSDeclareMethod\":void 0;i&&!this.match(l.braceL)&&this.isLineTerminator()?this.finishNode(t,i):\"TSDeclareFunction\"===i&&this.state.isDeclareContext&&(this.raise(t.start,ft.DeclareFunctionHasImplementation),t.declare)?super.parseFunctionBodyAndFinish(t,i,s):super.parseFunctionBodyAndFinish(t,e,s)}registerFunctionStatementId(t){!t.body&&t.id?this.checkLVal(t.id,\"function name\",1024):super.registerFunctionStatementId(...arguments)}tsCheckForInvalidTypeCasts(t){t.forEach((t=>{\"TSTypeCastExpression\"===(null==t?void 0:t.type)&&this.raise(t.typeAnnotation.start,ft.UnexpectedTypeAnnotation)}))}toReferencedList(t,e){return this.tsCheckForInvalidTypeCasts(t),t}parseArrayLike(...t){const e=super.parseArrayLike(...t);return\"ArrayExpression\"===e.type&&this.tsCheckForInvalidTypeCasts(e.elements),e}parseSubscript(t,e,s,i,r){if(!this.hasPrecedingLineBreak()&&this.match(l.bang)){this.state.exprAllowed=!1,this.next();const i=this.startNodeAt(e,s);return i.expression=t,this.finishNode(i,\"TSNonNullExpression\")}if(this.isRelational(\"<\")){const a=this.tsTryParseAndCatch((()=>{if(!i&&this.atPossibleAsyncArrow(t)){const t=this.tsTryParseGenericAsyncArrowFunction(e,s);if(t)return t}const a=this.startNodeAt(e,s);a.callee=t;const n=this.tsParseTypeArguments();if(n){if(!i&&this.eat(l.parenL))return a.arguments=this.parseCallExpressionArguments(l.parenR,!1),this.tsCheckForInvalidTypeCasts(a.arguments),a.typeParameters=n,r.optionalChainMember&&(a.optional=!1),this.finishCallExpression(a,r.optionalChainMember);if(this.match(l.backQuote)){const i=this.parseTaggedTemplateExpression(t,e,s,r);return i.typeParameters=n,i}}this.unexpected()}));if(a)return a}return super.parseSubscript(t,e,s,i,r)}parseNewArguments(t){if(this.isRelational(\"<\")){const e=this.tsTryParseAndCatch((()=>{const t=this.tsParseTypeArguments();return this.match(l.parenL)||this.unexpected(),t}));e&&(t.typeParameters=e)}super.parseNewArguments(t)}parseExprOp(t,e,s,i){if(dt(l._in.binop)>i&&!this.hasPrecedingLineBreak()&&this.isContextual(\"as\")){const r=this.startNodeAt(e,s);r.expression=t;const a=this.tsTryNextParseConstantContext();return r.typeAnnotation=a||this.tsNextThenParseType(),this.finishNode(r,\"TSAsExpression\"),this.reScan_lt_gt(),this.parseExprOp(r,e,s,i)}return super.parseExprOp(t,e,s,i)}checkReservedWord(t,e,s,i){}checkDuplicateExports(){}parseImport(t){if(this.match(l.name)||this.match(l.star)||this.match(l.braceL)){const e=this.lookahead();if(this.match(l.name)&&e.type===l.eq)return this.tsParseImportEqualsDeclaration(t);!this.isContextual(\"type\")||e.type===l.comma||e.type===l.name&&\"from\"===e.value||(t.importKind=\"type\",this.next())}t.importKind||(t.importKind=\"value\");const e=super.parseImport(t);return\"type\"===e.importKind&&e.specifiers.length>1&&\"ImportDefaultSpecifier\"===e.specifiers[0].type&&this.raise(e.start,\"A type-only import can specify a default import or named bindings, but not both.\"),e}parseExport(t){if(this.match(l._import))return this.expect(l._import),this.tsParseImportEqualsDeclaration(t,!0);if(this.eat(l.eq)){const e=t;return e.expression=this.parseExpression(),this.semicolon(),this.finishNode(e,\"TSExportAssignment\")}if(this.eatContextual(\"as\")){const e=t;return this.expectContextual(\"namespace\"),e.id=this.parseIdentifier(),this.semicolon(),this.finishNode(e,\"TSNamespaceExportDeclaration\")}return this.isContextual(\"type\")&&this.lookahead().type===l.braceL?(this.next(),t.exportKind=\"type\"):t.exportKind=\"value\",super.parseExport(t)}isAbstractClass(){return this.isContextual(\"abstract\")&&this.lookahead().type===l._class}parseExportDefaultExpression(){if(this.isAbstractClass()){const t=this.startNode();return this.next(),t.abstract=!0,this.parseClass(t,!0,!0),t}if(\"interface\"===this.state.value){const t=this.tsParseDeclaration(this.startNode(),this.state.value,!0);if(t)return t}return super.parseExportDefaultExpression()}parseStatementContent(t,e){if(this.state.type===l._const){const t=this.lookahead();if(t.type===l.name&&\"enum\"===t.value){const t=this.startNode();return this.expect(l._const),this.expectContextual(\"enum\"),this.tsParseEnumDeclaration(t,!0)}}return super.parseStatementContent(t,e)}parseAccessModifier(){return this.tsParseModifier([\"public\",\"protected\",\"private\"])}parseClassMember(t,e,s){this.tsParseModifiers(e,[\"declare\",\"private\",\"public\",\"protected\"]);const i=()=>{super.parseClassMember(t,e,s)};e.declare?this.tsInDeclareContext(i):i()}parseClassMemberWithIsStatic(t,e,s,i){this.tsParseModifiers(e,[\"abstract\",\"readonly\",\"declare\"]);const r=this.tsTryParseIndexSignature(e);if(r)return t.body.push(r),e.abstract&&this.raise(e.start,ft.IndexSignatureHasAbstract),i&&this.raise(e.start,ft.IndexSignatureHasStatic),e.accessibility&&this.raise(e.start,ft.IndexSignatureHasAccessibility,e.accessibility),void(e.declare&&this.raise(e.start,ft.IndexSignatureHasDeclare));!this.state.inAbstractClass&&e.abstract&&this.raise(e.start,ft.NonAbstractClassHasAbstractMethod),super.parseClassMemberWithIsStatic(t,e,s,i)}parsePostMemberNameModifiers(t){this.eat(l.question)&&(t.optional=!0),t.readonly&&this.match(l.parenL)&&this.raise(t.start,ft.ClassMethodHasReadonly),t.declare&&this.match(l.parenL)&&this.raise(t.start,ft.ClassMethodHasDeclare)}parseExpressionStatement(t,e){return(\"Identifier\"===e.type?this.tsParseExpressionStatement(t,e):void 0)||super.parseExpressionStatement(t,e)}shouldParseExportDeclaration(){return!!this.tsIsDeclarationStart()||super.shouldParseExportDeclaration()}parseConditional(t,e,s,i){if(!i||!this.match(l.question))return super.parseConditional(t,e,s,i);const r=this.tryParse((()=>super.parseConditional(t,e,s)));return r.node?(r.error&&(this.state=r.failState),r.node):(i.start=r.error.pos||this.state.start,t)}parseParenItem(t,e,s){if(t=super.parseParenItem(t,e,s),this.eat(l.question)&&(t.optional=!0,this.resetEndLocation(t)),this.match(l.colon)){const i=this.startNodeAt(e,s);return i.expression=t,i.typeAnnotation=this.tsParseTypeAnnotation(),this.finishNode(i,\"TSTypeCastExpression\")}return t}parseExportDeclaration(t){const e=this.state.start,s=this.state.startLoc,i=this.eatContextual(\"declare\");if(i&&(this.isContextual(\"declare\")||!this.shouldParseExportDeclaration()))throw this.raise(this.state.start,ft.ExpectedAmbientAfterExportDeclare);let r;return this.match(l.name)&&(r=this.tsTryParseExportDeclaration()),r||(r=super.parseExportDeclaration(t)),r&&(\"TSInterfaceDeclaration\"===r.type||\"TSTypeAliasDeclaration\"===r.type||i)&&(t.exportKind=\"type\"),r&&i&&(this.resetStartLocation(r,e,s),r.declare=!0),r}parseClassId(t,e,s){if((!e||s)&&this.isContextual(\"implements\"))return;super.parseClassId(t,e,s,t.declare?1024:139);const i=this.tsTryParseTypeParameters();i&&(t.typeParameters=i)}parseClassPropertyAnnotation(t){!t.optional&&this.eat(l.bang)&&(t.definite=!0);const e=this.tsTryParseTypeAnnotation();e&&(t.typeAnnotation=e)}parseClassProperty(t){return this.parseClassPropertyAnnotation(t),this.state.isDeclareContext&&this.match(l.eq)&&this.raise(this.state.start,ft.DeclareClassFieldHasInitializer),super.parseClassProperty(t)}parseClassPrivateProperty(t){return t.abstract&&this.raise(t.start,ft.PrivateElementHasAbstract),t.accessibility&&this.raise(t.start,ft.PrivateElementHasAccessibility,t.accessibility),this.parseClassPropertyAnnotation(t),super.parseClassPrivateProperty(t)}pushClassMethod(t,e,s,i,r,a){const n=this.tsTryParseTypeParameters();n&&r&&this.raise(n.start,ft.ConstructorHasTypeParameters),n&&(e.typeParameters=n),super.pushClassMethod(t,e,s,i,r,a)}pushClassPrivateMethod(t,e,s,i){const r=this.tsTryParseTypeParameters();r&&(e.typeParameters=r),super.pushClassPrivateMethod(t,e,s,i)}parseClassSuper(t){super.parseClassSuper(t),t.superClass&&this.isRelational(\"<\")&&(t.superTypeParameters=this.tsParseTypeArguments()),this.eatContextual(\"implements\")&&(t.implements=this.tsParseHeritageClause(\"implements\"))}parseObjPropValue(t,...e){const s=this.tsTryParseTypeParameters();s&&(t.typeParameters=s),super.parseObjPropValue(t,...e)}parseFunctionParams(t,e){const s=this.tsTryParseTypeParameters();s&&(t.typeParameters=s),super.parseFunctionParams(t,e)}parseVarId(t,e){super.parseVarId(t,e),\"Identifier\"===t.id.type&&this.eat(l.bang)&&(t.definite=!0);const s=this.tsTryParseTypeAnnotation();s&&(t.id.typeAnnotation=s,this.resetEndLocation(t.id))}parseAsyncArrowFromCallExpression(t,e){return this.match(l.colon)&&(t.returnType=this.tsParseTypeAnnotation()),super.parseAsyncArrowFromCallExpression(t,e)}parseMaybeAssign(...t){var e,s,i,r,a,n,o;let h,p,c,u;if(this.hasPlugin(\"jsx\")&&(this.match(l.jsxTagStart)||this.isRelational(\"<\"))){if(h=this.state.clone(),p=this.tryParse((()=>super.parseMaybeAssign(...t)),h),!p.error)return p.node;const{context:e}=this.state;e[e.length-1]===A.j_oTag?e.length-=2:e[e.length-1]===A.j_expr&&(e.length-=1)}if(!(null==(e=p)?void 0:e.error)&&!this.isRelational(\"<\"))return super.parseMaybeAssign(...t);h=h||this.state.clone();const d=this.tryParse((e=>{var s;u=this.tsParseTypeParameters();const i=super.parseMaybeAssign(...t);return(\"ArrowFunctionExpression\"!==i.type||i.extra&&i.extra.parenthesized)&&e(),0!==(null==(s=u)?void 0:s.params.length)&&this.resetStartLocationFromNode(i,u),i.typeParameters=u,i}),h);if(!d.error&&!d.aborted)return d.node;if(!p&&(mt(!this.hasPlugin(\"jsx\")),c=this.tryParse((()=>super.parseMaybeAssign(...t)),h),!c.error))return c.node;if(null==(s=p)?void 0:s.node)return this.state=p.failState,p.node;if(d.node)return this.state=d.failState,d.node;if(null==(i=c)?void 0:i.node)return this.state=c.failState,c.node;if(null==(r=p)?void 0:r.thrown)throw p.error;if(d.thrown)throw d.error;if(null==(a=c)?void 0:a.thrown)throw c.error;throw(null==(n=p)?void 0:n.error)||d.error||(null==(o=c)?void 0:o.error)}parseMaybeUnary(t){return!this.hasPlugin(\"jsx\")&&this.isRelational(\"<\")?this.tsParseTypeAssertion():super.parseMaybeUnary(t)}parseArrow(t){if(this.match(l.colon)){const e=this.tryParse((t=>{const e=this.tsParseTypeOrTypePredicateAnnotation(l.colon);return!this.canInsertSemicolon()&&this.match(l.arrow)||t(),e}));if(e.aborted)return;e.thrown||(e.error&&(this.state=e.failState),t.returnType=e.node)}return super.parseArrow(t)}parseAssignableListItemTypes(t){this.eat(l.question)&&(\"Identifier\"===t.type||this.state.isDeclareContext||this.state.inType||this.raise(t.start,ft.PatternIsOptional),t.optional=!0);const e=this.tsTryParseTypeAnnotation();return e&&(t.typeAnnotation=e),this.resetEndLocation(t),t}toAssignable(t,e=!1){switch(t.type){case\"TSTypeCastExpression\":return super.toAssignable(this.typeCastToParameter(t),e);case\"TSParameterProperty\":return super.toAssignable(t,e);case\"TSAsExpression\":case\"TSNonNullExpression\":case\"TSTypeAssertion\":return t.expression=this.toAssignable(t.expression,e),t;default:return super.toAssignable(t,e)}}checkLVal(t,e,...s){switch(t.type){case\"TSTypeCastExpression\":return;case\"TSParameterProperty\":return void this.checkLVal(t.parameter,\"parameter property\",...s);case\"TSAsExpression\":case\"TSNonNullExpression\":case\"TSTypeAssertion\":return void this.checkLVal(t.expression,e,...s);default:return void super.checkLVal(t,e,...s)}}parseBindingAtom(){switch(this.state.type){case l._this:return this.parseIdentifier(!0);default:return super.parseBindingAtom()}}parseMaybeDecoratorArguments(t){if(this.isRelational(\"<\")){const e=this.tsParseTypeArguments();if(this.match(l.parenL)){const s=super.parseMaybeDecoratorArguments(t);return s.typeParameters=e,s}this.unexpected(this.state.start,l.parenL)}return super.parseMaybeDecoratorArguments(t)}isClassMethod(){return this.isRelational(\"<\")||super.isClassMethod()}isClassProperty(){return this.match(l.bang)||this.match(l.colon)||super.isClassProperty()}parseMaybeDefault(...t){const e=super.parseMaybeDefault(...t);return\"AssignmentPattern\"===e.type&&e.typeAnnotation&&e.right.start<e.typeAnnotation.start&&this.raise(e.typeAnnotation.start,ft.TypeAnnotationAfterAssign),e}getTokenFromCode(t){return!this.state.inType||62!==t&&60!==t?super.getTokenFromCode(t):this.finishOp(l.relational,1)}reScan_lt_gt(){if(this.match(l.relational)){const t=this.input.charCodeAt(this.state.start);60!==t&&62!==t||(this.state.pos-=1,this.readToken_lt_gt(t))}}toAssignableList(t){for(let e=0;e<t.length;e++){const s=t[e];if(s)switch(s.type){case\"TSTypeCastExpression\":t[e]=this.typeCastToParameter(s);break;case\"TSAsExpression\":case\"TSTypeAssertion\":this.state.maybeInArrowParameters?this.raise(s.start,ft.UnexpectedTypeCastInParameter):t[e]=this.typeCastToParameter(s)}}return super.toAssignableList(...arguments)}typeCastToParameter(t){return t.expression.typeAnnotation=t.typeAnnotation,this.resetEndLocation(t.expression,t.typeAnnotation.end,t.typeAnnotation.loc.end),t.expression}shouldParseArrow(){return this.match(l.colon)||super.shouldParseArrow()}shouldParseAsyncArrow(){return this.match(l.colon)||super.shouldParseAsyncArrow()}canHaveLeadingDecorator(){return super.canHaveLeadingDecorator()||this.isAbstractClass()}jsxParseOpeningElementAfterName(t){if(this.isRelational(\"<\")){const e=this.tsTryParseAndCatch((()=>this.tsParseTypeArguments()));e&&(t.typeParameters=e)}return super.jsxParseOpeningElementAfterName(t)}getGetterSetterExpectedParamCount(t){const e=super.getGetterSetterExpectedParamCount(t),s=this.getObjectOrClassMethodParams(t)[0];return s&&\"Identifier\"===s.type&&\"this\"===s.name?e+1:e}parseCatchClauseParam(){const t=super.parseCatchClauseParam(),e=this.tsTryParseTypeAnnotation();return e&&(t.typeAnnotation=e,this.resetEndLocation(t)),t}tsInDeclareContext(t){const e=this.state.isDeclareContext;this.state.isDeclareContext=!0;try{return t()}finally{this.state.isDeclareContext=e}}parseClass(t,...e){const s=this.state.inAbstractClass;this.state.inAbstractClass=!!t.abstract;try{return super.parseClass(t,...e)}finally{this.state.inAbstractClass=s}}tsParseAbstractDeclaration(t){if(this.match(l._class))return t.abstract=!0,this.parseClass(t,!0,!1);if(this.isContextual(\"interface\")){if(!this.hasFollowingLineBreak())return t.abstract=!0,this.raise(t.start,ft.NonClassMethodPropertyHasAbstractModifer),this.next(),this.tsParseInterfaceDeclaration(t)}else this.unexpected(null,l._class)}},v8intrinsic:t=>class extends t{parseV8Intrinsic(){if(this.match(l.modulo)){const t=this.state.start,e=this.startNode();if(this.eat(l.modulo),this.match(l.name)){const t=this.parseIdentifierName(this.state.start),s=this.createIdentifier(e,t);if(s.type=\"V8IntrinsicIdentifier\",this.match(l.parenL))return s}this.unexpected(t)}}parseExprAtom(){return this.parseV8Intrinsic()||super.parseExprAtom(...arguments)}},placeholders:t=>class extends t{parsePlaceholder(t){if(this.match(l.placeholder)){const e=this.startNode();return this.next(),this.assertNoSpace(\"Unexpected space in placeholder.\"),e.name=super.parseIdentifier(!0),this.assertNoSpace(\"Unexpected space in placeholder.\"),this.expect(l.placeholder),this.finishPlaceholder(e,t)}}finishPlaceholder(t,e){const s=!(!t.expectedNode||\"Placeholder\"!==t.type);return t.expectedNode=e,s?t:this.finishNode(t,\"Placeholder\")}getTokenFromCode(t){return 37===t&&37===this.input.charCodeAt(this.state.pos+1)?this.finishOp(l.placeholder,2):super.getTokenFromCode(...arguments)}parseExprAtom(){return this.parsePlaceholder(\"Expression\")||super.parseExprAtom(...arguments)}parseIdentifier(){return this.parsePlaceholder(\"Identifier\")||super.parseIdentifier(...arguments)}checkReservedWord(t){void 0!==t&&super.checkReservedWord(...arguments)}parseBindingAtom(){return this.parsePlaceholder(\"Pattern\")||super.parseBindingAtom(...arguments)}checkLVal(t){\"Placeholder\"!==t.type&&super.checkLVal(...arguments)}toAssignable(t){return t&&\"Placeholder\"===t.type&&\"Expression\"===t.expectedNode?(t.expectedNode=\"Pattern\",t):super.toAssignable(...arguments)}isLet(t){if(super.isLet(t))return!0;if(!this.isContextual(\"let\"))return!1;if(t)return!1;return this.lookahead().type===l.placeholder}verifyBreakContinue(t){t.label&&\"Placeholder\"===t.label.type||super.verifyBreakContinue(...arguments)}parseExpressionStatement(t,e){if(\"Placeholder\"!==e.type||e.extra&&e.extra.parenthesized)return super.parseExpressionStatement(...arguments);if(this.match(l.colon)){const s=t;return s.label=this.finishPlaceholder(e,\"Identifier\"),this.next(),s.body=this.parseStatement(\"label\"),this.finishNode(s,\"LabeledStatement\")}return this.semicolon(),t.name=e.name,this.finishPlaceholder(t,\"Statement\")}parseBlock(){return this.parsePlaceholder(\"BlockStatement\")||super.parseBlock(...arguments)}parseFunctionId(){return this.parsePlaceholder(\"Identifier\")||super.parseFunctionId(...arguments)}parseClass(t,e,s){const i=e?\"ClassDeclaration\":\"ClassExpression\";this.next(),this.takeDecorators(t);const r=this.state.strict,a=this.parsePlaceholder(\"Identifier\");if(a)if(this.match(l._extends)||this.match(l.placeholder)||this.match(l.braceL))t.id=a;else{if(s||!e)return t.id=null,t.body=this.finishPlaceholder(a,\"ClassBody\"),this.finishNode(t,i);this.unexpected(null,\"A class name is required\")}else this.parseClassId(t,e,s);return this.parseClassSuper(t),t.body=this.parsePlaceholder(\"ClassBody\")||this.parseClassBody(!!t.superClass,r),this.finishNode(t,i)}parseExport(t){const e=this.parsePlaceholder(\"Identifier\");if(!e)return super.parseExport(...arguments);if(!this.isContextual(\"from\")&&!this.match(l.comma))return t.specifiers=[],t.source=null,t.declaration=this.finishPlaceholder(e,\"Declaration\"),this.finishNode(t,\"ExportNamedDeclaration\");this.expectPlugin(\"exportDefaultFrom\");const s=this.startNode();return s.exported=e,t.specifiers=[this.finishNode(s,\"ExportDefaultSpecifier\")],super.parseExport(t)}isExportDefaultSpecifier(){if(this.match(l._default)){const t=this.nextTokenStart();if(this.isUnparsedContextual(t,\"from\")&&this.input.startsWith(l.placeholder.label,this.nextTokenStartSince(t+4)))return!0}return super.isExportDefaultSpecifier()}maybeParseExportDefaultSpecifier(t){return!!(t.specifiers&&t.specifiers.length>0)||super.maybeParseExportDefaultSpecifier(...arguments)}checkExport(t){const{specifiers:e}=t;(null==e?void 0:e.length)&&(t.specifiers=e.filter((t=>\"Placeholder\"===t.exported.type))),super.checkExport(t),t.specifiers=e}parseImport(t){const e=this.parsePlaceholder(\"Identifier\");if(!e)return super.parseImport(...arguments);if(t.specifiers=[],!this.isContextual(\"from\")&&!this.match(l.comma))return t.source=this.finishPlaceholder(e,\"StringLiteral\"),this.semicolon(),this.finishNode(t,\"ImportDeclaration\");const s=this.startNodeAtNode(e);if(s.local=e,this.finishNode(s,\"ImportDefaultSpecifier\"),t.specifiers.push(s),this.eat(l.comma)){this.maybeParseStarImportSpecifier(t)||this.parseNamedImportSpecifiers(t)}return this.expectContextual(\"from\"),t.source=this.parseImportSource(),this.semicolon(),this.finishNode(t,\"ImportDeclaration\")}parseImportSource(){return this.parsePlaceholder(\"StringLiteral\")||super.parseImportSource(...arguments)}}},At=Object.keys(Tt),wt={sourceType:\"script\",sourceFilename:void 0,startLine:1,allowAwaitOutsideFunction:!1,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowSuperOutsideMethod:!1,allowUndeclaredExports:!1,plugins:[],strictMode:null,ranges:!1,tokens:!1,createParenthesizedExpressions:!1,errorRecovery:!1};class Et{constructor(){this.strict=void 0,this.curLine=void 0,this.startLoc=void 0,this.endLoc=void 0,this.errors=[],this.potentialArrowAt=-1,this.noArrowAt=[],this.noArrowParamsConversionAt=[],this.maybeInArrowParameters=!1,this.inPipeline=!1,this.inType=!1,this.noAnonFunctionType=!1,this.inPropertyName=!1,this.hasFlowComment=!1,this.isIterator=!1,this.isDeclareContext=!1,this.inAbstractClass=!1,this.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null},this.soloAwait=!1,this.inFSharpPipelineDirectBody=!1,this.labels=[],this.decoratorStack=[[]],this.comments=[],this.trailingComments=[],this.leadingComments=[],this.commentStack=[],this.commentPreviousNode=null,this.pos=0,this.lineStart=0,this.type=l.eof,this.value=null,this.start=0,this.end=0,this.lastTokEndLoc=null,this.lastTokStartLoc=null,this.lastTokStart=0,this.lastTokEnd=0,this.context=[A.braceStatement],this.exprAllowed=!0,this.containsEsc=!1,this.strictErrors=new Map,this.exportedIdentifiers=[],this.tokensLength=0}init(t){this.strict=!1!==t.strictMode&&\"module\"===t.sourceType,this.curLine=t.startLine,this.startLoc=this.endLoc=this.curPosition()}curPosition(){return new x(this.curLine,this.pos-this.lineStart)}clone(t){const e=new Et,s=Object.keys(this);for(let i=0,r=s.length;i<r;i++){const r=s[i];let a=this[r];!t&&Array.isArray(a)&&(a=a.slice()),e[r]=a}return e}}var St=function(t){return t>=48&&t<=57};const Ct=new Set([\"g\",\"m\",\"s\",\"i\",\"y\",\"u\"]),Nt={decBinOct:[46,66,69,79,95,98,101,111],hex:[46,88,95,120]},kt={bin:[48,49]};kt.oct=[...kt.bin,50,51,52,53,54,55],kt.dec=[...kt.oct,56,57],kt.hex=[...kt.dec,65,66,67,68,69,70,97,98,99,100,101,102];class It{constructor(t){this.type=t.type,this.value=t.value,this.start=t.start,this.end=t.end,this.loc=new P(t.startLoc,t.endLoc)}}class vt{constructor(){this.shorthandAssign=-1,this.doubleProto=-1}}class Lt{constructor(t,e,s){this.type=void 0,this.start=void 0,this.end=void 0,this.loc=void 0,this.range=void 0,this.leadingComments=void 0,this.trailingComments=void 0,this.innerComments=void 0,this.extra=void 0,this.type=\"\",this.start=e,this.end=0,this.loc=new P(s),(null==t?void 0:t.options.ranges)&&(this.range=[e,0]),(null==t?void 0:t.filename)&&(this.loc.filename=t.filename)}__clone(){const t=new Lt,e=Object.keys(this);for(let s=0,i=e.length;s<i;s++){const i=e[s];\"leadingComments\"!==i&&\"trailingComments\"!==i&&\"innerComments\"!==i&&(t[i]=this[i])}return t}}const Dt=t=>\"ParenthesizedExpression\"===t.type?Dt(t.expression):t;class Mt{constructor(t=0){this.type=void 0,this.type=t}canBeArrowParameterDeclaration(){return 2===this.type||1===this.type}isCertainlyParameterDeclaration(){return 3===this.type}}class Rt extends Mt{constructor(t){super(t),this.errors=new Map}recordDeclarationError(t,e){this.errors.set(t,e)}clearDeclarationError(t){this.errors.delete(t)}iterateErrors(t){this.errors.forEach(t)}}class Ot{constructor(t){this.stack=[new Mt],this.raise=t}enter(t){this.stack.push(t)}exit(){this.stack.pop()}recordParameterInitializerError(t,e){const{stack:s}=this;let i=s.length-1,r=s[i];for(;!r.isCertainlyParameterDeclaration();){if(!r.canBeArrowParameterDeclaration())return;r.recordDeclarationError(t,e),r=s[--i]}this.raise(t,e)}recordParenthesizedIdentifierError(t,e){const{stack:s}=this,i=s[s.length-1];if(i.isCertainlyParameterDeclaration())this.raise(t,e);else{if(!i.canBeArrowParameterDeclaration())return;i.recordDeclarationError(t,e)}}recordAsyncArrowParametersError(t,e){const{stack:s}=this;let i=s.length-1,r=s[i];for(;r.canBeArrowParameterDeclaration();)2===r.type&&r.recordDeclarationError(t,e),r=s[--i]}validateAsPattern(){const{stack:t}=this,e=t[t.length-1];e.canBeArrowParameterDeclaration()&&e.iterateErrors(((e,s)=>{this.raise(s,e);let i=t.length-2,r=t[i];for(;r.canBeArrowParameterDeclaration();)r.clearDeclarationError(s),r=t[--i]}))}}function Ft(){return new Mt}const Bt={kind:\"loop\"},_t={kind:\"switch\"},jt=/[\\uD800-\\uDFFF]/u;class Ut{constructor(){this.privateNames=new Set,this.loneAccessors=new Map,this.undefinedPrivateNames=new Map}}class qt{constructor(t){this.stack=[],this.undefinedPrivateNames=new Map,this.raise=t}current(){return this.stack[this.stack.length-1]}enter(){this.stack.push(new Ut)}exit(){const t=this.stack.pop(),e=this.current();for(let s=0,i=Array.from(t.undefinedPrivateNames);s<i.length;s++){const[t,r]=i[s];e?e.undefinedPrivateNames.has(t)||e.undefinedPrivateNames.set(t,r):this.raise(r,b.InvalidPrivateFieldResolution,t)}}declarePrivateName(t,e,s){const i=this.current();let r=i.privateNames.has(t);if(3&e){const s=r&&i.loneAccessors.get(t);if(s){const a=4&s,n=4&e;r=(3&s)===(3&e)||a!==n,r||i.loneAccessors.delete(t)}else r||i.loneAccessors.set(t,e)}r&&this.raise(s,b.PrivateNameRedeclaration,t),i.privateNames.add(t),i.undefinedPrivateNames.delete(t)}usePrivateName(t,e){let s;for(let i=0,r=this.stack;i<r.length;i++)if(s=r[i],s.privateNames.has(t))return;s?s.undefinedPrivateNames.set(t,e):this.raise(e,b.InvalidPrivateFieldResolution,t)}}class Vt extends class extends class extends class extends class extends class extends class extends class extends class extends class{constructor(){this.sawUnambiguousESM=!1,this.ambiguousScriptDifferentAst=!1}hasPlugin(t){return this.plugins.has(t)}getPluginOption(t,e){if(this.hasPlugin(t))return this.plugins.get(t)[e]}}{addComment(t){this.filename&&(t.loc.filename=this.filename),this.state.trailingComments.push(t),this.state.leadingComments.push(t)}adjustCommentsAfterTrailingComma(t,e,s){if(0===this.state.leadingComments.length)return;let i=null,r=e.length;for(;null===i&&r>0;)i=e[--r];if(null===i)return;for(let n=0;n<this.state.leadingComments.length;n++)this.state.leadingComments[n].end<this.state.commentPreviousNode.end&&(this.state.leadingComments.splice(n,1),n--);const a=[];for(let n=0;n<this.state.leadingComments.length;n++){const e=this.state.leadingComments[n];e.end<t.end?(a.push(e),s||(this.state.leadingComments.splice(n,1),n--)):(void 0===t.trailingComments&&(t.trailingComments=[]),t.trailingComments.push(e))}s&&(this.state.leadingComments=[]),a.length>0?i.trailingComments=a:void 0!==i.trailingComments&&(i.trailingComments=[])}processComment(t){if(\"Program\"===t.type&&t.body.length>0)return;const e=this.state.commentStack;let s,i,r,a,n;if(this.state.trailingComments.length>0)this.state.trailingComments[0].start>=t.end?(r=this.state.trailingComments,this.state.trailingComments=[]):this.state.trailingComments.length=0;else if(e.length>0){const s=g(e);s.trailingComments&&s.trailingComments[0].start>=t.end&&(r=s.trailingComments,delete s.trailingComments)}for(e.length>0&&g(e).start>=t.start&&(s=e.pop());e.length>0&&g(e).start>=t.start;)i=e.pop();if(!i&&s&&(i=s),s)switch(t.type){case\"ObjectExpression\":this.adjustCommentsAfterTrailingComma(t,t.properties);break;case\"ObjectPattern\":this.adjustCommentsAfterTrailingComma(t,t.properties,!0);break;case\"CallExpression\":this.adjustCommentsAfterTrailingComma(t,t.arguments);break;case\"ArrayExpression\":this.adjustCommentsAfterTrailingComma(t,t.elements);break;case\"ArrayPattern\":this.adjustCommentsAfterTrailingComma(t,t.elements,!0)}else this.state.commentPreviousNode&&(\"ImportSpecifier\"===this.state.commentPreviousNode.type&&\"ImportSpecifier\"!==t.type||\"ExportSpecifier\"===this.state.commentPreviousNode.type&&\"ExportSpecifier\"!==t.type)&&this.adjustCommentsAfterTrailingComma(t,[this.state.commentPreviousNode]);if(i){if(i.leadingComments)if(i!==t&&i.leadingComments.length>0&&g(i.leadingComments).end<=t.start)t.leadingComments=i.leadingComments,delete i.leadingComments;else for(a=i.leadingComments.length-2;a>=0;--a)if(i.leadingComments[a].end<=t.start){t.leadingComments=i.leadingComments.splice(0,a+1);break}}else if(this.state.leadingComments.length>0)if(g(this.state.leadingComments).end<=t.start){if(this.state.commentPreviousNode)for(n=0;n<this.state.leadingComments.length;n++)this.state.leadingComments[n].end<this.state.commentPreviousNode.end&&(this.state.leadingComments.splice(n,1),n--);this.state.leadingComments.length>0&&(t.leadingComments=this.state.leadingComments,this.state.leadingComments=[])}else{for(a=0;a<this.state.leadingComments.length&&!(this.state.leadingComments[a].end>t.start);a++);const e=this.state.leadingComments.slice(0,a);e.length&&(t.leadingComments=e),r=this.state.leadingComments.slice(a),0===r.length&&(r=null)}if(this.state.commentPreviousNode=t,r)if(r.length&&r[0].start>=t.start&&g(r).end<=t.end)t.innerComments=r;else{const e=r.findIndex((e=>e.end>=t.end));e>0?(t.innerComments=r.slice(0,e),t.trailingComments=r.slice(e)):t.trailingComments=r}e.push(t)}}{getLocationForPosition(t){let e;return e=t===this.state.start?this.state.startLoc:t===this.state.lastTokStart?this.state.lastTokStartLoc:t===this.state.end?this.state.endLoc:t===this.state.lastTokEnd?this.state.lastTokEndLoc:function(t,e){let s,i=1,r=0;for(d.lastIndex=0;(s=d.exec(t))&&s.index<e;)i++,r=d.lastIndex;return new x(i,e-r)}(this.input,t),e}raise(t,e,...s){return this.raiseWithData(t,void 0,e,...s)}raiseOverwrite(t,e,...s){const i=this.getLocationForPosition(t),r=e.replace(/%(\\d+)/g,((t,e)=>s[e]))+` (${i.line}:${i.column})`;if(this.options.errorRecovery){const e=this.state.errors;for(let s=e.length-1;s>=0;s--){const i=e[s];if(i.pos===t)return Object.assign(i,{message:r});if(i.pos<t)break}}return this._raise({loc:i,pos:t},r)}raiseWithData(t,e,s,...i){const r=this.getLocationForPosition(t),a=s.replace(/%(\\d+)/g,((t,e)=>i[e]))+` (${r.line}:${r.column})`;return this._raise(Object.assign({loc:r,pos:t},e),a)}_raise(t,e){const s=new SyntaxError(e);if(Object.assign(s,t),this.options.errorRecovery)return this.isLookahead||this.state.errors.push(s),s;throw s}}{constructor(t,e){super(),this.isLookahead=void 0,this.tokens=[],this.state=new Et,this.state.init(t),this.input=e,this.length=e.length,this.isLookahead=!1}pushToken(t){this.tokens.length=this.state.tokensLength,this.tokens.push(t),++this.state.tokensLength}next(){this.isLookahead||(this.checkKeywordEscapes(),this.options.tokens&&this.pushToken(new It(this.state))),this.state.lastTokEnd=this.state.end,this.state.lastTokStart=this.state.start,this.state.lastTokEndLoc=this.state.endLoc,this.state.lastTokStartLoc=this.state.startLoc,this.nextToken()}eat(t){return!!this.match(t)&&(this.next(),!0)}match(t){return this.state.type===t}lookahead(){const t=this.state;this.state=t.clone(!0),this.isLookahead=!0,this.next(),this.isLookahead=!1;const e=this.state;return this.state=t,e}nextTokenStart(){return this.nextTokenStartSince(this.state.pos)}nextTokenStartSince(t){f.lastIndex=t;return t+f.exec(this.input)[0].length}lookaheadCharCode(){return this.input.charCodeAt(this.nextTokenStart())}setStrict(t){this.state.strict=t,t&&(this.state.strictErrors.forEach(((t,e)=>this.raise(e,t))),this.state.strictErrors.clear())}curContext(){return this.state.context[this.state.context.length-1]}nextToken(){const t=this.curContext();if((null==t?void 0:t.preserveSpace)||this.skipSpace(),this.state.start=this.state.pos,this.state.startLoc=this.state.curPosition(),this.state.pos>=this.length)return void this.finishToken(l.eof);const e=null==t?void 0:t.override;e?e(this):this.getTokenFromCode(this.input.codePointAt(this.state.pos))}pushComment(t,e,s,i,r,a){const n={type:t?\"CommentBlock\":\"CommentLine\",value:e,start:s,end:i,loc:new P(r,a)};this.options.tokens&&this.pushToken(n),this.state.comments.push(n),this.addComment(n)}skipBlockComment(){const t=this.state.curPosition(),e=this.state.pos,s=this.input.indexOf(\"*/\",this.state.pos+2);if(-1===s)throw this.raise(e,b.UnterminatedComment);let i;for(this.state.pos=s+2,d.lastIndex=e;(i=d.exec(this.input))&&i.index<this.state.pos;)++this.state.curLine,this.state.lineStart=i.index+i[0].length;this.isLookahead||this.pushComment(!0,this.input.slice(e+2,s),e,this.state.pos,t,this.state.curPosition())}skipLineComment(t){const e=this.state.pos,s=this.state.curPosition();let i=this.input.charCodeAt(this.state.pos+=t);if(this.state.pos<this.length)for(;!m(i)&&++this.state.pos<this.length;)i=this.input.charCodeAt(this.state.pos);this.isLookahead||this.pushComment(!1,this.input.slice(e+t,this.state.pos),e,this.state.pos,s,this.state.curPosition())}skipSpace(){t:for(;this.state.pos<this.length;){const t=this.input.charCodeAt(this.state.pos);switch(t){case 32:case 160:case 9:++this.state.pos;break;case 13:10===this.input.charCodeAt(this.state.pos+1)&&++this.state.pos;case 10:case 8232:case 8233:++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;break;case 47:switch(this.input.charCodeAt(this.state.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break t}break;default:if(!y(t))break t;++this.state.pos}}}finishToken(t,e){this.state.end=this.state.pos,this.state.endLoc=this.state.curPosition();const s=this.state.type;this.state.type=t,this.state.value=e,this.isLookahead||this.updateContext(s)}readToken_numberSign(){if(0===this.state.pos&&this.readToken_interpreter())return;const t=this.state.pos+1,e=this.input.charCodeAt(t);if(e>=48&&e<=57)throw this.raise(this.state.pos,b.UnexpectedDigitAfterHash);if(123===e||91===e&&this.hasPlugin(\"recordAndTuple\")){if(this.expectPlugin(\"recordAndTuple\"),\"hash\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,123===e?b.RecordExpressionHashIncorrectStartSyntaxType:b.TupleExpressionHashIncorrectStartSyntaxType);123===e?this.finishToken(l.braceHashL):this.finishToken(l.bracketHashL),this.state.pos+=2}else this.finishOp(l.hash,1)}readToken_dot(){const t=this.input.charCodeAt(this.state.pos+1);t>=48&&t<=57?this.readNumber(!0):46===t&&46===this.input.charCodeAt(this.state.pos+2)?(this.state.pos+=3,this.finishToken(l.ellipsis)):(++this.state.pos,this.finishToken(l.dot))}readToken_slash(){if(this.state.exprAllowed&&!this.state.inType)return++this.state.pos,void this.readRegexp();61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(l.assign,2):this.finishOp(l.slash,1)}readToken_interpreter(){if(0!==this.state.pos||this.length<2)return!1;let t=this.input.charCodeAt(this.state.pos+1);if(33!==t)return!1;const e=this.state.pos;for(this.state.pos+=1;!m(t)&&++this.state.pos<this.length;)t=this.input.charCodeAt(this.state.pos);const s=this.input.slice(e+2,this.state.pos);return this.finishToken(l.interpreterDirective,s),!0}readToken_mult_modulo(t){let e=42===t?l.star:l.modulo,s=1,i=this.input.charCodeAt(this.state.pos+1);const r=this.state.exprAllowed;42===t&&42===i&&(s++,i=this.input.charCodeAt(this.state.pos+2),e=l.exponent),61!==i||r||(s++,e=l.assign),this.finishOp(e,s)}readToken_pipe_amp(t){const e=this.input.charCodeAt(this.state.pos+1);if(e!==t){if(124===t){if(62===e)return void this.finishOp(l.pipeline,2);if(this.hasPlugin(\"recordAndTuple\")&&125===e){if(\"bar\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,b.RecordExpressionBarIncorrectEndSyntaxType);return void this.finishOp(l.braceBarR,2)}if(this.hasPlugin(\"recordAndTuple\")&&93===e){if(\"bar\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,b.TupleExpressionBarIncorrectEndSyntaxType);return void this.finishOp(l.bracketBarR,2)}}61!==e?this.finishOp(124===t?l.bitwiseOR:l.bitwiseAND,1):this.finishOp(l.assign,2)}else 61===this.input.charCodeAt(this.state.pos+2)?this.finishOp(l.assign,3):this.finishOp(124===t?l.logicalOR:l.logicalAND,2)}readToken_caret(){61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(l.assign,2):this.finishOp(l.bitwiseXOR,1)}readToken_plus_min(t){const e=this.input.charCodeAt(this.state.pos+1);if(e===t)return 45!==e||this.inModule||62!==this.input.charCodeAt(this.state.pos+2)||0!==this.state.lastTokEnd&&!this.hasPrecedingLineBreak()?void this.finishOp(l.incDec,2):(this.skipLineComment(3),this.skipSpace(),void this.nextToken());61===e?this.finishOp(l.assign,2):this.finishOp(l.plusMin,1)}readToken_lt_gt(t){const e=this.input.charCodeAt(this.state.pos+1);let s=1;return e===t?(s=62===t&&62===this.input.charCodeAt(this.state.pos+2)?3:2,61===this.input.charCodeAt(this.state.pos+s)?void this.finishOp(l.assign,s+1):void this.finishOp(l.bitShift,s)):33!==e||60!==t||this.inModule||45!==this.input.charCodeAt(this.state.pos+2)||45!==this.input.charCodeAt(this.state.pos+3)?(61===e&&(s=2),void this.finishOp(l.relational,s)):(this.skipLineComment(4),this.skipSpace(),void this.nextToken())}readToken_eq_excl(t){const e=this.input.charCodeAt(this.state.pos+1);if(61!==e)return 61===t&&62===e?(this.state.pos+=2,void this.finishToken(l.arrow)):void this.finishOp(61===t?l.eq:l.bang,1);this.finishOp(l.equality,61===this.input.charCodeAt(this.state.pos+2)?3:2)}readToken_question(){const t=this.input.charCodeAt(this.state.pos+1),e=this.input.charCodeAt(this.state.pos+2);63===t?61===e?this.finishOp(l.assign,3):this.finishOp(l.nullishCoalescing,2):46!==t||e>=48&&e<=57?(++this.state.pos,this.finishToken(l.question)):(this.state.pos+=2,this.finishToken(l.questionDot))}getTokenFromCode(t){switch(t){case 46:return void this.readToken_dot();case 40:return++this.state.pos,void this.finishToken(l.parenL);case 41:return++this.state.pos,void this.finishToken(l.parenR);case 59:return++this.state.pos,void this.finishToken(l.semi);case 44:return++this.state.pos,void this.finishToken(l.comma);case 91:if(this.hasPlugin(\"recordAndTuple\")&&124===this.input.charCodeAt(this.state.pos+1)){if(\"bar\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,b.TupleExpressionBarIncorrectStartSyntaxType);this.finishToken(l.bracketBarL),this.state.pos+=2}else++this.state.pos,this.finishToken(l.bracketL);return;case 93:return++this.state.pos,void this.finishToken(l.bracketR);case 123:if(this.hasPlugin(\"recordAndTuple\")&&124===this.input.charCodeAt(this.state.pos+1)){if(\"bar\"!==this.getPluginOption(\"recordAndTuple\",\"syntaxType\"))throw this.raise(this.state.pos,b.RecordExpressionBarIncorrectStartSyntaxType);this.finishToken(l.braceBarL),this.state.pos+=2}else++this.state.pos,this.finishToken(l.braceL);return;case 125:return++this.state.pos,void this.finishToken(l.braceR);case 58:return void(this.hasPlugin(\"functionBind\")&&58===this.input.charCodeAt(this.state.pos+1)?this.finishOp(l.doubleColon,2):(++this.state.pos,this.finishToken(l.colon)));case 63:return void this.readToken_question();case 96:return++this.state.pos,void this.finishToken(l.backQuote);case 48:{const t=this.input.charCodeAt(this.state.pos+1);if(120===t||88===t)return void this.readRadixNumber(16);if(111===t||79===t)return void this.readRadixNumber(8);if(98===t||66===t)return void this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return void this.readNumber(!1);case 34:case 39:return void this.readString(t);case 47:return void this.readToken_slash();case 37:case 42:return void this.readToken_mult_modulo(t);case 124:case 38:return void this.readToken_pipe_amp(t);case 94:return void this.readToken_caret();case 43:case 45:return void this.readToken_plus_min(t);case 60:case 62:return void this.readToken_lt_gt(t);case 61:case 33:return void this.readToken_eq_excl(t);case 126:return void this.finishOp(l.tilde,1);case 64:return++this.state.pos,void this.finishToken(l.at);case 35:return void this.readToken_numberSign();case 92:return void this.readWord();default:if(v(t))return void this.readWord()}throw this.raise(this.state.pos,b.InvalidOrUnexpectedToken,String.fromCodePoint(t))}finishOp(t,e){const s=this.input.slice(this.state.pos,this.state.pos+e);this.state.pos+=e,this.finishToken(t,s)}readRegexp(){const t=this.state.pos;let e,s;for(;;){if(this.state.pos>=this.length)throw this.raise(t,b.UnterminatedRegExp);const i=this.input.charAt(this.state.pos);if(u.test(i))throw this.raise(t,b.UnterminatedRegExp);if(e)e=!1;else{if(\"[\"===i)s=!0;else if(\"]\"===i&&s)s=!1;else if(\"/\"===i&&!s)break;e=\"\\\\\"===i}++this.state.pos}const i=this.input.slice(t,this.state.pos);++this.state.pos;let r=\"\";for(;this.state.pos<this.length;){const t=this.input[this.state.pos],e=this.input.codePointAt(this.state.pos);if(Ct.has(t))r.indexOf(t)>-1&&this.raise(this.state.pos+1,b.DuplicateRegExpFlags);else{if(!L(e)&&92!==e)break;this.raise(this.state.pos+1,b.MalformedRegExpFlags)}++this.state.pos,r+=t}this.finishToken(l.regexp,{pattern:i,flags:r})}readInt(t,e,s,i=!0){const r=this.state.pos,a=16===t?Nt.hex:Nt.decBinOct,n=16===t?kt.hex:10===t?kt.dec:8===t?kt.oct:kt.bin;let o=!1,h=0;for(let p=0,c=null==e?1/0:e;p<c;++p){const e=this.input.charCodeAt(this.state.pos);let r;if(95!==e){if(r=e>=97?e-97+10:e>=65?e-65+10:St(e)?e-48:1/0,r>=t)if(this.options.errorRecovery&&r<=9)r=0,this.raise(this.state.start+p+2,b.InvalidDigit,t);else{if(!s)break;r=0,o=!0}++this.state.pos,h=h*t+r}else{const t=this.input.charCodeAt(this.state.pos-1),e=this.input.charCodeAt(this.state.pos+1);(-1===n.indexOf(e)||a.indexOf(t)>-1||a.indexOf(e)>-1||Number.isNaN(e))&&this.raise(this.state.pos,b.UnexpectedNumericSeparator),i||this.raise(this.state.pos,b.NumericSeparatorInEscapeSequence),++this.state.pos}}return this.state.pos===r||null!=e&&this.state.pos-r!==e||o?null:h}readRadixNumber(t){const e=this.state.pos;let s=!1;this.state.pos+=2;const i=this.readInt(t);null==i&&this.raise(this.state.start+2,b.InvalidDigit,t);const r=this.input.charCodeAt(this.state.pos);if(110===r)++this.state.pos,s=!0;else if(109===r)throw this.raise(e,b.InvalidDecimal);if(v(this.input.codePointAt(this.state.pos)))throw this.raise(this.state.pos,b.NumberIdentifier);if(s){const t=this.input.slice(e,this.state.pos).replace(/[_n]/g,\"\");this.finishToken(l.bigint,t)}else this.finishToken(l.num,i)}readNumber(t){const e=this.state.pos;let s=!1,i=!1,r=!1,a=!1,n=!1;t||null!==this.readInt(10)||this.raise(e,b.InvalidNumber);const o=this.state.pos-e>=2&&48===this.input.charCodeAt(e);if(o){const t=this.input.slice(e,this.state.pos);if(this.recordStrictModeErrors(e,b.StrictOctalLiteral),!this.state.strict){const s=t.indexOf(\"_\");s>0&&this.raise(s+e,b.ZeroDigitNumericSeparator)}n=o&&!/[89]/.test(t)}let h=this.input.charCodeAt(this.state.pos);if(46!==h||n||(++this.state.pos,this.readInt(10),s=!0,h=this.input.charCodeAt(this.state.pos)),69!==h&&101!==h||n||(h=this.input.charCodeAt(++this.state.pos),43!==h&&45!==h||++this.state.pos,null===this.readInt(10)&&this.raise(e,b.InvalidOrMissingExponent),s=!0,a=!0,h=this.input.charCodeAt(this.state.pos)),110===h&&((s||o)&&this.raise(e,b.InvalidBigIntLiteral),++this.state.pos,i=!0),109===h&&(this.expectPlugin(\"decimal\",this.state.pos),(a||o)&&this.raise(e,b.InvalidDecimal),++this.state.pos,r=!0),v(this.input.codePointAt(this.state.pos)))throw this.raise(this.state.pos,b.NumberIdentifier);const p=this.input.slice(e,this.state.pos).replace(/[_mn]/g,\"\");if(i)return void this.finishToken(l.bigint,p);if(r)return void this.finishToken(l.decimal,p);const c=n?parseInt(p,8):parseFloat(p);this.finishToken(l.num,c)}readCodePoint(t){let e;if(123===this.input.charCodeAt(this.state.pos)){const s=++this.state.pos;if(e=this.readHexChar(this.input.indexOf(\"}\",this.state.pos)-this.state.pos,!0,t),++this.state.pos,null!==e&&e>1114111){if(!t)return null;this.raise(s,b.InvalidCodePoint)}}else e=this.readHexChar(4,!1,t);return e}readString(t){let e=\"\",s=++this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,b.UnterminatedString);const i=this.input.charCodeAt(this.state.pos);if(i===t)break;if(92===i)e+=this.input.slice(s,this.state.pos),e+=this.readEscapedChar(!1),s=this.state.pos;else if(8232===i||8233===i)++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;else{if(m(i))throw this.raise(this.state.start,b.UnterminatedString);++this.state.pos}}e+=this.input.slice(s,this.state.pos++),this.finishToken(l.string,e)}readTmplToken(){let t=\"\",e=this.state.pos,s=!1;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,b.UnterminatedTemplate);const i=this.input.charCodeAt(this.state.pos);if(96===i||36===i&&123===this.input.charCodeAt(this.state.pos+1))return this.state.pos===this.state.start&&this.match(l.template)?36===i?(this.state.pos+=2,void this.finishToken(l.dollarBraceL)):(++this.state.pos,void this.finishToken(l.backQuote)):(t+=this.input.slice(e,this.state.pos),void this.finishToken(l.template,s?null:t));if(92===i){t+=this.input.slice(e,this.state.pos);const i=this.readEscapedChar(!0);null===i?s=!0:t+=i,e=this.state.pos}else if(m(i)){switch(t+=this.input.slice(e,this.state.pos),++this.state.pos,i){case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:t+=\"\\n\";break;default:t+=String.fromCharCode(i)}++this.state.curLine,this.state.lineStart=this.state.pos,e=this.state.pos}else++this.state.pos}}recordStrictModeErrors(t,e){this.state.strict&&!this.state.strictErrors.has(t)?this.raise(t,e):this.state.strictErrors.set(t,e)}readEscapedChar(t){const e=!t,s=this.input.charCodeAt(++this.state.pos);switch(++this.state.pos,s){case 110:return\"\\n\";case 114:return\"\\r\";case 120:{const t=this.readHexChar(2,!1,e);return null===t?null:String.fromCharCode(t)}case 117:{const t=this.readCodePoint(e);return null===t?null:String.fromCodePoint(t)}case 116:return\"\\t\";case 98:return\"\\b\";case 118:return\"\\v\";case 102:return\"\\f\";case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:this.state.lineStart=this.state.pos,++this.state.curLine;case 8232:case 8233:return\"\";case 56:case 57:if(t)return null;this.recordStrictModeErrors(this.state.pos-1,b.StrictNumericEscape);default:if(s>=48&&s<=55){const e=this.state.pos-1;let s=this.input.substr(this.state.pos-1,3).match(/^[0-7]+/)[0],i=parseInt(s,8);i>255&&(s=s.slice(0,-1),i=parseInt(s,8)),this.state.pos+=s.length-1;const r=this.input.charCodeAt(this.state.pos);if(\"0\"!==s||56===r||57===r){if(t)return null;this.recordStrictModeErrors(e,b.StrictNumericEscape)}return String.fromCharCode(i)}return String.fromCharCode(s)}}readHexChar(t,e,s){const i=this.state.pos,r=this.readInt(16,t,e,!1);return null===r&&(s?this.raise(i,b.InvalidEscapeSequence):this.state.pos=i-1),r}readWord1(){let t=\"\";this.state.containsEsc=!1;const e=this.state.pos;let s=this.state.pos;for(;this.state.pos<this.length;){const i=this.input.codePointAt(this.state.pos);if(L(i))this.state.pos+=i<=65535?1:2;else if(this.state.isIterator&&64===i)++this.state.pos;else{if(92!==i)break;{this.state.containsEsc=!0,t+=this.input.slice(s,this.state.pos);const i=this.state.pos,r=this.state.pos===e?v:L;if(117!==this.input.charCodeAt(++this.state.pos)){this.raise(this.state.pos,b.MissingUnicodeEscape);continue}++this.state.pos;const a=this.readCodePoint(!0);null!==a&&(r(a)||this.raise(i,b.EscapedCharNotAnIdentifier),t+=String.fromCodePoint(a)),s=this.state.pos}}}return t+this.input.slice(s,this.state.pos)}isIterator(t){return\"@@iterator\"===t||\"@@asyncIterator\"===t}readWord(){const t=this.readWord1(),e=h.get(t)||l.name;!this.state.isIterator||this.isIterator(t)&&this.state.inType||this.raise(this.state.pos,b.InvalidIdentifier,t),this.finishToken(e,t)}checkKeywordEscapes(){const t=this.state.type.keyword;t&&this.state.containsEsc&&this.raise(this.state.start,b.InvalidEscapedReservedWord,t)}braceIsBlock(t){const e=this.curContext();return e===A.functionExpression||e===A.functionStatement||(t!==l.colon||e!==A.braceStatement&&e!==A.braceExpression?t===l._return||t===l.name&&this.state.exprAllowed?this.hasPrecedingLineBreak():t===l._else||t===l.semi||t===l.eof||t===l.parenR||t===l.arrow||(t===l.braceL?e===A.braceStatement:t!==l._var&&t!==l._const&&t!==l.name&&(t===l.relational||!this.state.exprAllowed)):!e.isExpr)}updateContext(t){const e=this.state.type;let s;!e.keyword||t!==l.dot&&t!==l.questionDot?(s=e.updateContext)?s.call(this,t):this.state.exprAllowed=e.beforeExpr:this.state.exprAllowed=!1}}{addExtra(t,e,s){if(!t)return;(t.extra=t.extra||{})[e]=s}isRelational(t){return this.match(l.relational)&&this.state.value===t}expectRelational(t){this.isRelational(t)?this.next():this.unexpected(null,l.relational)}isContextual(t){return this.match(l.name)&&this.state.value===t&&!this.state.containsEsc}isUnparsedContextual(t,e){const s=t+e.length;return this.input.slice(t,s)===e&&(s===this.input.length||!L(this.input.charCodeAt(s)))}isLookaheadContextual(t){const e=this.nextTokenStart();return this.isUnparsedContextual(e,t)}eatContextual(t){return this.isContextual(t)&&this.eat(l.name)}expectContextual(t,e){this.eatContextual(t)||this.unexpected(null,e)}canInsertSemicolon(){return this.match(l.eof)||this.match(l.braceR)||this.hasPrecedingLineBreak()}hasPrecedingLineBreak(){return u.test(this.input.slice(this.state.lastTokEnd,this.state.start))}hasFollowingLineBreak(){return u.test(this.input.slice(this.state.end,this.nextTokenStart()))}isLineTerminator(){return this.eat(l.semi)||this.canInsertSemicolon()}semicolon(t=!0){(t?this.isLineTerminator():this.eat(l.semi))||this.raise(this.state.lastTokEnd,b.MissingSemicolon)}expect(t,e){this.eat(t)||this.unexpected(e,t)}assertNoSpace(t=\"Unexpected space.\"){this.state.start>this.state.lastTokEnd&&this.raise(this.state.lastTokEnd,t)}unexpected(t,e=\"Unexpected token\"){throw\"string\"!==typeof e&&(e=`Unexpected token, expected \"${e.label}\"`),this.raise(null!=t?t:this.state.start,e)}expectPlugin(t,e){if(!this.hasPlugin(t))throw this.raiseWithData(null!=e?e:this.state.start,{missingPlugin:[t]},`This experimental syntax requires enabling the parser plugin: '${t}'`);return!0}expectOnePlugin(t,e){if(!t.some((t=>this.hasPlugin(t))))throw this.raiseWithData(null!=e?e:this.state.start,{missingPlugin:t},`This experimental syntax requires enabling one of the following parser plugin(s): '${t.join(\", \")}'`)}tryParse(t,e=this.state.clone()){const s={node:null};try{const i=t(((t=null)=>{throw s.node=t,s}));if(this.state.errors.length>e.errors.length){const t=this.state;return this.state=e,{node:i,error:t.errors[e.errors.length],thrown:!1,aborted:!1,failState:t}}return{node:i,error:null,thrown:!1,aborted:!1,failState:null}}catch(i){const t=this.state;if(this.state=e,i instanceof SyntaxError)return{node:null,error:i,thrown:!0,aborted:!1,failState:t};if(i===s)return{node:s.node,error:null,thrown:!1,aborted:!0,failState:t};throw i}}checkExpressionErrors(t,e){if(!t)return!1;const{shorthandAssign:s,doubleProto:i}=t;if(!e)return s>=0||i>=0;s>=0&&this.unexpected(s),i>=0&&this.raise(i,b.DuplicateProto)}isLiteralPropertyName(){return this.match(l.name)||!!this.state.type.keyword||this.match(l.string)||this.match(l.num)||this.match(l.bigint)||this.match(l.decimal)}isPrivateName(t){return\"PrivateName\"===t.type}getPrivateNameSV(t){return t.id.name}hasPropertyAsPrivateName(t){return(\"MemberExpression\"===t.type||\"OptionalMemberExpression\"===t.type)&&this.isPrivateName(t.property)}isOptionalChain(t){return\"OptionalMemberExpression\"===t.type||\"OptionalCallExpression\"===t.type}isObjectProperty(t){return\"ObjectProperty\"===t.type}isObjectMethod(t){return\"ObjectMethod\"===t.type}}{startNode(){return new Lt(this,this.state.start,this.state.startLoc)}startNodeAt(t,e){return new Lt(this,t,e)}startNodeAtNode(t){return this.startNodeAt(t.start,t.loc.start)}finishNode(t,e){return this.finishNodeAt(t,e,this.state.lastTokEnd,this.state.lastTokEndLoc)}finishNodeAt(t,e,s,i){return t.type=e,t.end=s,t.loc.end=i,this.options.ranges&&(t.range[1]=s),this.processComment(t),t}resetStartLocation(t,e,s){t.start=e,t.loc.start=s,this.options.ranges&&(t.range[0]=e)}resetEndLocation(t,e=this.state.lastTokEnd,s=this.state.lastTokEndLoc){t.end=e,t.loc.end=s,this.options.ranges&&(t.range[1]=e)}resetStartLocationFromNode(t,e){this.resetStartLocation(t,e.start,e.loc.start)}}{toAssignable(t,e=!1){var s,i;let r;switch((\"ParenthesizedExpression\"===t.type||(null==(s=t.extra)?void 0:s.parenthesized))&&(r=Dt(t),e?\"Identifier\"===r.type?this.expressionScope.recordParenthesizedIdentifierError(t.start,b.InvalidParenthesizedAssignment):\"MemberExpression\"!==r.type&&this.raise(t.start,b.InvalidParenthesizedAssignment):this.raise(t.start,b.InvalidParenthesizedAssignment)),t.type){case\"Identifier\":case\"ObjectPattern\":case\"ArrayPattern\":case\"AssignmentPattern\":break;case\"ObjectExpression\":t.type=\"ObjectPattern\";for(let s=0,i=t.properties.length,r=i-1;s<i;s++){var a;const i=t.properties[s],n=s===r;this.toAssignableObjectExpressionProp(i,n,e),n&&\"RestElement\"===i.type&&(null==(a=t.extra)?void 0:a.trailingComma)&&this.raiseRestNotLast(t.extra.trailingComma)}break;case\"ObjectProperty\":this.toAssignable(t.value,e);break;case\"SpreadElement\":{this.checkToRestConversion(t),t.type=\"RestElement\";const s=t.argument;this.toAssignable(s,e);break}case\"ArrayExpression\":t.type=\"ArrayPattern\",this.toAssignableList(t.elements,null==(i=t.extra)?void 0:i.trailingComma,e);break;case\"AssignmentExpression\":\"=\"!==t.operator&&this.raise(t.left.end,b.MissingEqInAssignment),t.type=\"AssignmentPattern\",delete t.operator,this.toAssignable(t.left,e);break;case\"ParenthesizedExpression\":this.toAssignable(r,e)}return t}toAssignableObjectExpressionProp(t,e,s){if(\"ObjectMethod\"===t.type){const e=\"get\"===t.kind||\"set\"===t.kind?b.PatternHasAccessor:b.PatternHasMethod;this.raise(t.key.start,e)}else\"SpreadElement\"!==t.type||e?this.toAssignable(t,s):this.raiseRestNotLast(t.start)}toAssignableList(t,e,s){let i=t.length;if(i){const r=t[i-1];if(\"RestElement\"===(null==r?void 0:r.type))--i;else if(\"SpreadElement\"===(null==r?void 0:r.type)){r.type=\"RestElement\";let t=r.argument;this.toAssignable(t,s),t=Dt(t),\"Identifier\"!==t.type&&\"MemberExpression\"!==t.type&&\"ArrayPattern\"!==t.type&&\"ObjectPattern\"!==t.type&&this.unexpected(t.start),e&&this.raiseTrailingCommaAfterRest(e),--i}}for(let r=0;r<i;r++){const e=t[r];e&&(this.toAssignable(e,s),\"RestElement\"===e.type&&this.raiseRestNotLast(e.start))}return t}toReferencedList(t,e){return t}toReferencedListDeep(t,e){this.toReferencedList(t,e);for(let s=0;s<t.length;s++){const e=t[s];\"ArrayExpression\"===(null==e?void 0:e.type)&&this.toReferencedListDeep(e.elements)}}parseSpread(t,e){const s=this.startNode();return this.next(),s.argument=this.parseMaybeAssignAllowIn(t,void 0,e),this.finishNode(s,\"SpreadElement\")}parseRestBinding(){const t=this.startNode();return this.next(),t.argument=this.parseBindingAtom(),this.finishNode(t,\"RestElement\")}parseBindingAtom(){switch(this.state.type){case l.bracketL:{const t=this.startNode();return this.next(),t.elements=this.parseBindingList(l.bracketR,93,!0),this.finishNode(t,\"ArrayPattern\")}case l.braceL:return this.parseObjectLike(l.braceR,!0)}return this.parseIdentifier()}parseBindingList(t,e,s,i){const r=[];let a=!0;for(;!this.eat(t);)if(a?a=!1:this.expect(l.comma),s&&this.match(l.comma))r.push(null);else{if(this.eat(t))break;if(this.match(l.ellipsis)){r.push(this.parseAssignableListItemTypes(this.parseRestBinding())),this.checkCommaAfterRest(e),this.expect(t);break}{const t=[];for(this.match(l.at)&&this.hasPlugin(\"decorators\")&&this.raise(this.state.start,b.UnsupportedParameterDecorator);this.match(l.at);)t.push(this.parseDecorator());r.push(this.parseAssignableListItem(i,t))}}return r}parseAssignableListItem(t,e){const s=this.parseMaybeDefault();this.parseAssignableListItemTypes(s);const i=this.parseMaybeDefault(s.start,s.loc.start,s);return e.length&&(s.decorators=e),i}parseAssignableListItemTypes(t){return t}parseMaybeDefault(t,e,s){var i,r,a;if(e=null!=(i=e)?i:this.state.startLoc,t=null!=(r=t)?r:this.state.start,s=null!=(a=s)?a:this.parseBindingAtom(),!this.eat(l.eq))return s;const n=this.startNodeAt(t,e);return n.left=s,n.right=this.parseMaybeAssignAllowIn(),this.finishNode(n,\"AssignmentPattern\")}checkLVal(t,e,s=64,i,r,a=!1){switch(t.type){case\"Identifier\":{const{name:e}=t;this.state.strict&&(a?U(e,this.inModule):j(e))&&this.raise(t.start,64===s?b.StrictEvalArguments:b.StrictEvalArgumentsBinding,e),i&&(i.has(e)?this.raise(t.start,b.ParamDupe):i.add(e)),r&&\"let\"===e&&this.raise(t.start,b.LetInLexicalBinding),64&s||this.scope.declareName(e,s,t.start);break}case\"MemberExpression\":64!==s&&this.raise(t.start,b.InvalidPropertyBindingPattern);break;case\"ObjectPattern\":for(let e=0,a=t.properties;e<a.length;e++){let t=a[e];if(this.isObjectProperty(t))t=t.value;else if(this.isObjectMethod(t))continue;this.checkLVal(t,\"object destructuring pattern\",s,i,r)}break;case\"ArrayPattern\":for(let e=0,a=t.elements;e<a.length;e++){const t=a[e];t&&this.checkLVal(t,\"array destructuring pattern\",s,i,r)}break;case\"AssignmentPattern\":this.checkLVal(t.left,\"assignment pattern\",s,i);break;case\"RestElement\":this.checkLVal(t.argument,\"rest element\",s,i);break;case\"ParenthesizedExpression\":this.checkLVal(t.expression,\"parenthesized expression\",s,i);break;default:this.raise(t.start,64===s?b.InvalidLhs:b.InvalidLhsBinding,e)}}checkToRestConversion(t){\"Identifier\"!==t.argument.type&&\"MemberExpression\"!==t.argument.type&&this.raise(t.argument.start,b.InvalidRestAssignmentPattern)}checkCommaAfterRest(t){this.match(l.comma)&&(this.lookaheadCharCode()===t?this.raiseTrailingCommaAfterRest(this.state.start):this.raiseRestNotLast(this.state.start))}raiseRestNotLast(t){throw this.raise(t,b.ElementAfterRest)}raiseTrailingCommaAfterRest(t){this.raise(t,b.RestTrailingComma)}}{checkProto(t,e,s,i){if(\"SpreadElement\"===t.type||this.isObjectMethod(t)||t.computed||t.shorthand)return;const r=t.key;if(\"__proto__\"===(\"Identifier\"===r.type?r.name:r.value)){if(e)return void this.raise(r.start,b.RecordNoProto);s.used&&(i?-1===i.doubleProto&&(i.doubleProto=r.start):this.raise(r.start,b.DuplicateProto)),s.used=!0}}shouldExitDescending(t,e){return\"ArrowFunctionExpression\"===t.type&&t.start===e}getExpression(){let t=0;this.hasPlugin(\"topLevelAwait\")&&this.inModule&&(t|=2),this.scope.enter(1),this.prodParam.enter(t),this.nextToken();const e=this.parseExpression();return this.match(l.eof)||this.unexpected(),e.comments=this.state.comments,e.errors=this.state.errors,e}parseExpression(t,e){return t?this.disallowInAnd((()=>this.parseExpressionBase(e))):this.allowInAnd((()=>this.parseExpressionBase(e)))}parseExpressionBase(t){const e=this.state.start,s=this.state.startLoc,i=this.parseMaybeAssign(t);if(this.match(l.comma)){const r=this.startNodeAt(e,s);for(r.expressions=[i];this.eat(l.comma);)r.expressions.push(this.parseMaybeAssign(t));return this.toReferencedList(r.expressions),this.finishNode(r,\"SequenceExpression\")}return i}parseMaybeAssignDisallowIn(t,e,s){return this.disallowInAnd((()=>this.parseMaybeAssign(t,e,s)))}parseMaybeAssignAllowIn(t,e,s){return this.allowInAnd((()=>this.parseMaybeAssign(t,e,s)))}parseMaybeAssign(t,e,s){const i=this.state.start,r=this.state.startLoc;if(this.isContextual(\"yield\")&&this.prodParam.hasYield){this.state.exprAllowed=!0;let t=this.parseYield();return e&&(t=e.call(this,t,i,r)),t}let a;t?a=!1:(t=new vt,a=!0),(this.match(l.parenL)||this.match(l.name))&&(this.state.potentialArrowAt=this.state.start);let n=this.parseMaybeConditional(t,s);if(e&&(n=e.call(this,n,i,r)),this.state.type.isAssign){const e=this.startNodeAt(i,r),s=this.state.value;return e.operator=s,this.match(l.eq)?(e.left=this.toAssignable(n,!0),t.doubleProto=-1):e.left=n,t.shorthandAssign>=e.left.start&&(t.shorthandAssign=-1),this.checkLVal(n,\"assignment expression\"),this.next(),e.right=this.parseMaybeAssign(),this.finishNode(e,\"AssignmentExpression\")}return a&&this.checkExpressionErrors(t,!0),n}parseMaybeConditional(t,e){const s=this.state.start,i=this.state.startLoc,r=this.state.potentialArrowAt,a=this.parseExprOps(t);return this.shouldExitDescending(a,r)?a:this.parseConditional(a,s,i,e)}parseConditional(t,e,s,i){if(this.eat(l.question)){const i=this.startNodeAt(e,s);return i.test=t,i.consequent=this.parseMaybeAssignAllowIn(),this.expect(l.colon),i.alternate=this.parseMaybeAssign(),this.finishNode(i,\"ConditionalExpression\")}return t}parseExprOps(t){const e=this.state.start,s=this.state.startLoc,i=this.state.potentialArrowAt,r=this.parseMaybeUnary(t);return this.shouldExitDescending(r,i)?r:this.parseExprOp(r,e,s,-1)}parseExprOp(t,e,s,i){let r=this.state.type.binop;if(null!=r&&(this.prodParam.hasIn||!this.match(l._in))&&r>i){const a=this.state.type;if(a===l.pipeline){if(this.expectPlugin(\"pipelineOperator\"),this.state.inFSharpPipelineDirectBody)return t;this.state.inPipeline=!0,this.checkPipelineAtInfixOperator(t,e)}const n=this.startNodeAt(e,s);n.left=t,n.operator=this.state.value,a!==l.exponent||\"UnaryExpression\"!==t.type||!this.options.createParenthesizedExpressions&&t.extra&&t.extra.parenthesized||this.raise(t.argument.start,b.UnexpectedTokenUnaryExponentiation);const o=a===l.logicalOR||a===l.logicalAND,h=a===l.nullishCoalescing;if(h&&(r=l.logicalAND.binop),this.next(),a===l.pipeline&&\"minimal\"===this.getPluginOption(\"pipelineOperator\",\"proposal\")&&this.match(l.name)&&\"await\"===this.state.value&&this.prodParam.hasAwait)throw this.raise(this.state.start,b.UnexpectedAwaitAfterPipelineBody);n.right=this.parseExprOpRightExpr(a,r),this.finishNode(n,o||h?\"LogicalExpression\":\"BinaryExpression\");const p=this.state.type;if(h&&(p===l.logicalOR||p===l.logicalAND)||o&&p===l.nullishCoalescing)throw this.raise(this.state.start,b.MixingCoalesceWithLogical);return this.parseExprOp(n,e,s,i)}return t}parseExprOpRightExpr(t,e){const s=this.state.start,i=this.state.startLoc;switch(t){case l.pipeline:switch(this.getPluginOption(\"pipelineOperator\",\"proposal\")){case\"smart\":return this.withTopicPermittingContext((()=>this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(t,e),s,i)));case\"fsharp\":return this.withSoloAwaitPermittingContext((()=>this.parseFSharpPipelineBody(e)))}default:return this.parseExprOpBaseRightExpr(t,e)}}parseExprOpBaseRightExpr(t,e){const s=this.state.start,i=this.state.startLoc;return this.parseExprOp(this.parseMaybeUnary(),s,i,t.rightAssociative?e-1:e)}parseMaybeUnary(t){const e=this.state.start,s=this.state.startLoc,i=this.isContextual(\"await\");if(i&&this.isAwaitAllowed())return this.next(),this.parseAwait(e,s);const r=this.match(l.incDec),a=this.startNode();if(this.state.type.prefix){a.operator=this.state.value,a.prefix=!0,this.match(l._throw)&&this.expectPlugin(\"throwExpressions\");const e=this.match(l._delete);if(this.next(),a.argument=this.parseMaybeUnary(),this.checkExpressionErrors(t,!0),this.state.strict&&e){const t=a.argument;\"Identifier\"===t.type?this.raise(a.start,b.StrictDelete):this.hasPropertyAsPrivateName(t)&&this.raise(a.start,b.DeletePrivateField)}if(!r)return this.finishNode(a,\"UnaryExpression\")}const n=this.parseUpdate(a,r,t);if(i){if((this.hasPlugin(\"v8intrinsic\")?this.state.type.startsExpr:this.state.type.startsExpr&&!this.match(l.modulo))&&!this.isAmbiguousAwait())return this.raiseOverwrite(e,this.hasPlugin(\"topLevelAwait\")?b.AwaitNotInAsyncContext:b.AwaitNotInAsyncFunction),this.parseAwait(e,s)}return n}parseUpdate(t,e,s){if(e)return this.checkLVal(t.argument,\"prefix operation\"),this.finishNode(t,\"UpdateExpression\");const i=this.state.start,r=this.state.startLoc;let a=this.parseExprSubscripts(s);if(this.checkExpressionErrors(s,!1))return a;for(;this.state.type.postfix&&!this.canInsertSemicolon();){const t=this.startNodeAt(i,r);t.operator=this.state.value,t.prefix=!1,t.argument=a,this.checkLVal(a,\"postfix operation\"),this.next(),a=this.finishNode(t,\"UpdateExpression\")}return a}parseExprSubscripts(t){const e=this.state.start,s=this.state.startLoc,i=this.state.potentialArrowAt,r=this.parseExprAtom(t);return this.shouldExitDescending(r,i)?r:this.parseSubscripts(r,e,s)}parseSubscripts(t,e,s,i){const r={optionalChainMember:!1,maybeAsyncArrow:this.atPossibleAsyncArrow(t),stop:!1};do{t=this.parseSubscript(t,e,s,i,r),r.maybeAsyncArrow=!1}while(!r.stop);return t}parseSubscript(t,e,s,i,r){if(!i&&this.eat(l.doubleColon))return this.parseBind(t,e,s,i,r);if(this.match(l.backQuote))return this.parseTaggedTemplateExpression(t,e,s,r);let a=!1;if(this.match(l.questionDot)){if(i&&40===this.lookaheadCharCode())return r.stop=!0,t;r.optionalChainMember=a=!0,this.next()}return!i&&this.match(l.parenL)?this.parseCoverCallAndAsyncArrowHead(t,e,s,r,a):a||this.match(l.bracketL)||this.eat(l.dot)?this.parseMember(t,e,s,r,a):(r.stop=!0,t)}parseMember(t,e,s,i,r){const a=this.startNodeAt(e,s),n=this.eat(l.bracketL);a.object=t,a.computed=n;const o=n?this.parseExpression():this.parseMaybePrivateName(!0);return this.isPrivateName(o)&&(\"Super\"===a.object.type&&this.raise(e,b.SuperPrivateField),this.classScope.usePrivateName(this.getPrivateNameSV(o),o.start)),a.property=o,n&&this.expect(l.bracketR),i.optionalChainMember?(a.optional=r,this.finishNode(a,\"OptionalMemberExpression\")):this.finishNode(a,\"MemberExpression\")}parseBind(t,e,s,i,r){const a=this.startNodeAt(e,s);return a.object=t,a.callee=this.parseNoCallExpr(),r.stop=!0,this.parseSubscripts(this.finishNode(a,\"BindExpression\"),e,s,i)}parseCoverCallAndAsyncArrowHead(t,e,s,i,r){const a=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=!0,this.next();let n=this.startNodeAt(e,s);return n.callee=t,i.maybeAsyncArrow&&this.expressionScope.enter(new Rt(2)),i.optionalChainMember&&(n.optional=r),n.arguments=r?this.parseCallExpressionArguments(l.parenR,!1):this.parseCallExpressionArguments(l.parenR,i.maybeAsyncArrow,\"Import\"===t.type,\"Super\"!==t.type,n),this.finishCallExpression(n,i.optionalChainMember),i.maybeAsyncArrow&&this.shouldParseAsyncArrow()&&!r?(i.stop=!0,this.expressionScope.validateAsPattern(),this.expressionScope.exit(),n=this.parseAsyncArrowFromCallExpression(this.startNodeAt(e,s),n)):(i.maybeAsyncArrow&&this.expressionScope.exit(),this.toReferencedArguments(n)),this.state.maybeInArrowParameters=a,n}toReferencedArguments(t,e){this.toReferencedListDeep(t.arguments,e)}parseTaggedTemplateExpression(t,e,s,i){const r=this.startNodeAt(e,s);return r.tag=t,r.quasi=this.parseTemplate(!0),i.optionalChainMember&&this.raise(e,b.OptionalChainingNoTemplate),this.finishNode(r,\"TaggedTemplateExpression\")}atPossibleAsyncArrow(t){return\"Identifier\"===t.type&&\"async\"===t.name&&this.state.lastTokEnd===t.end&&!this.canInsertSemicolon()&&t.end-t.start===5&&t.start===this.state.potentialArrowAt}finishCallExpression(t,e){if(\"Import\"===t.callee.type)if(2===t.arguments.length&&(this.hasPlugin(\"moduleAttributes\")||this.expectPlugin(\"importAssertions\")),0===t.arguments.length||t.arguments.length>2)this.raise(t.start,b.ImportCallArity,this.hasPlugin(\"importAssertions\")||this.hasPlugin(\"moduleAttributes\")?\"one or two arguments\":\"one argument\");else for(let s=0,i=t.arguments;s<i.length;s++){const t=i[s];\"SpreadElement\"===t.type&&this.raise(t.start,b.ImportCallSpreadArgument)}return this.finishNode(t,e?\"OptionalCallExpression\":\"CallExpression\")}parseCallExpressionArguments(t,e,s,i,r){const a=[];let n=!0;const o=this.state.inFSharpPipelineDirectBody;for(this.state.inFSharpPipelineDirectBody=!1;!this.eat(t);){if(n)n=!1;else if(this.expect(l.comma),this.match(t)){!s||this.hasPlugin(\"importAssertions\")||this.hasPlugin(\"moduleAttributes\")||this.raise(this.state.lastTokStart,b.ImportCallArgumentTrailingComma),r&&this.addExtra(r,\"trailingComma\",this.state.lastTokStart),this.next();break}a.push(this.parseExprListItem(!1,e?new vt:void 0,e?{start:0}:void 0,i))}return this.state.inFSharpPipelineDirectBody=o,a}shouldParseAsyncArrow(){return this.match(l.arrow)&&!this.canInsertSemicolon()}parseAsyncArrowFromCallExpression(t,e){var s;return this.expect(l.arrow),this.parseArrowExpression(t,e.arguments,!0,null==(s=e.extra)?void 0:s.trailingComma),t}parseNoCallExpr(){const t=this.state.start,e=this.state.startLoc;return this.parseSubscripts(this.parseExprAtom(),t,e,!0)}parseExprAtom(t){this.state.type===l.slash&&this.readRegexp();const e=this.state.potentialArrowAt===this.state.start;let s;switch(this.state.type){case l._super:return this.parseSuper();case l._import:return s=this.startNode(),this.next(),this.match(l.dot)?this.parseImportMetaProperty(s):(this.match(l.parenL)||this.raise(this.state.lastTokStart,b.UnsupportedImport),this.finishNode(s,\"Import\"));case l._this:return s=this.startNode(),this.next(),this.finishNode(s,\"ThisExpression\");case l.name:{const t=this.state.containsEsc,s=this.parseIdentifier();if(!t&&\"async\"===s.name&&!this.canInsertSemicolon()){if(this.match(l._function)){const t=this.state.context.length-1;if(this.state.context[t]!==A.functionStatement)throw new Error(\"Internal error\");return this.state.context[t]=A.functionExpression,this.next(),this.parseFunction(this.startNodeAtNode(s),void 0,!0)}if(this.match(l.name))return this.parseAsyncArrowUnaryFunction(s)}return e&&this.match(l.arrow)&&!this.canInsertSemicolon()?(this.next(),this.parseArrowExpression(this.startNodeAtNode(s),[s],!1)):s}case l._do:return this.parseDo();case l.regexp:{const t=this.state.value;return s=this.parseLiteral(t.value,\"RegExpLiteral\"),s.pattern=t.pattern,s.flags=t.flags,s}case l.num:return this.parseLiteral(this.state.value,\"NumericLiteral\");case l.bigint:return this.parseLiteral(this.state.value,\"BigIntLiteral\");case l.decimal:return this.parseLiteral(this.state.value,\"DecimalLiteral\");case l.string:return this.parseLiteral(this.state.value,\"StringLiteral\");case l._null:return s=this.startNode(),this.next(),this.finishNode(s,\"NullLiteral\");case l._true:case l._false:return this.parseBooleanLiteral();case l.parenL:return this.parseParenAndDistinguishExpression(e);case l.bracketBarL:case l.bracketHashL:return this.parseArrayLike(this.state.type===l.bracketBarL?l.bracketBarR:l.bracketR,!1,!0,t);case l.bracketL:return this.parseArrayLike(l.bracketR,!0,!1,t);case l.braceBarL:case l.braceHashL:return this.parseObjectLike(this.state.type===l.braceBarL?l.braceBarR:l.braceR,!1,!0,t);case l.braceL:return this.parseObjectLike(l.braceR,!1,!1,t);case l._function:return this.parseFunctionOrFunctionSent();case l.at:this.parseDecorators();case l._class:return s=this.startNode(),this.takeDecorators(s),this.parseClass(s,!1);case l._new:return this.parseNewOrNewTarget();case l.backQuote:return this.parseTemplate(!1);case l.doubleColon:{s=this.startNode(),this.next(),s.object=null;const t=s.callee=this.parseNoCallExpr();if(\"MemberExpression\"===t.type)return this.finishNode(s,\"BindExpression\");throw this.raise(t.start,b.UnsupportedBind)}case l.hash:{if(this.state.inPipeline)return s=this.startNode(),\"smart\"!==this.getPluginOption(\"pipelineOperator\",\"proposal\")&&this.raise(s.start,b.PrimaryTopicRequiresSmartPipeline),this.next(),this.primaryTopicReferenceIsAllowedInCurrentTopicContext()||this.raise(s.start,b.PrimaryTopicNotAllowed),this.registerTopicReference(),this.finishNode(s,\"PipelinePrimaryTopicReference\");const t=this.input.codePointAt(this.state.end);if(v(t)||92===t){const t=this.state.start;if(s=this.parseMaybePrivateName(!0),this.match(l._in))this.expectPlugin(\"privateIn\"),this.classScope.usePrivateName(s.id.name,s.start);else{if(!this.hasPlugin(\"privateIn\"))throw this.unexpected(t);this.raise(this.state.start,b.PrivateInExpectedIn,s.id.name)}return s}}case l.relational:if(\"<\"===this.state.value){const t=this.input.codePointAt(this.nextTokenStart());(v(t)||62===t)&&this.expectOnePlugin([\"jsx\",\"flow\",\"typescript\"])}default:throw this.unexpected()}}parseAsyncArrowUnaryFunction(t){const e=this.startNodeAtNode(t);this.prodParam.enter(ut(!0,this.prodParam.hasYield));const s=[this.parseIdentifier()];return this.prodParam.exit(),this.hasPrecedingLineBreak()&&this.raise(this.state.pos,b.LineTerminatorBeforeArrow),this.expect(l.arrow),this.parseArrowExpression(e,s,!0),e}parseDo(){this.expectPlugin(\"doExpressions\");const t=this.startNode();this.next();const e=this.state.labels;return this.state.labels=[],t.body=this.parseBlock(),this.state.labels=e,this.finishNode(t,\"DoExpression\")}parseSuper(){const t=this.startNode();return this.next(),!this.match(l.parenL)||this.scope.allowDirectSuper||this.options.allowSuperOutsideMethod?this.scope.allowSuper||this.options.allowSuperOutsideMethod||this.raise(t.start,b.UnexpectedSuper):this.raise(t.start,b.SuperNotAllowed),this.match(l.parenL)||this.match(l.bracketL)||this.match(l.dot)||this.raise(t.start,b.UnsupportedSuper),this.finishNode(t,\"Super\")}parseBooleanLiteral(){const t=this.startNode();return t.value=this.match(l._true),this.next(),this.finishNode(t,\"BooleanLiteral\")}parseMaybePrivateName(t){if(this.match(l.hash)){this.expectOnePlugin([\"classPrivateProperties\",\"classPrivateMethods\"]),t||this.raise(this.state.pos,b.UnexpectedPrivateField);const e=this.startNode();return this.next(),this.assertNoSpace(\"Unexpected space between # and identifier\"),e.id=this.parseIdentifier(!0),this.finishNode(e,\"PrivateName\")}return this.parseIdentifier(!0)}parseFunctionOrFunctionSent(){const t=this.startNode();if(this.next(),this.prodParam.hasYield&&this.match(l.dot)){const e=this.createIdentifier(this.startNodeAtNode(t),\"function\");return this.next(),this.parseMetaProperty(t,e,\"sent\")}return this.parseFunction(t)}parseMetaProperty(t,e,s){t.meta=e,\"function\"===e.name&&\"sent\"===s&&(this.isContextual(s)?this.expectPlugin(\"functionSent\"):this.hasPlugin(\"functionSent\")||this.unexpected());const i=this.state.containsEsc;return t.property=this.parseIdentifier(!0),(t.property.name!==s||i)&&this.raise(t.property.start,b.UnsupportedMetaProperty,e.name,s),this.finishNode(t,\"MetaProperty\")}parseImportMetaProperty(t){const e=this.createIdentifier(this.startNodeAtNode(t),\"import\");return this.next(),this.isContextual(\"meta\")&&(this.inModule||this.raiseWithData(e.start,{code:\"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"},b.ImportMetaOutsideModule),this.sawUnambiguousESM=!0),this.parseMetaProperty(t,e,\"meta\")}parseLiteral(t,e,s,i){s=s||this.state.start,i=i||this.state.startLoc;const r=this.startNodeAt(s,i);return this.addExtra(r,\"rawValue\",t),this.addExtra(r,\"raw\",this.input.slice(s,this.state.end)),r.value=t,this.next(),this.finishNode(r,e)}parseParenAndDistinguishExpression(t){const e=this.state.start,s=this.state.startLoc;let i;this.next(),this.expressionScope.enter(new Rt(1));const r=this.state.maybeInArrowParameters,a=this.state.inFSharpPipelineDirectBody;this.state.maybeInArrowParameters=!0,this.state.inFSharpPipelineDirectBody=!1;const n=this.state.start,o=this.state.startLoc,h=[],p=new vt,c={start:0};let u,d,m=!0;for(;!this.match(l.parenR);){if(m)m=!1;else if(this.expect(l.comma,c.start||null),this.match(l.parenR)){d=this.state.start;break}if(this.match(l.ellipsis)){const t=this.state.start,e=this.state.startLoc;u=this.state.start,h.push(this.parseParenItem(this.parseRestBinding(),t,e)),this.checkCommaAfterRest(41);break}h.push(this.parseMaybeAssignAllowIn(p,this.parseParenItem,c))}const f=this.state.lastTokEnd,y=this.state.lastTokEndLoc;this.expect(l.parenR),this.state.maybeInArrowParameters=r,this.state.inFSharpPipelineDirectBody=a;let x=this.startNodeAt(e,s);if(t&&this.shouldParseArrow()&&(x=this.parseArrow(x)))return this.expressionScope.validateAsPattern(),this.expressionScope.exit(),this.parseArrowExpression(x,h,!1),x;if(this.expressionScope.exit(),h.length||this.unexpected(this.state.lastTokStart),d&&this.unexpected(d),u&&this.unexpected(u),this.checkExpressionErrors(p,!0),c.start&&this.unexpected(c.start),this.toReferencedListDeep(h,!0),h.length>1?(i=this.startNodeAt(n,o),i.expressions=h,this.finishNodeAt(i,\"SequenceExpression\",f,y)):i=h[0],!this.options.createParenthesizedExpressions)return this.addExtra(i,\"parenthesized\",!0),this.addExtra(i,\"parenStart\",e),i;const P=this.startNodeAt(e,s);return P.expression=i,this.finishNode(P,\"ParenthesizedExpression\"),P}shouldParseArrow(){return!this.canInsertSemicolon()}parseArrow(t){if(this.eat(l.arrow))return t}parseParenItem(t,e,s){return t}parseNewOrNewTarget(){const t=this.startNode();if(this.next(),this.match(l.dot)){const e=this.createIdentifier(this.startNodeAtNode(t),\"new\");this.next();const s=this.parseMetaProperty(t,e,\"target\");if(!this.scope.inNonArrowFunction&&!this.scope.inClass){let t=b.UnexpectedNewTarget;this.hasPlugin(\"classProperties\")&&(t+=\" or class properties\"),this.raise(s.start,t)}return s}return this.parseNew(t)}parseNew(t){return t.callee=this.parseNoCallExpr(),\"Import\"===t.callee.type?this.raise(t.callee.start,b.ImportCallNotNewExpression):this.isOptionalChain(t.callee)?this.raise(this.state.lastTokEnd,b.OptionalChainingNoNew):this.eat(l.questionDot)&&this.raise(this.state.start,b.OptionalChainingNoNew),this.parseNewArguments(t),this.finishNode(t,\"NewExpression\")}parseNewArguments(t){if(this.eat(l.parenL)){const e=this.parseExprList(l.parenR);this.toReferencedList(e),t.arguments=e}else t.arguments=[]}parseTemplateElement(t){const e=this.startNode();return null===this.state.value&&(t||this.raise(this.state.start+1,b.InvalidEscapeSequenceTemplate)),e.value={raw:this.input.slice(this.state.start,this.state.end).replace(/\\r\\n?/g,\"\\n\"),cooked:this.state.value},this.next(),e.tail=this.match(l.backQuote),this.finishNode(e,\"TemplateElement\")}parseTemplate(t){const e=this.startNode();this.next(),e.expressions=[];let s=this.parseTemplateElement(t);for(e.quasis=[s];!s.tail;)this.expect(l.dollarBraceL),e.expressions.push(this.parseTemplateSubstitution()),this.expect(l.braceR),e.quasis.push(s=this.parseTemplateElement(t));return this.next(),this.finishNode(e,\"TemplateLiteral\")}parseTemplateSubstitution(){return this.parseExpression()}parseObjectLike(t,e,s,i){s&&this.expectPlugin(\"recordAndTuple\");const r=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!1;const a=Object.create(null);let n=!0;const o=this.startNode();for(o.properties=[],this.next();!this.match(t);){if(n)n=!1;else if(this.expect(l.comma),this.match(t)){this.addExtra(o,\"trailingComma\",this.state.lastTokStart);break}const r=this.parsePropertyDefinition(e,i);e||this.checkProto(r,s,a,i),s&&!this.isObjectProperty(r)&&\"SpreadElement\"!==r.type&&this.raise(r.start,b.InvalidRecordProperty),r.shorthand&&this.addExtra(r,\"shorthand\",!0),o.properties.push(r)}this.state.exprAllowed=!1,this.next(),this.state.inFSharpPipelineDirectBody=r;let h=\"ObjectExpression\";return e?h=\"ObjectPattern\":s&&(h=\"RecordExpression\"),this.finishNode(o,h)}maybeAsyncOrAccessorProp(t){return!t.computed&&\"Identifier\"===t.key.type&&(this.isLiteralPropertyName()||this.match(l.bracketL)||this.match(l.star))}parsePropertyDefinition(t,e){let s=[];if(this.match(l.at))for(this.hasPlugin(\"decorators\")&&this.raise(this.state.start,b.UnsupportedPropertyDecorator);this.match(l.at);)s.push(this.parseDecorator());const i=this.startNode();let r,a,n=!1,o=!1,h=!1;if(this.match(l.ellipsis))return s.length&&this.unexpected(),t?(this.next(),i.argument=this.parseIdentifier(),this.checkCommaAfterRest(125),this.finishNode(i,\"RestElement\")):this.parseSpread();s.length&&(i.decorators=s,s=[]),i.method=!1,(t||e)&&(r=this.state.start,a=this.state.startLoc),t||(n=this.eat(l.star));const p=this.state.containsEsc,c=this.parsePropertyName(i,!1);if(!t&&!n&&!p&&this.maybeAsyncOrAccessorProp(i)){const t=c.name;\"async\"!==t||this.hasPrecedingLineBreak()||(o=!0,n=this.eat(l.star),this.parsePropertyName(i,!1)),\"get\"!==t&&\"set\"!==t||(h=!0,i.kind=t,this.match(l.star)&&(n=!0,this.raise(this.state.pos,b.AccessorIsGenerator,t),this.next()),this.parsePropertyName(i,!1))}return this.parseObjPropValue(i,r,a,n,o,t,h,e),i}getGetterSetterExpectedParamCount(t){return\"get\"===t.kind?0:1}getObjectOrClassMethodParams(t){return t.params}checkGetterSetterParams(t){var e;const s=this.getGetterSetterExpectedParamCount(t),i=this.getObjectOrClassMethodParams(t),r=t.start;i.length!==s&&(\"get\"===t.kind?this.raise(r,b.BadGetterArity):this.raise(r,b.BadSetterArity)),\"set\"===t.kind&&\"RestElement\"===(null==(e=i[i.length-1])?void 0:e.type)&&this.raise(r,b.BadSetterRestParameter)}parseObjectMethod(t,e,s,i,r){return r?(this.parseMethod(t,e,!1,!1,!1,\"ObjectMethod\"),this.checkGetterSetterParams(t),t):s||e||this.match(l.parenL)?(i&&this.unexpected(),t.kind=\"method\",t.method=!0,this.parseMethod(t,e,s,!1,!1,\"ObjectMethod\")):void 0}parseObjectProperty(t,e,s,i,r){return t.shorthand=!1,this.eat(l.colon)?(t.value=i?this.parseMaybeDefault(this.state.start,this.state.startLoc):this.parseMaybeAssignAllowIn(r),this.finishNode(t,\"ObjectProperty\")):t.computed||\"Identifier\"!==t.key.type?void 0:(this.checkReservedWord(t.key.name,t.key.start,!0,!1),i?t.value=this.parseMaybeDefault(e,s,t.key.__clone()):this.match(l.eq)&&r?(-1===r.shorthandAssign&&(r.shorthandAssign=this.state.start),t.value=this.parseMaybeDefault(e,s,t.key.__clone())):t.value=t.key.__clone(),t.shorthand=!0,this.finishNode(t,\"ObjectProperty\"))}parseObjPropValue(t,e,s,i,r,a,n,o){const h=this.parseObjectMethod(t,i,r,a,n)||this.parseObjectProperty(t,e,s,a,o);return h||this.unexpected(),h}parsePropertyName(t,e){if(this.eat(l.bracketL))t.computed=!0,t.key=this.parseMaybeAssignAllowIn(),this.expect(l.bracketR);else{const s=this.state.inPropertyName;this.state.inPropertyName=!0,t.key=this.match(l.num)||this.match(l.string)||this.match(l.bigint)||this.match(l.decimal)?this.parseExprAtom():this.parseMaybePrivateName(e),this.isPrivateName(t.key)||(t.computed=!1),this.state.inPropertyName=s}return t.key}initFunction(t,e){t.id=null,t.generator=!1,t.async=!!e}parseMethod(t,e,s,i,r,a,n=!1){this.initFunction(t,s),t.generator=!!e;const o=i;return this.scope.enter(18|(n?64:0)|(r?32:0)),this.prodParam.enter(ut(s,t.generator)),this.parseFunctionParams(t,o),this.parseFunctionBodyAndFinish(t,a,!0),this.prodParam.exit(),this.scope.exit(),t}parseArrayLike(t,e,s,i){s&&this.expectPlugin(\"recordAndTuple\");const r=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!1;const a=this.startNode();return this.next(),a.elements=this.parseExprList(t,!s,i,a),this.state.inFSharpPipelineDirectBody=r,this.finishNode(a,s?\"TupleExpression\":\"ArrayExpression\")}parseArrowExpression(t,e,s,i){this.scope.enter(6);let r=ut(s,!1);!this.match(l.bracketL)&&this.prodParam.hasIn&&(r|=8),this.prodParam.enter(r),this.initFunction(t,s);const a=this.state.maybeInArrowParameters;return e&&(this.state.maybeInArrowParameters=!0,this.setArrowFunctionParameters(t,e,i)),this.state.maybeInArrowParameters=!1,this.parseFunctionBody(t,!0),this.prodParam.exit(),this.scope.exit(),this.state.maybeInArrowParameters=a,this.finishNode(t,\"ArrowFunctionExpression\")}setArrowFunctionParameters(t,e,s){t.params=this.toAssignableList(e,s,!1)}parseFunctionBodyAndFinish(t,e,s=!1){this.parseFunctionBody(t,!1,s),this.finishNode(t,e)}parseFunctionBody(t,e,s=!1){const i=e&&!this.match(l.braceL);if(this.expressionScope.enter(Ft()),i)t.body=this.parseMaybeAssign(),this.checkParams(t,!1,e,!1);else{const i=this.state.strict,r=this.state.labels;this.state.labels=[],this.prodParam.enter(4|this.prodParam.currentFlags()),t.body=this.parseBlock(!0,!1,(r=>{const a=!this.isSimpleParamList(t.params);if(r&&a){const e=\"method\"!==t.kind&&\"constructor\"!==t.kind||!t.key?t.start:t.key.end;this.raise(e,b.IllegalLanguageModeDirective)}const n=!i&&this.state.strict;this.checkParams(t,!this.state.strict&&!e&&!s&&!a,e,n),this.state.strict&&t.id&&this.checkLVal(t.id,\"function name\",65,void 0,void 0,n)})),this.prodParam.exit(),this.expressionScope.exit(),this.state.labels=r}}isSimpleParamList(t){for(let e=0,s=t.length;e<s;e++)if(\"Identifier\"!==t[e].type)return!1;return!0}checkParams(t,e,s,i=!0){const r=new Set;for(let a=0,n=t.params;a<n.length;a++){const t=n[a];this.checkLVal(t,\"function parameter list\",5,e?null:r,void 0,i)}}parseExprList(t,e,s,i){const r=[];let a=!0;for(;!this.eat(t);){if(a)a=!1;else if(this.expect(l.comma),this.match(t)){i&&this.addExtra(i,\"trailingComma\",this.state.lastTokStart),this.next();break}r.push(this.parseExprListItem(e,s))}return r}parseExprListItem(t,e,s,i){let r;if(this.match(l.comma))t||this.raise(this.state.pos,b.UnexpectedToken,\",\"),r=null;else if(this.match(l.ellipsis)){const t=this.state.start,i=this.state.startLoc;r=this.parseParenItem(this.parseSpread(e,s),t,i)}else if(this.match(l.question)){this.expectPlugin(\"partialApplication\"),i||this.raise(this.state.start,b.UnexpectedArgumentPlaceholder);const t=this.startNode();this.next(),r=this.finishNode(t,\"ArgumentPlaceholder\")}else r=this.parseMaybeAssignAllowIn(e,this.parseParenItem,s);return r}parseIdentifier(t){const e=this.startNode(),s=this.parseIdentifierName(e.start,t);return this.createIdentifier(e,s)}createIdentifier(t,e){return t.name=e,t.loc.identifierName=e,this.finishNode(t,\"Identifier\")}parseIdentifierName(t,e){let s;const{start:i,type:r}=this.state;if(r===l.name)s=this.state.value;else{if(!r.keyword)throw this.unexpected();{s=r.keyword;const t=this.curContext();r!==l._class&&r!==l._function||t!==A.functionStatement&&t!==A.functionExpression||this.state.context.pop()}}return e?this.state.type=l.name:this.checkReservedWord(s,i,!!r.keyword,!1),this.next(),s}checkReservedWord(t,e,s,i){if(this.prodParam.hasYield&&\"yield\"===t)return void this.raise(e,b.YieldBindingIdentifier);if(\"await\"===t){if(this.prodParam.hasAwait)return void this.raise(e,b.AwaitBindingIdentifier);if(this.scope.inStaticBlock&&!this.scope.inNonArrowFunction)return void this.raise(e,b.AwaitBindingIdentifierInStaticBlock);this.expressionScope.recordAsyncArrowParametersError(e,b.AwaitBindingIdentifier)}if(this.scope.inClass&&!this.scope.inNonArrowFunction&&\"arguments\"===t)return void this.raise(e,b.ArgumentsInClass);if(s&&q(t))return void this.raise(e,b.UnexpectedKeyword,t);(this.state.strict?i?U:_:B)(t,this.inModule)&&this.raise(e,b.UnexpectedReservedWord,t)}isAwaitAllowed(){return!!this.prodParam.hasAwait||!(!this.options.allowAwaitOutsideFunction||this.scope.inFunction)}parseAwait(t,e){const s=this.startNodeAt(t,e);return this.expressionScope.recordParameterInitializerError(s.start,b.AwaitExpressionFormalParameter),this.eat(l.star)&&this.raise(s.start,b.ObsoleteAwaitStar),this.scope.inFunction||this.options.allowAwaitOutsideFunction||(this.isAmbiguousAwait()?this.ambiguousScriptDifferentAst=!0:this.sawUnambiguousESM=!0),this.state.soloAwait||(s.argument=this.parseMaybeUnary()),this.finishNode(s,\"AwaitExpression\")}isAmbiguousAwait(){return this.hasPrecedingLineBreak()||this.match(l.plusMin)||this.match(l.parenL)||this.match(l.bracketL)||this.match(l.backQuote)||this.match(l.regexp)||this.match(l.slash)||this.hasPlugin(\"v8intrinsic\")&&this.match(l.modulo)}parseYield(){const t=this.startNode();return this.expressionScope.recordParameterInitializerError(t.start,b.YieldInParameter),this.next(),this.match(l.semi)||!this.match(l.star)&&!this.state.type.startsExpr||this.hasPrecedingLineBreak()?(t.delegate=!1,t.argument=null):(t.delegate=this.eat(l.star),t.argument=this.parseMaybeAssign()),this.finishNode(t,\"YieldExpression\")}checkPipelineAtInfixOperator(t,e){\"smart\"===this.getPluginOption(\"pipelineOperator\",\"proposal\")&&\"SequenceExpression\"===t.type&&this.raise(e,b.PipelineHeadSequenceExpression)}parseSmartPipelineBody(t,e,s){return this.checkSmartPipelineBodyEarlyErrors(t,e),this.parseSmartPipelineBodyInStyle(t,e,s)}checkSmartPipelineBodyEarlyErrors(t,e){if(this.match(l.arrow))throw this.raise(this.state.start,b.PipelineBodyNoArrow);\"SequenceExpression\"===t.type&&this.raise(e,b.PipelineBodySequenceExpression)}parseSmartPipelineBodyInStyle(t,e,s){const i=this.startNodeAt(e,s),r=this.isSimpleReference(t);return r?i.callee=t:(this.topicReferenceWasUsedInCurrentTopicContext()||this.raise(e,b.PipelineTopicUnused),i.expression=t),this.finishNode(i,r?\"PipelineBareFunction\":\"PipelineTopicExpression\")}isSimpleReference(t){switch(t.type){case\"MemberExpression\":return!t.computed&&this.isSimpleReference(t.object);case\"Identifier\":return!0;default:return!1}}withTopicPermittingContext(t){const e=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:1,maxTopicIndex:null};try{return t()}finally{this.state.topicContext=e}}withTopicForbiddingContext(t){const e=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null};try{return t()}finally{this.state.topicContext=e}}withSoloAwaitPermittingContext(t){const e=this.state.soloAwait;this.state.soloAwait=!0;try{return t()}finally{this.state.soloAwait=e}}allowInAnd(t){const e=this.prodParam.currentFlags();if(8&~e){this.prodParam.enter(8|e);try{return t()}finally{this.prodParam.exit()}}return t()}disallowInAnd(t){const e=this.prodParam.currentFlags();if(8&e){this.prodParam.enter(-9&e);try{return t()}finally{this.prodParam.exit()}}return t()}registerTopicReference(){this.state.topicContext.maxTopicIndex=0}primaryTopicReferenceIsAllowedInCurrentTopicContext(){return this.state.topicContext.maxNumOfResolvableTopics>=1}topicReferenceWasUsedInCurrentTopicContext(){return null!=this.state.topicContext.maxTopicIndex&&this.state.topicContext.maxTopicIndex>=0}parseFSharpPipelineBody(t){const e=this.state.start,s=this.state.startLoc;this.state.potentialArrowAt=this.state.start;const i=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!0;const r=this.parseExprOp(this.parseMaybeUnary(),e,s,t);return this.state.inFSharpPipelineDirectBody=i,r}}{parseTopLevel(t,e){if(e.sourceType=this.options.sourceType,e.interpreter=this.parseInterpreterDirective(),this.parseBlockBody(e,!0,!0,l.eof),this.inModule&&!this.options.allowUndeclaredExports&&this.scope.undefinedExports.size>0)for(let s=0,i=Array.from(this.scope.undefinedExports);s<i.length;s++){const[t]=i[s],e=this.scope.undefinedExports.get(t);this.raise(e,b.ModuleExportUndefined,t)}return t.program=this.finishNode(e,\"Program\"),t.comments=this.state.comments,this.options.tokens&&(t.tokens=this.tokens),this.finishNode(t,\"File\")}stmtToDirective(t){const e=t.expression,s=this.startNodeAt(e.start,e.loc.start),i=this.startNodeAt(t.start,t.loc.start),r=this.input.slice(e.start,e.end),a=s.value=r.slice(1,-1);return this.addExtra(s,\"raw\",r),this.addExtra(s,\"rawValue\",a),i.value=this.finishNodeAt(s,\"DirectiveLiteral\",e.end,e.loc.end),this.finishNodeAt(i,\"Directive\",t.end,t.loc.end)}parseInterpreterDirective(){if(!this.match(l.interpreterDirective))return null;const t=this.startNode();return t.value=this.state.value,this.next(),this.finishNode(t,\"InterpreterDirective\")}isLet(t){if(!this.isContextual(\"let\"))return!1;const e=this.nextTokenStart(),s=this.input.charCodeAt(e);if(91===s)return!0;if(t)return!1;if(123===s)return!0;if(v(s)){let t=e+1;for(;L(this.input.charCodeAt(t));)++t;const s=this.input.slice(e,t);if(!V.test(s))return!0}return!1}parseStatement(t,e){return this.match(l.at)&&this.parseDecorators(!0),this.parseStatementContent(t,e)}parseStatementContent(t,e){let s=this.state.type;const i=this.startNode();let r;switch(this.isLet(t)&&(s=l._var,r=\"let\"),s){case l._break:case l._continue:return this.parseBreakContinueStatement(i,s.keyword);case l._debugger:return this.parseDebuggerStatement(i);case l._do:return this.parseDoStatement(i);case l._for:return this.parseForStatement(i);case l._function:if(46===this.lookaheadCharCode())break;return t&&(this.state.strict?this.raise(this.state.start,b.StrictFunction):\"if\"!==t&&\"label\"!==t&&this.raise(this.state.start,b.SloppyFunction)),this.parseFunctionStatement(i,!1,!t);case l._class:return t&&this.unexpected(),this.parseClass(i,!0);case l._if:return this.parseIfStatement(i);case l._return:return this.parseReturnStatement(i);case l._switch:return this.parseSwitchStatement(i);case l._throw:return this.parseThrowStatement(i);case l._try:return this.parseTryStatement(i);case l._const:case l._var:return r=r||this.state.value,t&&\"var\"!==r&&this.raise(this.state.start,b.UnexpectedLexicalDeclaration),this.parseVarStatement(i,r);case l._while:return this.parseWhileStatement(i);case l._with:return this.parseWithStatement(i);case l.braceL:return this.parseBlock();case l.semi:return this.parseEmptyStatement(i);case l._import:{const t=this.lookaheadCharCode();if(40===t||46===t)break}case l._export:{let t;return this.options.allowImportExportEverywhere||e||this.raise(this.state.start,b.UnexpectedImportExport),this.next(),s===l._import?(t=this.parseImport(i),\"ImportDeclaration\"!==t.type||t.importKind&&\"value\"!==t.importKind||(this.sawUnambiguousESM=!0)):(t=this.parseExport(i),(\"ExportNamedDeclaration\"!==t.type||t.exportKind&&\"value\"!==t.exportKind)&&(\"ExportAllDeclaration\"!==t.type||t.exportKind&&\"value\"!==t.exportKind)&&\"ExportDefaultDeclaration\"!==t.type||(this.sawUnambiguousESM=!0)),this.assertModuleNodeAllowed(i),t}default:if(this.isAsyncFunction())return t&&this.raise(this.state.start,b.AsyncFunctionInSingleStatementContext),this.next(),this.parseFunctionStatement(i,!0,!t)}const a=this.state.value,n=this.parseExpression();return s===l.name&&\"Identifier\"===n.type&&this.eat(l.colon)?this.parseLabeledStatement(i,a,n,t):this.parseExpressionStatement(i,n)}assertModuleNodeAllowed(t){this.options.allowImportExportEverywhere||this.inModule||this.raiseWithData(t.start,{code:\"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"},b.ImportOutsideModule)}takeDecorators(t){const e=this.state.decoratorStack[this.state.decoratorStack.length-1];e.length&&(t.decorators=e,this.resetStartLocationFromNode(t,e[0]),this.state.decoratorStack[this.state.decoratorStack.length-1]=[])}canHaveLeadingDecorator(){return this.match(l._class)}parseDecorators(t){const e=this.state.decoratorStack[this.state.decoratorStack.length-1];for(;this.match(l.at);){const t=this.parseDecorator();e.push(t)}if(this.match(l._export))t||this.unexpected(),this.hasPlugin(\"decorators\")&&!this.getPluginOption(\"decorators\",\"decoratorsBeforeExport\")&&this.raise(this.state.start,b.DecoratorExportClass);else if(!this.canHaveLeadingDecorator())throw this.raise(this.state.start,b.UnexpectedLeadingDecorator)}parseDecorator(){this.expectOnePlugin([\"decorators-legacy\",\"decorators\"]);const t=this.startNode();if(this.next(),this.hasPlugin(\"decorators\")){this.state.decoratorStack.push([]);const e=this.state.start,s=this.state.startLoc;let i;if(this.eat(l.parenL))i=this.parseExpression(),this.expect(l.parenR);else for(i=this.parseIdentifier(!1);this.eat(l.dot);){const t=this.startNodeAt(e,s);t.object=i,t.property=this.parseIdentifier(!0),t.computed=!1,i=this.finishNode(t,\"MemberExpression\")}t.expression=this.parseMaybeDecoratorArguments(i),this.state.decoratorStack.pop()}else t.expression=this.parseExprSubscripts();return this.finishNode(t,\"Decorator\")}parseMaybeDecoratorArguments(t){if(this.eat(l.parenL)){const e=this.startNodeAtNode(t);return e.callee=t,e.arguments=this.parseCallExpressionArguments(l.parenR,!1),this.toReferencedList(e.arguments),this.finishNode(e,\"CallExpression\")}return t}parseBreakContinueStatement(t,e){const s=\"break\"===e;return this.next(),this.isLineTerminator()?t.label=null:(t.label=this.parseIdentifier(),this.semicolon()),this.verifyBreakContinue(t,e),this.finishNode(t,s?\"BreakStatement\":\"ContinueStatement\")}verifyBreakContinue(t,e){const s=\"break\"===e;let i;for(i=0;i<this.state.labels.length;++i){const e=this.state.labels[i];if(null==t.label||e.name===t.label.name){if(null!=e.kind&&(s||\"loop\"===e.kind))break;if(t.label&&s)break}}i===this.state.labels.length&&this.raise(t.start,b.IllegalBreakContinue,e)}parseDebuggerStatement(t){return this.next(),this.semicolon(),this.finishNode(t,\"DebuggerStatement\")}parseHeaderExpression(){this.expect(l.parenL);const t=this.parseExpression();return this.expect(l.parenR),t}parseDoStatement(t){return this.next(),this.state.labels.push(Bt),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"do\"))),this.state.labels.pop(),this.expect(l._while),t.test=this.parseHeaderExpression(),this.eat(l.semi),this.finishNode(t,\"DoWhileStatement\")}parseForStatement(t){this.next(),this.state.labels.push(Bt);let e=-1;if(this.isAwaitAllowed()&&this.eatContextual(\"await\")&&(e=this.state.lastTokStart),this.scope.enter(0),this.expect(l.parenL),this.match(l.semi))return e>-1&&this.unexpected(e),this.parseFor(t,null);const s=this.isLet();if(this.match(l._var)||this.match(l._const)||s){const i=this.startNode(),r=s?\"let\":this.state.value;return this.next(),this.parseVar(i,!0,r),this.finishNode(i,\"VariableDeclaration\"),(this.match(l._in)||this.isContextual(\"of\"))&&1===i.declarations.length?this.parseForIn(t,i,e):(e>-1&&this.unexpected(e),this.parseFor(t,i))}const i=new vt,r=this.parseExpression(!0,i);if(this.match(l._in)||this.isContextual(\"of\")){this.toAssignable(r,!0);const s=this.isContextual(\"of\")?\"for-of statement\":\"for-in statement\";return this.checkLVal(r,s),this.parseForIn(t,r,e)}return this.checkExpressionErrors(i,!0),e>-1&&this.unexpected(e),this.parseFor(t,r)}parseFunctionStatement(t,e,s){return this.next(),this.parseFunction(t,1|(s?0:2),e)}parseIfStatement(t){return this.next(),t.test=this.parseHeaderExpression(),t.consequent=this.parseStatement(\"if\"),t.alternate=this.eat(l._else)?this.parseStatement(\"if\"):null,this.finishNode(t,\"IfStatement\")}parseReturnStatement(t){return this.prodParam.hasReturn||this.options.allowReturnOutsideFunction||this.raise(this.state.start,b.IllegalReturn),this.next(),this.isLineTerminator()?t.argument=null:(t.argument=this.parseExpression(),this.semicolon()),this.finishNode(t,\"ReturnStatement\")}parseSwitchStatement(t){this.next(),t.discriminant=this.parseHeaderExpression();const e=t.cases=[];let s,i;for(this.expect(l.braceL),this.state.labels.push(_t),this.scope.enter(0);!this.match(l.braceR);)if(this.match(l._case)||this.match(l._default)){const t=this.match(l._case);s&&this.finishNode(s,\"SwitchCase\"),e.push(s=this.startNode()),s.consequent=[],this.next(),t?s.test=this.parseExpression():(i&&this.raise(this.state.lastTokStart,b.MultipleDefaultsInSwitch),i=!0,s.test=null),this.expect(l.colon)}else s?s.consequent.push(this.parseStatement(null)):this.unexpected();return this.scope.exit(),s&&this.finishNode(s,\"SwitchCase\"),this.next(),this.state.labels.pop(),this.finishNode(t,\"SwitchStatement\")}parseThrowStatement(t){return this.next(),this.hasPrecedingLineBreak()&&this.raise(this.state.lastTokEnd,b.NewlineAfterThrow),t.argument=this.parseExpression(),this.semicolon(),this.finishNode(t,\"ThrowStatement\")}parseCatchClauseParam(){const t=this.parseBindingAtom(),e=\"Identifier\"===t.type;return this.scope.enter(e?8:0),this.checkLVal(t,\"catch clause\",9),t}parseTryStatement(t){if(this.next(),t.block=this.parseBlock(),t.handler=null,this.match(l._catch)){const e=this.startNode();this.next(),this.match(l.parenL)?(this.expect(l.parenL),e.param=this.parseCatchClauseParam(),this.expect(l.parenR)):(e.param=null,this.scope.enter(0)),e.body=this.withTopicForbiddingContext((()=>this.parseBlock(!1,!1))),this.scope.exit(),t.handler=this.finishNode(e,\"CatchClause\")}return t.finalizer=this.eat(l._finally)?this.parseBlock():null,t.handler||t.finalizer||this.raise(t.start,b.NoCatchOrFinally),this.finishNode(t,\"TryStatement\")}parseVarStatement(t,e){return this.next(),this.parseVar(t,!1,e),this.semicolon(),this.finishNode(t,\"VariableDeclaration\")}parseWhileStatement(t){return this.next(),t.test=this.parseHeaderExpression(),this.state.labels.push(Bt),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"while\"))),this.state.labels.pop(),this.finishNode(t,\"WhileStatement\")}parseWithStatement(t){return this.state.strict&&this.raise(this.state.start,b.StrictWith),this.next(),t.object=this.parseHeaderExpression(),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"with\"))),this.finishNode(t,\"WithStatement\")}parseEmptyStatement(t){return this.next(),this.finishNode(t,\"EmptyStatement\")}parseLabeledStatement(t,e,s,i){for(let a=0,n=this.state.labels;a<n.length;a++){n[a].name===e&&this.raise(s.start,b.LabelRedeclaration,e)}const r=this.state.type.isLoop?\"loop\":this.match(l._switch)?\"switch\":null;for(let a=this.state.labels.length-1;a>=0;a--){const e=this.state.labels[a];if(e.statementStart!==t.start)break;e.statementStart=this.state.start,e.kind=r}return this.state.labels.push({name:e,kind:r,statementStart:this.state.start}),t.body=this.parseStatement(i?-1===i.indexOf(\"label\")?i+\"label\":i:\"label\"),this.state.labels.pop(),t.label=s,this.finishNode(t,\"LabeledStatement\")}parseExpressionStatement(t,e){return t.expression=e,this.semicolon(),this.finishNode(t,\"ExpressionStatement\")}parseBlock(t=!1,e=!0,s){const i=this.startNode();return t&&this.state.strictErrors.clear(),this.expect(l.braceL),e&&this.scope.enter(0),this.parseBlockBody(i,t,!1,l.braceR,s),e&&this.scope.exit(),this.finishNode(i,\"BlockStatement\")}isValidDirective(t){return\"ExpressionStatement\"===t.type&&\"StringLiteral\"===t.expression.type&&!t.expression.extra.parenthesized}parseBlockBody(t,e,s,i,r){const a=t.body=[],n=t.directives=[];this.parseBlockOrModuleBlockBody(a,e?n:void 0,s,i,r)}parseBlockOrModuleBlockBody(t,e,s,i,r){const a=this.state.strict;let n=!1,o=!1;for(;!this.match(i);){const i=this.parseStatement(null,s);if(e&&!o){if(this.isValidDirective(i)){const t=this.stmtToDirective(i);e.push(t),n||\"use strict\"!==t.value.value||(n=!0,this.setStrict(!0));continue}o=!0,this.state.strictErrors.clear()}t.push(i)}r&&r.call(this,n),a||this.setStrict(!1),this.next()}parseFor(t,e){return t.init=e,this.semicolon(!1),t.test=this.match(l.semi)?null:this.parseExpression(),this.semicolon(!1),t.update=this.match(l.parenR)?null:this.parseExpression(),this.expect(l.parenR),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"for\"))),this.scope.exit(),this.state.labels.pop(),this.finishNode(t,\"ForStatement\")}parseForIn(t,e,s){const i=this.match(l._in);return this.next(),i?s>-1&&this.unexpected(s):t.await=s>-1,\"VariableDeclaration\"!==e.type||null==e.declarations[0].init||i&&!this.state.strict&&\"var\"===e.kind&&\"Identifier\"===e.declarations[0].id.type?\"AssignmentPattern\"===e.type&&this.raise(e.start,b.InvalidLhs,\"for-loop\"):this.raise(e.start,b.ForInOfLoopInitializer,i?\"for-in\":\"for-of\"),t.left=e,t.right=i?this.parseExpression():this.parseMaybeAssignAllowIn(),this.expect(l.parenR),t.body=this.withTopicForbiddingContext((()=>this.parseStatement(\"for\"))),this.scope.exit(),this.state.labels.pop(),this.finishNode(t,i?\"ForInStatement\":\"ForOfStatement\")}parseVar(t,e,s){const i=t.declarations=[],r=this.hasPlugin(\"typescript\");for(t.kind=s;;){const t=this.startNode();if(this.parseVarId(t,s),this.eat(l.eq)?t.init=e?this.parseMaybeAssignDisallowIn():this.parseMaybeAssignAllowIn():(\"const\"!==s||this.match(l._in)||this.isContextual(\"of\")?\"Identifier\"===t.id.type||e&&(this.match(l._in)||this.isContextual(\"of\"))||this.raise(this.state.lastTokEnd,b.DeclarationMissingInitializer,\"Complex binding patterns\"):r||this.raise(this.state.lastTokEnd,b.DeclarationMissingInitializer,\"Const declarations\"),t.init=null),i.push(this.finishNode(t,\"VariableDeclarator\")),!this.eat(l.comma))break}return t}parseVarId(t,e){t.id=this.parseBindingAtom(),this.checkLVal(t.id,\"variable declaration\",\"var\"===e?5:9,void 0,\"var\"!==e)}parseFunction(t,e=0,s=!1){const i=1&e,r=2&e,a=!!i&&!(4&e);this.initFunction(t,s),this.match(l.star)&&r&&this.raise(this.state.start,b.GeneratorInSingleStatementContext),t.generator=this.eat(l.star),i&&(t.id=this.parseFunctionId(a));const n=this.state.maybeInArrowParameters;return this.state.maybeInArrowParameters=!1,this.scope.enter(2),this.prodParam.enter(ut(s,t.generator)),i||(t.id=this.parseFunctionId()),this.parseFunctionParams(t,!1),this.withTopicForbiddingContext((()=>{this.parseFunctionBodyAndFinish(t,i?\"FunctionDeclaration\":\"FunctionExpression\")})),this.prodParam.exit(),this.scope.exit(),i&&!r&&this.registerFunctionStatementId(t),this.state.maybeInArrowParameters=n,t}parseFunctionId(t){return t||this.match(l.name)?this.parseIdentifier():null}parseFunctionParams(t,e){this.expect(l.parenL),this.expressionScope.enter(new Mt(3)),t.params=this.parseBindingList(l.parenR,41,!1,e),this.expressionScope.exit()}registerFunctionStatementId(t){t.id&&this.scope.declareName(t.id.name,this.state.strict||t.generator||t.async?this.scope.treatFunctionsAsVar?5:9:17,t.id.start)}parseClass(t,e,s){this.next(),this.takeDecorators(t);const i=this.state.strict;return this.state.strict=!0,this.parseClassId(t,e,s),this.parseClassSuper(t),t.body=this.parseClassBody(!!t.superClass,i),this.finishNode(t,e?\"ClassDeclaration\":\"ClassExpression\")}isClassProperty(){return this.match(l.eq)||this.match(l.semi)||this.match(l.braceR)}isClassMethod(){return this.match(l.parenL)}isNonstaticConstructor(t){return!t.computed&&!t.static&&(\"constructor\"===t.key.name||\"constructor\"===t.key.value)}parseClassBody(t,e){this.classScope.enter();const s={constructorAllowsSuper:t,hadConstructor:!1,hadStaticBlock:!1};let i=[];const r=this.startNode();if(r.body=[],this.expect(l.braceL),this.withTopicForbiddingContext((()=>{for(;!this.match(l.braceR);){if(this.eat(l.semi)){if(i.length>0)throw this.raise(this.state.lastTokEnd,b.DecoratorSemicolon);continue}if(this.match(l.at)){i.push(this.parseDecorator());continue}const t=this.startNode();i.length&&(t.decorators=i,this.resetStartLocationFromNode(t,i[0]),i=[]),this.parseClassMember(r,t,s),\"constructor\"===t.kind&&t.decorators&&t.decorators.length>0&&this.raise(t.start,b.DecoratorConstructor)}})),this.state.strict=e,this.next(),i.length)throw this.raise(this.state.start,b.TrailingDecorator);return this.classScope.exit(),this.finishNode(r,\"ClassBody\")}parseClassMemberFromModifier(t,e){const s=this.parseIdentifier(!0);if(this.isClassMethod()){const i=e;return i.kind=\"method\",i.computed=!1,i.key=s,i.static=!1,this.pushClassMethod(t,i,!1,!1,!1,!1),!0}if(this.isClassProperty()){const i=e;return i.computed=!1,i.key=s,i.static=!1,t.body.push(this.parseClassProperty(i)),!0}return!1}parseClassMember(t,e,s){const i=this.isContextual(\"static\");if(i){if(this.parseClassMemberFromModifier(t,e))return;if(this.eat(l.braceL))return void this.parseClassStaticBlock(t,e,s)}this.parseClassMemberWithIsStatic(t,e,s,i)}parseClassMemberWithIsStatic(t,e,s,i){const r=e,a=e,n=e,o=e,h=r,p=r;if(e.static=i,this.eat(l.star))return h.kind=\"method\",this.parseClassElementName(h),this.isPrivateName(h.key)?void this.pushClassPrivateMethod(t,a,!0,!1):(this.isNonstaticConstructor(r)&&this.raise(r.key.start,b.ConstructorIsGenerator),void this.pushClassMethod(t,r,!0,!1,!1,!1));const c=this.state.containsEsc,u=this.parseClassElementName(e),d=this.isPrivateName(u),m=\"Identifier\"===u.type,f=this.state.start;if(this.parsePostMemberNameModifiers(p),this.isClassMethod()){if(h.kind=\"method\",d)return void this.pushClassPrivateMethod(t,a,!1,!1);const e=this.isNonstaticConstructor(r);let i=!1;e&&(r.kind=\"constructor\",s.hadConstructor&&!this.hasPlugin(\"typescript\")&&this.raise(u.start,b.DuplicateConstructor),s.hadConstructor=!0,i=s.constructorAllowsSuper),this.pushClassMethod(t,r,!1,!1,e,i)}else if(this.isClassProperty())d?this.pushClassPrivateProperty(t,o):this.pushClassProperty(t,n);else if(!m||\"async\"!==u.name||c||this.isLineTerminator())!m||\"get\"!==u.name&&\"set\"!==u.name||c||this.match(l.star)&&this.isLineTerminator()?this.isLineTerminator()?d?this.pushClassPrivateProperty(t,o):this.pushClassProperty(t,n):this.unexpected():(h.kind=u.name,this.parseClassElementName(r),this.isPrivateName(h.key)?this.pushClassPrivateMethod(t,a,!1,!1):(this.isNonstaticConstructor(r)&&this.raise(r.key.start,b.ConstructorIsAccessor),this.pushClassMethod(t,r,!1,!1,!1,!1)),this.checkGetterSetterParams(r));else{const e=this.eat(l.star);p.optional&&this.unexpected(f),h.kind=\"method\",this.parseClassElementName(h),this.parsePostMemberNameModifiers(p),this.isPrivateName(h.key)?this.pushClassPrivateMethod(t,a,e,!0):(this.isNonstaticConstructor(r)&&this.raise(r.key.start,b.ConstructorIsAsync),this.pushClassMethod(t,r,e,!0,!1,!1))}}parseClassElementName(t){const e=this.parsePropertyName(t,!0);return t.computed||!t.static||\"prototype\"!==e.name&&\"prototype\"!==e.value||this.raise(e.start,b.StaticPrototype),this.isPrivateName(e)&&\"constructor\"===this.getPrivateNameSV(e)&&this.raise(e.start,b.ConstructorClassPrivateField),e}parseClassStaticBlock(t,e,s){var i;this.expectPlugin(\"classStaticBlock\",e.start),this.scope.enter(208);const r=this.state.labels;this.state.labels=[],this.prodParam.enter(0);const a=e.body=[];this.parseBlockOrModuleBlockBody(a,void 0,!1,l.braceR),this.prodParam.exit(),this.scope.exit(),this.state.labels=r,t.body.push(this.finishNode(e,\"StaticBlock\")),s.hadStaticBlock&&this.raise(e.start,b.DuplicateStaticBlock),(null==(i=e.decorators)?void 0:i.length)&&this.raise(e.start,b.DecoratorStaticBlock),s.hadStaticBlock=!0}pushClassProperty(t,e){e.computed||\"constructor\"!==e.key.name&&\"constructor\"!==e.key.value||this.raise(e.key.start,b.ConstructorClassField),t.body.push(this.parseClassProperty(e))}pushClassPrivateProperty(t,e){this.expectPlugin(\"classPrivateProperties\",e.key.start);const s=this.parseClassPrivateProperty(e);t.body.push(s),this.classScope.declarePrivateName(this.getPrivateNameSV(s.key),0,s.key.start)}pushClassMethod(t,e,s,i,r,a){t.body.push(this.parseMethod(e,s,i,r,a,\"ClassMethod\",!0))}pushClassPrivateMethod(t,e,s,i){this.expectPlugin(\"classPrivateMethods\",e.key.start);const r=this.parseMethod(e,s,i,!1,!1,\"ClassPrivateMethod\",!0);t.body.push(r);const a=\"get\"===r.kind?r.static?6:2:\"set\"===r.kind?r.static?5:1:0;this.classScope.declarePrivateName(this.getPrivateNameSV(r.key),a,r.key.start)}parsePostMemberNameModifiers(t){}parseClassPrivateProperty(t){return this.parseInitializer(t),this.semicolon(),this.finishNode(t,\"ClassPrivateProperty\")}parseClassProperty(t){return t.typeAnnotation&&!this.match(l.eq)||this.expectPlugin(\"classProperties\"),this.parseInitializer(t),this.semicolon(),this.finishNode(t,\"ClassProperty\")}parseInitializer(t){this.scope.enter(80),this.expressionScope.enter(Ft()),this.prodParam.enter(0),t.value=this.eat(l.eq)?this.parseMaybeAssignAllowIn():null,this.expressionScope.exit(),this.prodParam.exit(),this.scope.exit()}parseClassId(t,e,s,i=139){this.match(l.name)?(t.id=this.parseIdentifier(),e&&this.checkLVal(t.id,\"class name\",i)):s||!e?t.id=null:this.unexpected(null,b.MissingClassName)}parseClassSuper(t){t.superClass=this.eat(l._extends)?this.parseExprSubscripts():null}parseExport(t){const e=this.maybeParseExportDefaultSpecifier(t),s=!e||this.eat(l.comma),i=s&&this.eatExportStar(t),r=i&&this.maybeParseExportNamespaceSpecifier(t),a=s&&(!r||this.eat(l.comma)),n=e||i;if(i&&!r)return e&&this.unexpected(),this.parseExportFrom(t,!0),this.finishNode(t,\"ExportAllDeclaration\");const o=this.maybeParseExportNamedSpecifiers(t);if(e&&s&&!i&&!o||r&&a&&!o)throw this.unexpected(null,l.braceL);let h;if(n||o?(h=!1,this.parseExportFrom(t,n)):h=this.maybeParseExportDeclaration(t),n||o||h)return this.checkExport(t,!0,!1,!!t.source),this.finishNode(t,\"ExportNamedDeclaration\");if(this.eat(l._default))return t.declaration=this.parseExportDefaultExpression(),this.checkExport(t,!0,!0),this.finishNode(t,\"ExportDefaultDeclaration\");throw this.unexpected(null,l.braceL)}eatExportStar(t){return this.eat(l.star)}maybeParseExportDefaultSpecifier(t){if(this.isExportDefaultSpecifier()){this.expectPlugin(\"exportDefaultFrom\");const e=this.startNode();return e.exported=this.parseIdentifier(!0),t.specifiers=[this.finishNode(e,\"ExportDefaultSpecifier\")],!0}return!1}maybeParseExportNamespaceSpecifier(t){if(this.isContextual(\"as\")){t.specifiers||(t.specifiers=[]);const e=this.startNodeAt(this.state.lastTokStart,this.state.lastTokStartLoc);return this.next(),e.exported=this.parseModuleExportName(),t.specifiers.push(this.finishNode(e,\"ExportNamespaceSpecifier\")),!0}return!1}maybeParseExportNamedSpecifiers(t){return!!this.match(l.braceL)&&(t.specifiers||(t.specifiers=[]),t.specifiers.push(...this.parseExportSpecifiers()),t.source=null,t.declaration=null,!0)}maybeParseExportDeclaration(t){return!!this.shouldParseExportDeclaration()&&(t.specifiers=[],t.source=null,t.declaration=this.parseExportDeclaration(t),!0)}isAsyncFunction(){if(!this.isContextual(\"async\"))return!1;const t=this.nextTokenStart();return!u.test(this.input.slice(this.state.pos,t))&&this.isUnparsedContextual(t,\"function\")}parseExportDefaultExpression(){const t=this.startNode(),e=this.isAsyncFunction();if(this.match(l._function)||e)return this.next(),e&&this.next(),this.parseFunction(t,5,e);if(this.match(l._class))return this.parseClass(t,!0,!0);if(this.match(l.at))return this.hasPlugin(\"decorators\")&&this.getPluginOption(\"decorators\",\"decoratorsBeforeExport\")&&this.raise(this.state.start,b.DecoratorBeforeExport),this.parseDecorators(!1),this.parseClass(t,!0,!0);if(this.match(l._const)||this.match(l._var)||this.isLet())throw this.raise(this.state.start,b.UnsupportedDefaultExport);{const t=this.parseMaybeAssignAllowIn();return this.semicolon(),t}}parseExportDeclaration(t){return this.parseStatement(null)}isExportDefaultSpecifier(){if(this.match(l.name)){const t=this.state.value;if(\"async\"===t&&!this.state.containsEsc||\"let\"===t)return!1;if((\"type\"===t||\"interface\"===t)&&!this.state.containsEsc){const t=this.lookahead();if(t.type===l.name&&\"from\"!==t.value||t.type===l.braceL)return this.expectOnePlugin([\"flow\",\"typescript\"]),!1}}else if(!this.match(l._default))return!1;const t=this.nextTokenStart(),e=this.isUnparsedContextual(t,\"from\");if(44===this.input.charCodeAt(t)||this.match(l.name)&&e)return!0;if(this.match(l._default)&&e){const e=this.input.charCodeAt(this.nextTokenStartSince(t+4));return 34===e||39===e}return!1}parseExportFrom(t,e){if(this.eatContextual(\"from\")){t.source=this.parseImportSource(),this.checkExport(t);const e=this.maybeParseImportAssertions();e&&(t.assertions=e)}else e?this.unexpected():t.source=null;this.semicolon()}shouldParseExportDeclaration(){if(this.match(l.at)&&(this.expectOnePlugin([\"decorators\",\"decorators-legacy\"]),this.hasPlugin(\"decorators\"))){if(!this.getPluginOption(\"decorators\",\"decoratorsBeforeExport\"))return!0;this.unexpected(this.state.start,b.DecoratorBeforeExport)}return\"var\"===this.state.type.keyword||\"const\"===this.state.type.keyword||\"function\"===this.state.type.keyword||\"class\"===this.state.type.keyword||this.isLet()||this.isAsyncFunction()}checkExport(t,e,s,i){if(e)if(s){if(this.checkDuplicateExports(t,\"default\"),this.hasPlugin(\"exportDefaultFrom\")){var r;const e=t.declaration;\"Identifier\"!==e.type||\"from\"!==e.name||e.end-e.start!==4||(null==(r=e.extra)?void 0:r.parenthesized)||this.raise(e.start,b.ExportDefaultFromAsIdentifier)}}else if(t.specifiers&&t.specifiers.length)for(let a=0,n=t.specifiers;a<n.length;a++){const t=n[a],{exported:e}=t,s=\"Identifier\"===e.type?e.name:e.value;if(this.checkDuplicateExports(t,s),!i&&t.local){const{local:e}=t;\"StringLiteral\"===e.type?this.raise(t.start,b.ExportBindingIsString,e.value,s):(this.checkReservedWord(e.name,e.start,!0,!1),this.scope.checkLocalExport(e))}}else if(t.declaration)if(\"FunctionDeclaration\"===t.declaration.type||\"ClassDeclaration\"===t.declaration.type){const e=t.declaration.id;if(!e)throw new Error(\"Assertion failure\");this.checkDuplicateExports(t,e.name)}else if(\"VariableDeclaration\"===t.declaration.type)for(let a=0,n=t.declaration.declarations;a<n.length;a++){const t=n[a];this.checkDeclaration(t.id)}if(this.state.decoratorStack[this.state.decoratorStack.length-1].length)throw this.raise(t.start,b.UnsupportedDecoratorExport)}checkDeclaration(t){if(\"Identifier\"===t.type)this.checkDuplicateExports(t,t.name);else if(\"ObjectPattern\"===t.type)for(let e=0,s=t.properties;e<s.length;e++){const t=s[e];this.checkDeclaration(t)}else if(\"ArrayPattern\"===t.type)for(let e=0,s=t.elements;e<s.length;e++){const t=s[e];t&&this.checkDeclaration(t)}else\"ObjectProperty\"===t.type?this.checkDeclaration(t.value):\"RestElement\"===t.type?this.checkDeclaration(t.argument):\"AssignmentPattern\"===t.type&&this.checkDeclaration(t.left)}checkDuplicateExports(t,e){this.state.exportedIdentifiers.indexOf(e)>-1&&this.raise(t.start,\"default\"===e?b.DuplicateDefaultExport:b.DuplicateExport,e),this.state.exportedIdentifiers.push(e)}parseExportSpecifiers(){const t=[];let e=!0;for(this.expect(l.braceL);!this.eat(l.braceR);){if(e)e=!1;else if(this.expect(l.comma),this.eat(l.braceR))break;const s=this.startNode();s.local=this.parseModuleExportName(),s.exported=this.eatContextual(\"as\")?this.parseModuleExportName():s.local.__clone(),t.push(this.finishNode(s,\"ExportSpecifier\"))}return t}parseModuleExportName(){if(this.match(l.string)){this.expectPlugin(\"moduleStringNames\");const t=this.parseLiteral(this.state.value,\"StringLiteral\"),e=t.value.match(jt);return e&&this.raise(t.start,b.ModuleExportNameHasLoneSurrogate,e[0].charCodeAt(0).toString(16)),t}return this.parseIdentifier(!0)}parseImport(t){if(t.specifiers=[],!this.match(l.string)){const e=!this.maybeParseDefaultImportSpecifier(t)||this.eat(l.comma),s=e&&this.maybeParseStarImportSpecifier(t);e&&!s&&this.parseNamedImportSpecifiers(t),this.expectContextual(\"from\")}t.source=this.parseImportSource();const e=this.maybeParseImportAssertions();if(e)t.assertions=e;else{const e=this.maybeParseModuleAttributes();e&&(t.attributes=e)}return this.semicolon(),this.finishNode(t,\"ImportDeclaration\")}parseImportSource(){return this.match(l.string)||this.unexpected(),this.parseExprAtom()}shouldParseDefaultImport(t){return this.match(l.name)}parseImportSpecifierLocal(t,e,s,i){e.local=this.parseIdentifier(),this.checkLVal(e.local,i,9),t.specifiers.push(this.finishNode(e,s))}parseAssertEntries(){const t=[],e=new Set;do{if(this.match(l.braceR))break;const s=this.startNode(),i=this.state.value;if(this.match(l.string)?s.key=this.parseLiteral(i,\"StringLiteral\"):s.key=this.parseIdentifier(!0),this.expect(l.colon),\"type\"!==i&&this.raise(s.key.start,b.ModuleAttributeDifferentFromType,i),e.has(i)&&this.raise(s.key.start,b.ModuleAttributesWithDuplicateKeys,i),e.add(i),!this.match(l.string))throw this.unexpected(this.state.start,b.ModuleAttributeInvalidValue);s.value=this.parseLiteral(this.state.value,\"StringLiteral\"),this.finishNode(s,\"ImportAttribute\"),t.push(s)}while(this.eat(l.comma));return t}maybeParseModuleAttributes(){if(!this.match(l._with)||this.hasPrecedingLineBreak())return this.hasPlugin(\"moduleAttributes\")?[]:null;this.expectPlugin(\"moduleAttributes\"),this.next();const t=[],e=new Set;do{const s=this.startNode();if(s.key=this.parseIdentifier(!0),\"type\"!==s.key.name&&this.raise(s.key.start,b.ModuleAttributeDifferentFromType,s.key.name),e.has(s.key.name)&&this.raise(s.key.start,b.ModuleAttributesWithDuplicateKeys,s.key.name),e.add(s.key.name),this.expect(l.colon),!this.match(l.string))throw this.unexpected(this.state.start,b.ModuleAttributeInvalidValue);s.value=this.parseLiteral(this.state.value,\"StringLiteral\"),this.finishNode(s,\"ImportAttribute\"),t.push(s)}while(this.eat(l.comma));return t}maybeParseImportAssertions(){if(!this.isContextual(\"assert\")||this.hasPrecedingLineBreak())return this.hasPlugin(\"importAssertions\")?[]:null;this.expectPlugin(\"importAssertions\"),this.next(),this.eat(l.braceL);const t=this.parseAssertEntries();return this.eat(l.braceR),t}maybeParseDefaultImportSpecifier(t){return!!this.shouldParseDefaultImport(t)&&(this.parseImportSpecifierLocal(t,this.startNode(),\"ImportDefaultSpecifier\",\"default import specifier\"),!0)}maybeParseStarImportSpecifier(t){if(this.match(l.star)){const e=this.startNode();return this.next(),this.expectContextual(\"as\"),this.parseImportSpecifierLocal(t,e,\"ImportNamespaceSpecifier\",\"import namespace specifier\"),!0}return!1}parseNamedImportSpecifiers(t){let e=!0;for(this.expect(l.braceL);!this.eat(l.braceR);){if(e)e=!1;else{if(this.eat(l.colon))throw this.raise(this.state.start,b.DestructureNamedImport);if(this.expect(l.comma),this.eat(l.braceR))break}this.parseImportSpecifier(t)}}parseImportSpecifier(t){const e=this.startNode();if(e.imported=this.parseModuleExportName(),this.eatContextual(\"as\"))e.local=this.parseIdentifier();else{const{imported:t}=e;if(\"StringLiteral\"===t.type)throw this.raise(e.start,b.ImportBindingIsString,t.value);this.checkReservedWord(t.name,e.start,!0,!0),e.local=t.__clone()}this.checkLVal(e.local,\"import specifier\",9),t.specifiers.push(this.finishNode(e,\"ImportSpecifier\"))}}{constructor(t,e){super(t=function(t){const e={};for(let s=0,i=Object.keys(wt);s<i.length;s++){const r=i[s];e[r]=t&&null!=t[r]?t[r]:wt[r]}return e}(t),e);const s=this.getScopeHandler();this.options=t,this.inModule=\"module\"===this.options.sourceType,this.scope=new s(this.raise.bind(this),this.inModule),this.prodParam=new lt,this.classScope=new qt(this.raise.bind(this)),this.expressionScope=new Ot(this.raise.bind(this)),this.plugins=function(t){const e=new Map;for(let s=0;s<t.length;s++){const i=t[s],[r,a]=Array.isArray(i)?i:[i,{}];e.has(r)||e.set(r,a||{})}return e}(this.options.plugins),this.filename=t.sourceFilename}getScopeHandler(){return X}parse(){let t=0;this.hasPlugin(\"topLevelAwait\")&&this.inModule&&(t|=2),this.scope.enter(1),this.prodParam.enter(t);const e=this.startNode(),s=this.startNode();return this.nextToken(),e.errors=null,this.parseTopLevel(e,s),e.errors=this.state.errors,e}}function zt(t,e){let s=Vt;return(null==t?void 0:t.plugins)&&(!function(t){if(xt(t,\"decorators\")){if(xt(t,\"decorators-legacy\"))throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");const e=Pt(t,\"decorators\",\"decoratorsBeforeExport\");if(null==e)throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.\");if(\"boolean\"!==typeof e)throw new Error(\"'decoratorsBeforeExport' must be a boolean.\")}if(xt(t,\"flow\")&&xt(t,\"typescript\"))throw new Error(\"Cannot combine flow and typescript plugins.\");if(xt(t,\"placeholders\")&&xt(t,\"v8intrinsic\"))throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");if(xt(t,\"pipelineOperator\")&&!gt.includes(Pt(t,\"pipelineOperator\",\"proposal\")))throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \"+gt.map((t=>`'${t}'`)).join(\", \"));if(xt(t,\"moduleAttributes\")){if(xt(t,\"importAssertions\"))throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");if(\"may-2020\"!==Pt(t,\"moduleAttributes\",\"version\"))throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.\")}if(xt(t,\"recordAndTuple\")&&!bt.includes(Pt(t,\"recordAndTuple\",\"syntaxType\")))throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \"+bt.map((t=>`'${t}'`)).join(\", \"))}(t.plugins),s=function(t){const e=At.filter((e=>xt(t,e))),s=e.join(\"/\");let i=Ht[s];if(!i){i=Vt;for(let t=0;t<e.length;t++){const s=e[t];i=Tt[s](i)}Ht[s]=i}return i}(t.plugins)),new s(t,e)}const Ht={};e.parse=function(t,e){var s;if(\"unambiguous\"!==(null==(s=e)?void 0:s.sourceType))return zt(e,t).parse();e=Object.assign({},e);try{e.sourceType=\"module\";const s=zt(e,t),r=s.parse();if(s.sawUnambiguousESM)return r;if(s.ambiguousScriptDifferentAst)try{return e.sourceType=\"script\",zt(e,t).parse()}catch(i){}else r.program.sourceType=\"script\";return r}catch(r){try{return e.sourceType=\"script\",zt(e,t).parse()}catch(a){}throw r}},e.parseExpression=function(t,e){const s=zt(e,t);return s.options.strictMode&&(s.state.strict=!0),s.getExpression()},e.tokTypes=l}}]);","map":{"version":3,"sources":["static/chunks/d57d79ab.396036635ece3758450a.js"],"names":["window","push","GGH7","module","exports","__webpack_require__","Object","defineProperty","value","beforeExpr","startsExpr","isLoop","prefix","TokenType","[object Object]","label","conf","this","keyword","rightAssociative","isAssign","postfix","binop","updateContext","keywords","Map","createKeyword","name","options","token","set","createBinop","types","num","bigint","decimal","regexp","string","eof","bracketL","bracketHashL","bracketBarL","bracketR","bracketBarR","braceL","braceBarL","braceHashL","braceR","braceBarR","parenL","parenR","comma","semi","colon","doubleColon","dot","question","questionDot","arrow","template","ellipsis","backQuote","dollarBraceL","at","hash","interpreterDirective","eq","assign","incDec","bang","tilde","pipeline","nullishCoalescing","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","exponent","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","RegExp","source","isNewLine","code","skipWhiteSpace","isWhitespace","Position","line","col","column","SourceLocation","start","end","filename","identifierName","last","stack","length","ErrorMessages","freeze","AccessorIsGenerator","ArgumentsInClass","AsyncFunctionInSingleStatementContext","AwaitBindingIdentifier","AwaitBindingIdentifierInStaticBlock","AwaitExpressionFormalParameter","AwaitNotInAsyncContext","AwaitNotInAsyncFunction","BadGetterArity","BadSetterArity","BadSetterRestParameter","ConstructorClassField","ConstructorClassPrivateField","ConstructorIsAccessor","ConstructorIsAsync","ConstructorIsGenerator","DeclarationMissingInitializer","DecoratorBeforeExport","DecoratorConstructor","DecoratorExportClass","DecoratorSemicolon","DecoratorStaticBlock","DeletePrivateField","DestructureNamedImport","DuplicateConstructor","DuplicateDefaultExport","DuplicateExport","DuplicateProto","DuplicateRegExpFlags","DuplicateStaticBlock","ElementAfterRest","EscapedCharNotAnIdentifier","ExportBindingIsString","ExportDefaultFromAsIdentifier","ForInOfLoopInitializer","GeneratorInSingleStatementContext","IllegalBreakContinue","IllegalLanguageModeDirective","IllegalReturn","ImportBindingIsString","ImportCallArgumentTrailingComma","ImportCallArity","ImportCallNotNewExpression","ImportCallSpreadArgument","ImportMetaOutsideModule","ImportOutsideModule","InvalidBigIntLiteral","InvalidCodePoint","InvalidDecimal","InvalidDigit","InvalidEscapeSequence","InvalidEscapeSequenceTemplate","InvalidEscapedReservedWord","InvalidIdentifier","InvalidLhs","InvalidLhsBinding","InvalidNumber","InvalidOrMissingExponent","InvalidOrUnexpectedToken","InvalidParenthesizedAssignment","InvalidPrivateFieldResolution","InvalidPropertyBindingPattern","InvalidRecordProperty","InvalidRestAssignmentPattern","LabelRedeclaration","LetInLexicalBinding","LineTerminatorBeforeArrow","MalformedRegExpFlags","MissingClassName","MissingEqInAssignment","MissingSemicolon","MissingUnicodeEscape","MixingCoalesceWithLogical","ModuleAttributeDifferentFromType","ModuleAttributeInvalidValue","ModuleAttributesWithDuplicateKeys","ModuleExportNameHasLoneSurrogate","ModuleExportUndefined","MultipleDefaultsInSwitch","NewlineAfterThrow","NoCatchOrFinally","NumberIdentifier","NumericSeparatorInEscapeSequence","ObsoleteAwaitStar","OptionalChainingNoNew","OptionalChainingNoTemplate","ParamDupe","PatternHasAccessor","PatternHasMethod","PipelineBodyNoArrow","PipelineBodySequenceExpression","PipelineHeadSequenceExpression","PipelineTopicUnused","PrimaryTopicNotAllowed","PrimaryTopicRequiresSmartPipeline","PrivateInExpectedIn","PrivateNameRedeclaration","RecordExpressionBarIncorrectEndSyntaxType","RecordExpressionBarIncorrectStartSyntaxType","RecordExpressionHashIncorrectStartSyntaxType","RecordNoProto","RestTrailingComma","SloppyFunction","StaticPrototype","StrictDelete","StrictEvalArguments","StrictEvalArgumentsBinding","StrictFunction","StrictNumericEscape","StrictOctalLiteral","StrictWith","SuperNotAllowed","SuperPrivateField","TrailingDecorator","TupleExpressionBarIncorrectEndSyntaxType","TupleExpressionBarIncorrectStartSyntaxType","TupleExpressionHashIncorrectStartSyntaxType","UnexpectedArgumentPlaceholder","UnexpectedAwaitAfterPipelineBody","UnexpectedDigitAfterHash","UnexpectedImportExport","UnexpectedKeyword","UnexpectedLeadingDecorator","UnexpectedLexicalDeclaration","UnexpectedNewTarget","UnexpectedNumericSeparator","UnexpectedPrivateField","UnexpectedReservedWord","UnexpectedSuper","UnexpectedToken","UnexpectedTokenUnaryExponentiation","UnsupportedBind","UnsupportedDecoratorExport","UnsupportedDefaultExport","UnsupportedImport","UnsupportedMetaProperty","UnsupportedParameterDecorator","UnsupportedPropertyDecorator","UnsupportedSuper","UnterminatedComment","UnterminatedRegExp","UnterminatedString","UnterminatedTemplate","VarRedeclaration","YieldBindingIdentifier","YieldInParameter","ZeroDigitNumericSeparator","TokContext","isExpr","preserveSpace","override","types$1","braceStatement","braceExpression","recordExpression","templateQuasi","parenStatement","parenExpression","p","readTmplToken","functionExpression","functionStatement","state","context","exprAllowed","out","pop","curContext","prevType","allowed","isIterator","braceIsBlock","statementParens","hasPrecedingLineBreak","b_stat","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","pos","i","isIdentifierStart","test","String","fromCharCode","isIdentifierChar","reservedWords","keywords$1","Set","reservedWordsStrictSet","reservedWordsStrictBindSet","isReservedWord","word","inModule","isStrictReservedWord","has","isStrictBindOnlyReservedWord","isStrictBindReservedWord","isKeyword","keywordRelationalOperator","SCOPE_TS_MODULE","BIND_FLAGS_CLASS","BIND_FLAGS_TS_EXPORT_ONLY","BIND_FLAGS_FLOW_DECLARE_FN","Scope","flags","var","lexical","functions","ScopeHandler","raise","scopeStack","undefinedExports","undefinedPrivateNames","inFunction","currentVarScope","allowSuper","currentThisScope","allowDirectSuper","inClass","inStaticBlock","inNonArrowFunction","treatFunctionsAsVar","treatFunctionsAsVarInScope","currentScope","createScope","scope","bindingType","checkRedeclarationInScope","maybeExportDefined","SCOPE_PROGRAM","delete","isRedeclaredInScope","indexOf","id","FlowScope","args","super","declareFunctions","FlowScopeHandler","declareName","arguments","includes","checkLocalExport","reservedTypes","FlowErrors","AmbiguousConditionalArrow","AmbiguousDeclareModuleKind","AssignReservedType","DeclareClassElement","DeclareClassFieldInitializer","DuplicateDeclareModuleExports","EnumBooleanMemberNotInitialized","EnumDuplicateMemberName","EnumInconsistentMemberValues","EnumInvalidExplicitType","EnumInvalidExplicitTypeUnknownSupplied","EnumInvalidMemberInitializerPrimaryType","EnumInvalidMemberInitializerSymbolType","EnumInvalidMemberInitializerUnknownType","EnumInvalidMemberName","EnumNumberMemberNotInitialized","EnumStringMemberInconsistentlyInitailized","ImportTypeShorthandOnlyInPureImport","InexactInsideExact","InexactInsideNonObject","InexactVariance","InvalidNonTypeImportInDeclareModule","MissingTypeParamDefault","NestedDeclareModule","NestedFlowComment","OptionalBindingPattern","SpreadVariance","TypeBeforeInitializer","TypeCastInPattern","UnexpectedExplicitInexactInObject","UnexpectedReservedType","UnexpectedReservedUnderscore","UnexpectedSpaceBetweenModuloChecks","UnexpectedSpreadType","UnexpectedSubtractionOperand","UnexpectedTokenAfterTypeParameter","UnexpectedTypeParameterBeforeAsyncArrowFunction","UnsupportedDeclareExportKind","UnsupportedStatementInDeclareModule","UnterminatedFlowComment","hasTypeImportKind","node","importKind","isMaybeDefaultImport","type","exportSuggestions","const","let","interface","FLOW_PRAGMA_REGEX","entities","quot","amp","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","HEX_NUMBER","DECIMAL_NUMBER","JsxErrors","AttributeIsEmpty","MissingClosingTagFragment","MissingClosingTagElement","UnexpectedSequenceExpression","UnsupportedJsxValue","UnterminatedJsxContent","UnwrappedAdjacentJSXElements","isFragment","object","getQualifiedJSXName","namespace","property","Error","j_oTag","j_cTag","j_expr","jsxName","jsxText","jsxTagStart","jsxTagEnd","TypeScriptScope","enums","constEnums","classes","exportOnlyBindings","TypeScriptScopeHandler","ProductionParameterHandler","stacks","hasAwait","currentFlags","hasYield","hasReturn","hasIn","functionFlags","isAsync","isGenerator","nonNull","x","assert","TSErrors","ClassMethodHasDeclare","ClassMethodHasReadonly","ConstructorHasTypeParameters","DeclareClassFieldHasInitializer","DeclareFunctionHasImplementation","DuplicateModifier","DuplicateAccessibilityModifier","EmptyHeritageClauseType","EmptyTypeArguments","EmptyTypeParameters","ExpectedAmbientAfterExportDeclare","IndexSignatureHasAbstract","IndexSignatureHasAccessibility","IndexSignatureHasStatic","IndexSignatureHasDeclare","InvalidModifierOnTypeMember","InvalidTupleMemberLabel","MixedLabeledAndUnlabeledElements","NonAbstractClassHasAbstractMethod","NonClassMethodPropertyHasAbstractModifer","OptionalTypeBeforeRequired","PatternIsOptional","PrivateElementHasAbstract","PrivateElementHasAccessibility","ReadonlyForMethodSignature","TypeAnnotationAfterAssign","UnexpectedParameterModifier","UnexpectedReadonly","UnexpectedTypeAnnotation","UnexpectedTypeCastInParameter","UnsupportedImportTypeArgument","UnsupportedParameterPropertyKind","UnsupportedSignatureParameterKind","tsIsAccessModifier","modifier","placeholder","hasPlugin","plugins","some","plugin","Array","isArray","getPluginOption","option","find","PIPELINE_PROPOSALS","RECORD_AND_TUPLE_SYNTAX_TYPES","mixinPlugins","estree","superClass","pattern","regex","e","estreeParseLiteral","bigInt","BigInt","_unused","parseLiteral","directive","directiveLiteral","stmt","startNodeAt","loc","expression","extra","expressionValue","raw","finishNodeAt","slice","initFunction","isObjectProperty","checkDeclaration","method","params","_stmt$expression$extr","parenthesized","stmtToDirective","addExtra","parseBlockBody","directiveStatements","directives","map","d","directiveToStmt","body","concat","classBody","isConstructor","allowsDirectSuper","parseMethod","typeParameters","refExpressionErrors","estreeParseRegExpLiteral","estreeParseBigIntLiteral","estreeParseDecimalLiteral","parseExprAtom","startPos","startLoc","allowExpression","isMethod","parseFunctionBody","inClassScope","funcNode","startNode","kind","finishNode","isPattern","isAccessor","parseObjectMethod","shorthand","parseObjectProperty","isLHS","toAssignable","key","toAssignableObjectExpressionProp","optional","finishCallExpression","callee","toReferencedArguments","parseExport","exported","specifiers","base","noCalls","parseSubscript","optionalChainMember","substring","stop","chain","startNodeAtNode","hasPropertyAsPrivateName","jsx","chunkStart","ch","input","charCodeAt","finishToken","getTokenFromCode","jsxReadEntity","jsxReadNewLine","normalizeCRLF","curLine","lineStart","quote","entity","str","count","substr","fromCodePoint","parseInt","match","unexpected","next","jsxParseIdentifier","eat","jsxParseNamespacedName","newNode","jsxParseExpressionContainer","lastTokEnd","lastTokEndLoc","parseExpression","expect","jsxParseEmptyExpression","argument","parseMaybeAssignAllowIn","jsxParseAttributeValue","jsxParseElementName","jsxParseOpeningElementAfterName","attributes","jsxParseAttribute","selfClosing","children","openingElement","jsxParseOpeningElementAt","closingElement","contents","jsxParseClosingElementAt","jsxParseElementAt","jsxParseSpreadChild","openingFragment","closingFragment","isRelational","jsxParseElement","inPropertyName","jsxReadToken","jsxReadWord","jsxReadString","flow","flowPragma","undefined","val","comment","matches","exec","addComment","tok","oldInType","inType","flowParseType","moduloLoc","moduloPos","checksLoc","expectContextual","predicate","flowParsePredicate","flowParseInterfaceish","parseIdentifier","typeNode","typeContainer","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","rest","returnType","flowParseTypeAndPredicateInitialiser","typeAnnotation","resetEndLocation","semicolon","insideModule","flowParseDeclareClass","flowParseDeclareFunction","flowParseDeclareVariable","eatContextual","flowParseDeclareModuleExports","lastTokStart","flowParseDeclareModule","isContextual","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","flowParseTypeAnnotatableIdentifier","BIND_KIND_VALUE","enter","bodyNode","parseImport","flowParseDeclare","exit","hasModuleExport","forEach","bodyElement","declaration","isEsModuleType","default","isLet","suggestion","exportKind","flowParseTypeAnnotation","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","extends","implements","mixins","flowParseInterfaceExtends","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","liberal","checkReservedType","right","flowParseTypeInitialiser","declare","supertype","impltype","requireDefault","nodeStart","variance","flowParseVariance","ident","bound","defaultRequired","typeParameter","flowParseTypeParameter","expectRelational","oldNoAnonFunctionType","noAnonFunctionType","flowParseTypeOrImplicitInstantiation","isStatic","static","lookahead","flowParseObjectPropertyKey","flowParseObjectTypeMethodish","flowParseFunctionTypeParam","valueNode","endDelim","exact","callProperties","properties","indexers","internalSlots","inexact","protoStart","inexactStart","flowParseObjectTypeInternalSlot","flowParseObjectTypeIndexer","flowParseObjectTypeCallProperty","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","proto","flowCheckGetterSetterParams","paramCount","node2","qualification","flowParsePrimaryType","lh","checkNotUnderscore","flowParseGenericType","isGroupedType","flowParseInterfaceType","flowIdentToTypeAnnotation","flowParseTupleType","reinterpretTypeAsFunctionTypeParam","flowParseTypeofType","createIdentifier","canInsertSemicolon","elementType","flowParsePrefixType","flowParsePostfixType","param","flowParseAnonFunctionWithoutParens","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","allowExpressionBody","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","topLevel","strict","flowParseInterface","shouldParseEnums","flowParseEnumDeclaration","parseStatement","isValidDirective","expr","parseExpressionStatement","shouldParseExportDeclaration","isExportDefaultSpecifier","parseExportDefaultExpression","refNeedsArrowPos","result","tryParse","parseConditional","error","failState","clone","originalNoArrowAt","noArrowAt","consequent","failed","tryParseConditionalConsequent","valid","invalid","getArrowLikeExpressions","alternate","parseMaybeAssign","noArrowParamsConversionAt","disallowInvalid","arrows","finishArrowValidation","list","list1","list2","partition","every","isAssignable","_node$extra","toAssignableList","trailingComma","SCOPE_FUNCTION","checkParams","parse","parseParenItem","typeCastNode","assertModuleNodeAllowed","decl","declarationNode","parseExportSpecifiers","parseExportFrom","parseExportDeclaration","eatExportStar","hasNamespace","maybeParseExportNamespaceSpecifier","isStatement","optionalId","parseClassId","member","parseClassMemberFromModifier","parseClassMember","finishOp","current","isIteratorStart","readWord","isBinding","elements","element","operator","typeCastToParameter","exprList","trailingCommaPos","isParenthesizedExpr","_expr$extra","close","canBePattern","isTuple","parseArrayLike","maybeInArrowParameters","toReferencedList","checkLVal","parseClassProperty","parseClassPrivateProperty","isClassMethod","isClassProperty","isNonstaticConstructor","pushClassMethod","pushClassPrivateMethod","parseClassSuper","superTypeParameters","implemented","isPrivateNameAllowed","parsePropertyName","parseObjPropValue","left","parseMaybeDefault","shouldParseDefaultImport","specifier","contextDescription","local","maybeParseDefaultImportSpecifier","firstIdentLoc","firstIdent","parseModuleExportName","specifierTypeKind","isLookaheadContextual","as_ident","imported","__clone","nodeIsTypeImport","specifierIsTypeImport","checkReservedWord","allowModifiers","parseFunctionParams","parseVarId","call","parseAsyncArrowFromCallExpression","shouldParseAsyncArrow","afterLeftParse","_jsx","_jsx2","_jsx3","abort","_arrowExpression$extr","arrowExpression","resetStartLocationFromNode","maybeUnwrapTypeCastExpression","aborted","async","thrown","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","canBeArrow","parseParenAndDistinguishExpression","parseCallExpressionArguments","parseAsyncArrowWithTypeParameters","parseSubscripts","subscriptState","isLookaheadToken_lt","typeArguments","shouldParseTypes","flowParseTypeParameterInstantiationCallOrNew","targs","parseNewArguments","parseArrowExpression","hasFlowComment","nextToken","readToken_mult_modulo","readToken_pipe_amp","file","program","fileNode","parseTopLevel","skipFlowComment","hasFlowCommentCompletion","skipBlockComment","shiftToFirstNonWhiteSpace","ch2","ch3","enumName","memberName","toUpperCase","suppliedType","explicitType","message","endOfInit","literal","parseBooleanLiteral","init","flowEnumMemberInit","expectedType","flowEnumErrorInvalidMemberInitializer","seenNames","members","booleanMembers","numberMembers","stringMembers","defaultedMembers","memberNode","flowEnumMemberRaw","flowEnumErrorInvalidMemberName","flowEnumErrorDuplicateMemberName","add","flowEnumCheckExplicitTypeMismatch","flowEnumErrorBooleanMemberNotInitialized","flowEnumErrorNumberMemberNotInitialized","initializedMembers","_i","flowEnumErrorStringMemberInconsistentlyInitailized","_i2","flowEnumErrorInvalidExplicitType","nameLoc","flowEnumParseExplicitType","flowEnumMembers","flowEnumStringMembers","boolsLen","numsLen","strsLen","defaultedLen","_i3","_members$defaultedMem","_i4","_members$defaultedMem2","flowEnumErrorInconsistentMemberValues","flowEnumBody","nextTokenStart","afterNext","typescript","isLiteralPropertyName","allowedModifiers","tsTryParse","tsNextTokenCanFollowModifier","bind","modified","disallowedModifiers","errorTemplate","tsParseModifier","accessibility","hasOwnProperty","parseElement","tsIsListTerminator","tsParseDelimitedListWorker","expectSuccess","bracket","skipFirstToken","tsParseDelimitedList","qualifier","tsParseEntityName","tsParseTypeArguments","allowReservedWords","typeName","lhs","parameterName","tsParseTypeAnnotation","asserts","exprName","tsParseImportType","parseIdentifierName","constraint","tsEatThenParseType","tsParseTypeParameters","tsParseBracketedList","tsParseTypeParameter","tsParseTypeReference","returnToken","signature","returnTokenRequired","tsTryParseTypeParameters","parameters","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","parseBindingList","tsFillSignature","tsParseTypeMemberSemicolon","tsLookAhead","tsIsUnambiguouslyIndexSignature","tsTryParseTypeAnnotation","readonly","nodeAny","tsParseSignatureMember","tsParsePropertyOrMethodSignature","tsParseModifiers","idx","tsTryParseIndexSignature","tsParseObjectTypeMembers","tsParseList","tsParseTypeMember","tsIsIdentifier","tsExpectThenParseType","tsParseMappedTypeParameter","nameType","tsParseType","tsTryParseType","elementTypes","tsParseTupleElementType","seenOptionalElement","labeledElements","elementNode","_labeledElements","isLabeled","labeledNode","optionalTypeNode","restNode","parseTemplate","parseTemplateSubstitution","thisKeyword","tsParseThisTypeNode","tsParseThisTypePredicate","keywordTypeFromName","lookaheadCharCode","tsParseLiteralTypeNode","parseMaybeUnary","tsParseThisTypeOrThisTypePredicate","tsParseTypeQuery","tsIsStartOfMappedType","tsParseMappedType","tsParseTypeLiteral","tsParseTupleType","tsParseParenthesizedType","tsParseTemplateLiteralType","tsParseNonArrayType","objectType","indexType","tsParseTypeOperatorOrHigher","tsCheckTypeAnnotationForReadOnly","kw","tsParseTypeOperator","tsParseInferType","tsParseArrayTypeOrHigher","parseConstituentType","hasLeadingOperator","tsParseUnionOrIntersectionType","tsParseIntersectionTypeOrHigher","tsIsUnambiguouslyStartOfFunctionType","braceStackCounter","tsSkipParameterStart","tsInType","t","tsParseTypePredicateAsserts","thisTypePredicate","typePredicateVariable","tsParseTypePredicatePrefix","containsEsc","eatColon","tsParseNonConditionalType","checkType","extendsType","trueType","falseType","tsIsStartOfFunctionType","tsParseFunctionOrConstructorType","tsParseUnionTypeOrHigher","tsTryNextParseConstantContext","tsNextThenParseType","descriptor","originalStart","delimitedList","tsParseExpressionWithTypeArguments","tsParseHeritageClause","cb","oldContext","tsDoThenParseType","initializer","isConst","BIND_TS_ENUM","tsParseEnumMember","parseBlockOrModuleBlockBody","nested","inner","tsParseModuleOrNamespaceDeclaration","prodParam","tsParseModuleBlock","global","isExport","moduleReference","tsParseModuleReference","tsIsExternalModuleReference","tsParseExternalModuleReference","f","res","nany","isLineTerminator","starttype","tsInDeclareContext","parseFunctionStatement","parseClass","tsParseEnumDeclaration","parseVarStatement","tsParseAmbientExternalModuleDeclaration","tsParseDeclaration","tsTryParseDeclare","mod","tsCheckLineTerminator","tsParseAbstractDeclaration","tsParseInterfaceDeclaration","tsParseTypeAliasDeclaration","hasFollowingLineBreak","oldMaybeInArrowParameters","tsTryParseAndCatch","tsTryParseTypeOrTypePredicateAnnotation","tsInNoContext","tsIsDeclarationStart","decorators","parseAccessModifier","parseAssignableListItemTypes","elt","pp","parameter","bodilessType","isDeclareContext","registerFunctionStatementId","items","isInParens","tsCheckForInvalidTypeCasts","nonNullExpression","atPossibleAsyncArrow","asyncArrowFn","tsTryParseGenericAsyncArrowFunction","parseTaggedTemplateExpression","leftStartPos","leftStartLoc","minPrec","reScan_lt_gt","parseExprOp","checkKeywords","ahead","tsParseImportEqualsDeclaration","importNode","isAbstractClass","cls","abstract","parseStatementContent","callParseClassMember","inAbstractClass","parseClassMemberWithIsStatic","methodOrProp","tsParseExpressionStatement","isDeclare","tsTryParseExportDeclaration","resetStartLocation","definite","parseClassPropertyAnnotation","_typeCast","_typeCast2","_jsx4","_typeCast3","typeCast","_typeParameters","tsParseTypeAssertion","parseBindingAtom","parseMaybeDecoratorArguments","readToken_lt_gt","canHaveLeadingDecorator","baseCount","getGetterSetterExpectedParamCount","firstParam","getObjectOrClassMethodParams","parseCatchClauseParam","oldIsDeclareContext","oldInAbstractClass","v8intrinsic","v8IntrinsicStart","identifier","parseV8Intrinsic","placeholders","expectedNode","assertNoSpace","finishPlaceholder","isFinished","parsePlaceholder","verifyBreakContinue","parseBlock","parseFunctionId","takeDecorators","oldStrict","parseClassBody","expectPlugin","isUnparsedContextual","startsWith","nextTokenStartSince","maybeParseExportDefaultSpecifier","filter","checkExport","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","parseImportSource","mixinPluginNames","keys","defaultOptions","sourceType","sourceFilename","startLine","allowAwaitOutsideFunction","allowReturnOutsideFunction","allowImportExportEverywhere","allowSuperOutsideMethod","allowUndeclaredExports","strictMode","ranges","tokens","createParenthesizedExpressions","errorRecovery","State","endLoc","errors","potentialArrowAt","inPipeline","topicContext","maxNumOfResolvableTopics","maxTopicIndex","soloAwait","inFSharpPipelineDirectBody","labels","decoratorStack","comments","trailingComments","leadingComments","commentStack","commentPreviousNode","lastTokStartLoc","strictErrors","exportedIdentifiers","tokensLength","curPosition","skipArrays","_isDigit","VALID_REGEX_FLAGS","forbiddenNumericSeparatorSiblings","decBinOct","hex","allowedNumericSeparatorSiblings","bin","oct","dec","Token","ExpressionErrors","shorthandAssign","doubleProto","Node","parser","range","innerComments","unwrapParenthesizedExpression","ExpressionScope","ArrowHeadParsingScope","iterator","ExpressionScopeHandler","isCertainlyParameterDeclaration","canBeArrowParameterDeclaration","recordDeclarationError","iterateErrors","clearDeclarationError","newExpressionScope","loopLabel","switchLabel","loneSurrogate","ClassScope","privateNames","loneAccessors","ClassScopeHandler","oldClassScope","_Array$from","from","classScope","redefined","CLASS_ELEMENT_KIND_GETTER","accessor","get","oldStatic","newStatic","_this$stack","Parser","sawUnambiguousESM","ambiguousScriptDifferentAst","takeAllComments","lastElement","j","splice","newTrailingComments","leadingComment","firstChild","lastChild","lastInStack","adjustCommentsAfterTrailingComma","firstTrailingCommentIndex","findIndex","offset","lastIndex","index","getLineInfo","raiseWithData","getLocationForPosition","replace","_","_raise","data","errorContext","err","SyntaxError","isLookahead","checkKeywordEscapes","pushToken","old","curr","clear","skipSpace","codePointAt","block","text","pushComment","startSkip","loop","skipLineComment","readToken_interpreter","nextPos","readNumber","readRegexp","width","size","next2","readToken_dot","readToken_question","readRadixNumber","readString","readToken_slash","readToken_caret","readToken_plus_min","readToken_eq_excl","readToken_numberSign","escaped","charAt","content","mods","char","charCode","radix","len","forceLen","allowNumSeparator","forbiddenSiblings","allowedSiblings","total","Infinity","prev","Number","isNaN","isBigInt","readInt","startsWithDot","isFloat","isDecimal","hasExponent","isOctal","hasLeadingZero","integer","recordStrictModeErrors","underscorePos","parseFloat","throwOnInvalid","codePos","readHexChar","readEscapedChar","containsInvalid","inTemplate","readCodePoint","octalStr","octal","n","escStart","identifierCheck","esc","readWord1","parent","update","op","nameStart","nameEnd","allowAsi","messageOrType","missingPlugin","names","join","fn","oldState","abortSignal","andThrow","isPrivateName","processComment","locationNode","_node$extra3","expressionScope","recordParenthesizedIdentifierError","_node$extra2","isLast","raiseRestNotLast","checkToRestConversion","arg","raiseTrailingCommaAfterRest","toReferencedListDeep","parseObjectLike","closeCharCode","allowEmpty","elts","first","parseRestBinding","checkCommaAfterRest","parseDecorator","parseAssignableListItem","_startLoc","_startPos","_left","checkClashes","disallowLetBinding","strictModeChanged","_expr$properties","isObjectMethod","_expr$elements","elem","isRecord","protoRef","computed","used","paramFlags","disallowIn","disallowInAnd","parseExpressionBase","allowInAnd","expressions","parseYield","ownExpressionErrors","parseMaybeConditional","checkExpressionErrors","parseExprOps","shouldExitDescending","prec","checkPipelineAtInfixOperator","logical","coalesce","parseExprOpRightExpr","nextOp","withTopicPermittingContext","parseSmartPipelineBody","parseExprOpBaseRightExpr","withSoloAwaitPermittingContext","parseFSharpPipelineBody","isAwait","isAwaitAllowed","parseAwait","isDelete","parseUpdate","isAmbiguousAwait","raiseOverwrite","parseExprSubscripts","maybeAsyncArrow","parseBind","parseCoverCallAndAsyncArrowHead","parseMember","parseMaybePrivateName","usePrivateName","getPrivateNameSV","parseNoCallExpr","validateAsPattern","tag","quasi","_node$arguments","possibleAsyncArrow","dynamicImport","allowPlaceholder","nodeForExtra","oldInFSharpPipelineDirectBody","parseExprListItem","_call$extra","parseSuper","parseImportMetaProperty","parseFunction","parseAsyncArrowUnaryFunction","parseDo","parseFunctionOrFunctionSent","parseDecorators","parseNewOrNewTarget","primaryTopicReferenceIsAllowedInCurrentTopicContext","registerTopicReference","nextCh","lookaheadCh","expectOnePlugin","oldLabels","meta","parseMetaProperty","propertyName","innerStartPos","innerStartLoc","spreadStart","optionalCommaStart","spreadNodeStartPos","spreadNodeStartLoc","innerEndPos","innerEndLoc","arrowNode","metaProp","parseNew","isOptionalChain","parseExprList","isTagged","cooked","tail","curElt","parseTemplateElement","quasis","propHash","create","parsePropertyDefinition","checkProto","parseSpread","maybeAsyncOrAccessorProp","keyName","_params","checkGetterSetterParams","oldInPropertyName","generator","isExpression","hasStrictModeDirective","nonSimple","isSimpleParamList","errorPos","_node$params","recordAsyncArrowParametersError","recordParameterInitializerError","delegate","childExpression","checkSmartPipelineBodyEarlyErrors","parseSmartPipelineBodyInStyle","isSimpleReference","topicReferenceWasUsedInCurrentTopicContext","callback","outerContextTopicState","outerContextSoloAwaitState","ret","interpreter","parseInterpreterDirective","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseWhileStatement","parseWithStatement","parseEmptyStatement","nextTokenCharCode","isAsyncFunction","maybeName","parseLabeledStatement","allowExport","currentContextDecorators","decorator","isBreak","lab","withTopicForbiddingContext","parseHeaderExpression","awaitAt","parseFor","parseVar","declarations","parseForIn","description","declarationPosition","discriminant","cases","cur","sawDefault","isCase","simple","handler","clause","finalizer","_this$state$labels","statementStart","allowDirectives","createNewLexicalScope","afterBlockParse","parsedNonDirective","setStrict","isForIn","await","isFor","isTypescript","parseMaybeAssignDisallowIn","statement","isHangingStatement","requireId","constructorAllowsSuper","hadConstructor","hadStaticBlock","parseClassStaticBlock","publicMethod","privateMethod","publicProp","privateProp","publicMember","parseClassElementName","isPrivate","isSimple","maybeQuestionTokenStart","parsePostMemberNameModifiers","pushClassPrivateProperty","pushClassProperty","_member$decorators","SCOPE_CLASS","declarePrivateName","CLASS_ELEMENT_KIND_SETTER","parseInitializer","hasDefault","parseAfterDefault","hasStar","parseAfterNamespace","isFromRequired","hasSpecifiers","maybeParseExportNamedSpecifiers","hasDeclaration","maybeParseExportDeclaration","FUNC_STATEMENT","l","hasFrom","nextAfterFrom","assertions","maybeParseImportAssertions","checkNames","isDefault","isFrom","checkDuplicateExports","_declaration$extra","_node$specifiers","exportedName","_node$declaration$dec","_i5","_node$properties","_i6","_node$elements","nodes","surrogate","toString","parseNext","maybeParseModuleAttributes","attrs","attrNames","parseAssertEntries","parseImportSpecifierLocal","parseImportSpecifier","opts","_Object$keys","getOptions","getScopeHandler","pluginMap","pluginsMap","getParser","decoratorsBeforeExport","validatePlugins","pluginsFromOptions","pluginList","parserClassCache","getParserClass","_options","ast","moduleError","_unused2","getExpression","tokTypes"],"mappings":"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I,EAAG,GAAI,GAAI,IAAK,GAAI,GAAI,IAAK,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,IAAK,IAAK,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,KAAM,KAAM,IAAK,KAAM,IAAK,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,KAAM,EAAG,KAAM,GAAI,EAAG,KAAM,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,KAAM,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,KAAM,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,KAAM,GAAI,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,KAAM,IAAK,GAAI,GAAI,EAAG,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,KAAM,MAAO,GAAI,KAAM,GAAI,IAAK,EAAG,KAAM,GAAI,KAAM,KAAM,IAAK,KAAM,MAC3wDC,EAAwB,CAAC,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,MAAO,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,MAAO,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,KAAM,GAAI,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,IAAK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"},"name":"static/chunks/d57d79ab.396036635ece3758450a.js","input":"(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[5],{\n\n/***/ \"GGH7\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass TokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.updateContext = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n\n}\nconst keywords = new Map();\n\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = new TokenType(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name, binop) {\n  return new TokenType(name, {\n    beforeExpr,\n    binop\n  });\n}\n\nconst types = {\n  num: new TokenType(\"num\", {\n    startsExpr\n  }),\n  bigint: new TokenType(\"bigint\", {\n    startsExpr\n  }),\n  decimal: new TokenType(\"decimal\", {\n    startsExpr\n  }),\n  regexp: new TokenType(\"regexp\", {\n    startsExpr\n  }),\n  string: new TokenType(\"string\", {\n    startsExpr\n  }),\n  name: new TokenType(\"name\", {\n    startsExpr\n  }),\n  eof: new TokenType(\"eof\"),\n  bracketL: new TokenType(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: new TokenType(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: new TokenType(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: new TokenType(\"]\"),\n  bracketBarR: new TokenType(\"|]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: new TokenType(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: new TokenType(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", {\n    beforeExpr\n  }),\n  semi: new TokenType(\";\", {\n    beforeExpr\n  }),\n  colon: new TokenType(\":\", {\n    beforeExpr\n  }),\n  doubleColon: new TokenType(\"::\", {\n    beforeExpr\n  }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", {\n    beforeExpr\n  }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", {\n    beforeExpr\n  }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", {\n    beforeExpr\n  }),\n  backQuote: new TokenType(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: new TokenType(\"#!...\"),\n  eq: new TokenType(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: new TokenType(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: new TokenType(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: new TokenType(\"%\", {\n    beforeExpr,\n    binop: 10,\n    startsExpr\n  }),\n  star: new TokenType(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: new TokenType(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  })\n};\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass Position {\n  constructor(line, col) {\n    this.line = void 0;\n    this.column = void 0;\n    this.line = line;\n    this.column = col;\n  }\n\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n\n}\nfunction getLineInfo(input, offset) {\n  let line = 1;\n  let lineStart = 0;\n  let match;\n  lineBreakG.lastIndex = 0;\n\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\n    line++;\n    lineStart = lineBreakG.lastIndex;\n  }\n\n  return new Position(line, offset - lineStart);\n}\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n\n  hasPlugin(name) {\n    return this.plugins.has(name);\n  }\n\n  getPluginOption(plugin, name) {\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\n  }\n\n}\n\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.trailingComments.push(comment);\n    this.state.leadingComments.push(comment);\n  }\n\n  adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {\n    if (this.state.leadingComments.length === 0) {\n      return;\n    }\n\n    let lastElement = null;\n    let i = elements.length;\n\n    while (lastElement === null && i > 0) {\n      lastElement = elements[--i];\n    }\n\n    if (lastElement === null) {\n      return;\n    }\n\n    for (let j = 0; j < this.state.leadingComments.length; j++) {\n      if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n        this.state.leadingComments.splice(j, 1);\n        j--;\n      }\n    }\n\n    const newTrailingComments = [];\n\n    for (let i = 0; i < this.state.leadingComments.length; i++) {\n      const leadingComment = this.state.leadingComments[i];\n\n      if (leadingComment.end < node.end) {\n        newTrailingComments.push(leadingComment);\n\n        if (!takeAllComments) {\n          this.state.leadingComments.splice(i, 1);\n          i--;\n        }\n      } else {\n        if (node.trailingComments === undefined) {\n          node.trailingComments = [];\n        }\n\n        node.trailingComments.push(leadingComment);\n      }\n    }\n\n    if (takeAllComments) this.state.leadingComments = [];\n\n    if (newTrailingComments.length > 0) {\n      lastElement.trailingComments = newTrailingComments;\n    } else if (lastElement.trailingComments !== undefined) {\n      lastElement.trailingComments = [];\n    }\n  }\n\n  processComment(node) {\n    if (node.type === \"Program\" && node.body.length > 0) return;\n    const stack = this.state.commentStack;\n    let firstChild, lastChild, trailingComments, i, j;\n\n    if (this.state.trailingComments.length > 0) {\n      if (this.state.trailingComments[0].start >= node.end) {\n        trailingComments = this.state.trailingComments;\n        this.state.trailingComments = [];\n      } else {\n        this.state.trailingComments.length = 0;\n      }\n    } else if (stack.length > 0) {\n      const lastInStack = last(stack);\n\n      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n        trailingComments = lastInStack.trailingComments;\n        delete lastInStack.trailingComments;\n      }\n    }\n\n    if (stack.length > 0 && last(stack).start >= node.start) {\n      firstChild = stack.pop();\n    }\n\n    while (stack.length > 0 && last(stack).start >= node.start) {\n      lastChild = stack.pop();\n    }\n\n    if (!lastChild && firstChild) lastChild = firstChild;\n\n    if (firstChild) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties);\n          break;\n\n        case \"ObjectPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties, true);\n          break;\n\n        case \"CallExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.arguments);\n          break;\n\n        case \"ArrayExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements);\n          break;\n\n        case \"ArrayPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements, true);\n          break;\n      }\n    } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === \"ImportSpecifier\" && node.type !== \"ImportSpecifier\" || this.state.commentPreviousNode.type === \"ExportSpecifier\" && node.type !== \"ExportSpecifier\")) {\n      this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);\n    }\n\n    if (lastChild) {\n      if (lastChild.leadingComments) {\n        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        } else {\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n            if (lastChild.leadingComments[i].end <= node.start) {\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n              break;\n            }\n          }\n        }\n      }\n    } else if (this.state.leadingComments.length > 0) {\n      if (last(this.state.leadingComments).end <= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n        }\n\n        if (this.state.leadingComments.length > 0) {\n          node.leadingComments = this.state.leadingComments;\n          this.state.leadingComments = [];\n        }\n      } else {\n        for (i = 0; i < this.state.leadingComments.length; i++) {\n          if (this.state.leadingComments[i].end > node.start) {\n            break;\n          }\n        }\n\n        const leadingComments = this.state.leadingComments.slice(0, i);\n\n        if (leadingComments.length) {\n          node.leadingComments = leadingComments;\n        }\n\n        trailingComments = this.state.leadingComments.slice(i);\n\n        if (trailingComments.length === 0) {\n          trailingComments = null;\n        }\n      }\n    }\n\n    this.state.commentPreviousNode = node;\n\n    if (trailingComments) {\n      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n        node.innerComments = trailingComments;\n      } else {\n        const firstTrailingCommentIndex = trailingComments.findIndex(comment => comment.end >= node.end);\n\n        if (firstTrailingCommentIndex > 0) {\n          node.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);\n          node.trailingComments = trailingComments.slice(firstTrailingCommentIndex);\n        } else {\n          node.trailingComments = trailingComments;\n        }\n      }\n    }\n\n    stack.push(node);\n  }\n\n}\n\nconst ErrorMessages = Object.freeze({\n  AccessorIsGenerator: \"A %0ter cannot be a generator\",\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block\",\n  AwaitExpressionFormalParameter: \"await is not allowed in async function parameters\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions\",\n  BadGetterArity: \"getter must not have any formal parameters\",\n  BadSetterArity: \"setter must have exactly one formal parameter\",\n  BadSetterRestParameter: \"setter function argument must not be a rest parameter\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor\",\n  ConstructorIsAsync: \"Constructor can't be an async function\",\n  ConstructorIsGenerator: \"Constructor can't be a generator\",\n  DeclarationMissingInitializer: \"%0 require an initialization value\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block\",\n  DeletePrivateField: \"Deleting a private field is not allowed\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: \"`%0` has already been exported. Exported identifiers must be unique.\",\n  DuplicateProto: \"Redefinition of __proto__ property\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag\",\n  DuplicateStaticBlock: \"Duplicate static block in the same class\",\n  ElementAfterRest: \"Rest element must be last element\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape\",\n  ExportBindingIsString: \"A string literal cannot be used as an exported binding without `from`.\\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?\",\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'\",\n  ForInOfLoopInitializer: \"%0 loop variable declaration may not have an initializer\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block\",\n  IllegalBreakContinue: \"Unsyntactic %0\",\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list\",\n  IllegalReturn: \"'return' outside of function\",\n  ImportBindingIsString: 'A string literal cannot be used as an imported binding.\\n- Did you mean `import { \"%0\" as foo }`?',\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments\",\n  ImportCallArity: \"import() requires exactly %0\",\n  ImportCallNotNewExpression: \"Cannot use new with import(...)\",\n  ImportCallSpreadArgument: \"... is not allowed in import()\",\n  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: \"module\"'`,\n  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral\",\n  InvalidCodePoint: \"Code point out of bounds\",\n  InvalidDecimal: \"Invalid decimal\",\n  InvalidDigit: \"Expected number in radix %0\",\n  InvalidEscapeSequence: \"Bad character escape sequence\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template\",\n  InvalidEscapedReservedWord: \"Escape sequence in keyword %0\",\n  InvalidIdentifier: \"Invalid identifier %0\",\n  InvalidLhs: \"Invalid left-hand side in %0\",\n  InvalidLhsBinding: \"Binding invalid left-hand side in %0\",\n  InvalidNumber: \"Invalid number\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'\",\n  InvalidOrUnexpectedToken: \"Unexpected character '%0'\",\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern\",\n  InvalidPrivateFieldResolution: \"Private name #%0 is not defined\",\n  InvalidPropertyBindingPattern: \"Binding member expression\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument\",\n  LabelRedeclaration: \"Label '%0' is already declared\",\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'\",\n  MalformedRegExpFlags: \"Invalid regular expression flag\",\n  MissingClassName: \"A class name is required\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon\",\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values\",\n  ModuleAttributesWithDuplicateKeys: 'Duplicate key \"%0\" is not allowed in module attributes',\n  ModuleExportNameHasLoneSurrogate: \"An export name cannot include a lone surrogate, found '\\\\u%0'\",\n  ModuleExportUndefined: \"Export '%0' is not defined\",\n  MultipleDefaultsInSwitch: \"Multiple default clauses\",\n  NewlineAfterThrow: \"Illegal newline after throw\",\n  NoCatchOrFinally: \"Missing catch or finally clause\",\n  NumberIdentifier: \"Identifier directly after number\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\",\n  ObsoleteAwaitStar: \"await* has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"constructors in/after an Optional Chain are not allowed\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain\",\n  ParamDupe: \"Argument name clash\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter\",\n  PatternHasMethod: \"Object pattern can't contain methods\",\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding\",\n  PrimaryTopicRequiresSmartPipeline: \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",\n  PrivateInExpectedIn: \"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)\",\n  PrivateNameRedeclaration: \"Duplicate private name #%0\",\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement\",\n  StaticPrototype: \"Classes may not have static property named prototype\",\n  StrictDelete: \"Deleting local variable in strict mode\",\n  StrictEvalArguments: \"Assigning to '%0' in strict mode\",\n  StrictEvalArgumentsBinding: \"Binding '%0' in strict mode\",\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode\",\n  StrictWith: \"'with' in strict mode\",\n  SuperNotAllowed: \"super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super\",\n  TrailingDecorator: \"Decorators must be attached to a class element\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level\",\n  UnexpectedKeyword: \"Unexpected keyword '%0'\",\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context\",\n  UnexpectedNewTarget: \"new.target can only be used in functions\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits\",\n  UnexpectedPrivateField: \"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",\n  UnexpectedReservedWord: \"Unexpected reserved word '%0'\",\n  UnexpectedSuper: \"super is only allowed in object methods and classes\",\n  UnexpectedToken: \"Unexpected token '%0'\",\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"import can only be used in import() or import.meta\",\n  UnsupportedMetaProperty: \"The only valid meta property for %0 is %0.%1\",\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties\",\n  UnsupportedSuper: \"super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])\",\n  UnterminatedComment: \"Unterminated comment\",\n  UnterminatedRegExp: \"Unterminated regular expression\",\n  UnterminatedString: \"Unterminated string constant\",\n  UnterminatedTemplate: \"Unterminated template\",\n  VarRedeclaration: \"Identifier '%0' has already been declared\",\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0\"\n});\n\nclass ParserError extends CommentsParser {\n  getLocationForPosition(pos) {\n    let loc;\n    if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);\n    return loc;\n  }\n\n  raise(pos, errorTemplate, ...params) {\n    return this.raiseWithData(pos, undefined, errorTemplate, ...params);\n  }\n\n  raiseOverwrite(pos, errorTemplate, ...params) {\n    const loc = this.getLocationForPosition(pos);\n    const message = errorTemplate.replace(/%(\\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;\n\n    if (this.options.errorRecovery) {\n      const errors = this.state.errors;\n\n      for (let i = errors.length - 1; i >= 0; i--) {\n        const error = errors[i];\n\n        if (error.pos === pos) {\n          return Object.assign(error, {\n            message\n          });\n        } else if (error.pos < pos) {\n          break;\n        }\n      }\n    }\n\n    return this._raise({\n      loc,\n      pos\n    }, message);\n  }\n\n  raiseWithData(pos, data, errorTemplate, ...params) {\n    const loc = this.getLocationForPosition(pos);\n    const message = errorTemplate.replace(/%(\\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;\n    return this._raise(Object.assign({\n      loc,\n      pos\n    }, data), message);\n  }\n\n  _raise(errorContext, message) {\n    const err = new SyntaxError(message);\n    Object.assign(err, errorContext);\n\n    if (this.options.errorRecovery) {\n      if (!this.isLookahead) this.state.errors.push(err);\n      return err;\n    } else {\n      throw err;\n    }\n  }\n\n}\n\nvar estree = (superClass => class extends superClass {\n  estreeParseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  estreeParseBigIntLiteral(value) {\n    let bigInt;\n\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  estreeParseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  directiveToStmt(directive) {\n    const directiveLiteral = directive.value;\n    const stmt = this.startNodeAt(directive.start, directive.loc.start);\n    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n    expression.value = directiveLiteral.extra.expressionValue;\n    expression.raw = directiveLiteral.extra.raw;\n    stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n    return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) == null ? void 0 : _stmt$expression$extr.parenthesized);\n  }\n\n  stmtToDirective(stmt) {\n    const directive = super.stmtToDirective(stmt);\n    const value = stmt.expression.value;\n    this.addExtra(directive.value, \"expressionValue\", value);\n    return directive;\n  }\n\n  parseBlockBody(node, ...args) {\n    super.parseBlockBody(node, ...args);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n\n    classBody.body.push(method);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    switch (this.state.type) {\n      case types.num:\n      case types.string:\n        return this.estreeParseLiteral(this.state.value);\n\n      case types.regexp:\n        return this.estreeParseRegExpLiteral(this.state.value);\n\n      case types.bigint:\n        return this.estreeParseBigIntLiteral(this.state.value);\n\n      case types.decimal:\n        return this.estreeParseDecimalLiteral(this.state.value);\n\n      case types._null:\n        return this.estreeParseLiteral(null);\n\n      case types._true:\n        return this.estreeParseLiteral(true);\n\n      case types._false:\n        return this.estreeParseLiteral(false);\n\n      default:\n        return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    const node = super.parseLiteral(value, type, startPos, startLoc);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    type = type === \"ClassMethod\" ? \"MethodDefinition\" : type;\n    return this.finishNode(node, type);\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") node.kind = \"init\";\n      node.shorthand = false;\n    }\n\n    return node;\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n\n    return node;\n  }\n\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.toAssignable(node.value, isLHS);\n      return node;\n    }\n\n    return super.toAssignable(node, isLHS);\n  }\n\n  toAssignableObjectExpressionProp(prop, ...args) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);\n    } else if (prop.method) {\n      this.raise(prop.key.start, ErrorMessages.PatternHasMethod);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, ...args);\n    }\n  }\n\n  finishCallExpression(node, optional) {\n    super.finishCallExpression(node, optional);\n\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      delete node.arguments;\n      delete node.callee;\n    }\n\n    return node;\n  }\n\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n\n    super.toReferencedArguments(node);\n  }\n\n  parseExport(node) {\n    super.parseExport(node);\n\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n\n        break;\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);\n\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n\n    return node;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n\n    return super.hasPropertyAsPrivateName(node);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"ChainExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n\n});\n\nclass TokContext {\n  constructor(token, isExpr, preserveSpace, override) {\n    this.token = void 0;\n    this.isExpr = void 0;\n    this.preserveSpace = void 0;\n    this.override = void 0;\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n  }\n\n}\nconst types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  recordExpression: new TokContext(\"#{\", true),\n  templateQuasi: new TokContext(\"${\", false),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, p => p.readTmplToken()),\n  functionExpression: new TokContext(\"function\", true),\n  functionStatement: new TokContext(\"function\", false)\n};\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  let out = this.state.context.pop();\n\n  if (out === types$1.braceStatement && this.curContext().token === \"function\") {\n    out = this.state.context.pop();\n  }\n\n  this.state.exprAllowed = !out.isExpr;\n};\n\ntypes.name.updateContext = function (prevType) {\n  let allowed = false;\n\n  if (prevType !== types.dot) {\n    if (this.state.value === \"of\" && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class) {\n      allowed = true;\n    }\n  }\n\n  this.state.exprAllowed = allowed;\n\n  if (this.state.isIterator) {\n    this.state.isIterator = false;\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {};\n\ntypes._function.updateContext = types._class.updateContext = function (prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && this.hasPrecedingLineBreak()) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n    this.state.context.push(types$1.functionExpression);\n  } else {\n    this.state.context.push(types$1.functionStatement);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.braceHashL.updateContext = function () {\n  this.state.context.push(types$1.recordExpression);\n  this.state.exprAllowed = true;\n};\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords$1 = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords$1.has(word);\n}\n\nconst keywordRelationalOperator = /^in(stanceof)?$/;\nfunction isIteratorStart(current, next) {\n  return current === 64 && next === 64;\n}\n\nconst SCOPE_OTHER = 0b000000000,\n      SCOPE_PROGRAM = 0b000000001,\n      SCOPE_FUNCTION = 0b000000010,\n      SCOPE_ARROW = 0b000000100,\n      SCOPE_SIMPLE_CATCH = 0b000001000,\n      SCOPE_SUPER = 0b000010000,\n      SCOPE_DIRECT_SUPER = 0b000100000,\n      SCOPE_CLASS = 0b001000000,\n      SCOPE_STATIC_BLOCK = 0b010000000,\n      SCOPE_TS_MODULE = 0b100000000,\n      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b000000000001,\n      BIND_KIND_TYPE = 0b000000000010,\n      BIND_SCOPE_VAR = 0b000000000100,\n      BIND_SCOPE_LEXICAL = 0b000000001000,\n      BIND_SCOPE_FUNCTION = 0b000000010000,\n      BIND_FLAGS_NONE = 0b000001000000,\n      BIND_FLAGS_CLASS = 0b000010000000,\n      BIND_FLAGS_TS_ENUM = 0b000100000000,\n      BIND_FLAGS_TS_CONST_ENUM = 0b001000000000,\n      BIND_FLAGS_TS_EXPORT_ONLY = 0b010000000000,\n      BIND_FLAGS_FLOW_DECLARE_FN = 0b100000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n      CLASS_ELEMENT_KIND_GETTER = 0b010,\n      CLASS_ELEMENT_KIND_SETTER = 0b001,\n      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n      CLASS_ELEMENT_OTHER = 0;\n\nclass Scope {\n  constructor(flags) {\n    this.flags = void 0;\n    this.var = [];\n    this.lexical = [];\n    this.functions = [];\n    this.flags = flags;\n  }\n\n}\nclass ScopeHandler {\n  constructor(raise, inModule) {\n    this.scopeStack = [];\n    this.undefinedExports = new Map();\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get allowSuper() {\n    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;\n  }\n\n  get allowDirectSuper() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n  }\n\n  get inClass() {\n    return (this.currentThisScope().flags & SCOPE_CLASS) > 0;\n  }\n\n  get inStaticBlock() {\n    return (this.currentThisScope().flags & SCOPE_STATIC_BLOCK) > 0;\n  }\n\n  get inNonArrowFunction() {\n    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags) {\n    return new Scope(flags);\n  }\n\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n\n  declareName(name, bindingType, pos) {\n    let scope = this.currentScope();\n\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.push(name);\n      } else {\n        scope.lexical.push(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        scope.var.push(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope, name) {\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(scope, name, bindingType, pos) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.raise(pos, ErrorMessages.VarRedeclaration, name);\n    }\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;\n    }\n\n    return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {\n      this.undefinedExports.set(id.name, id.start);\n    }\n  }\n\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if (scope.flags & SCOPE_VAR) {\n        return scope;\n      }\n    }\n  }\n\n  currentThisScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {\n        return scope;\n      }\n    }\n  }\n\n}\n\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = [];\n  }\n\n}\n\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(...arguments)) return true;\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      return !scope.declareFunctions.includes(name) && (scope.lexical.includes(name) || scope.functions.includes(name));\n    }\n\n    return false;\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].declareFunctions.indexOf(id.name) === -1) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = Object.freeze({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\",\n  AssignReservedType: \"Cannot overwrite reserved type %0\",\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement\",\n  EnumBooleanMemberNotInitialized: \"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",\n  EnumDuplicateMemberName: \"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",\n  EnumInconsistentMemberValues: \"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",\n  EnumInvalidExplicitType: \"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidExplicitTypeUnknownSupplied: \"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidMemberInitializerPrimaryType: \"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",\n  EnumInvalidMemberInitializerSymbolType: \"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",\n  EnumInvalidMemberInitializerUnknownType: \"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",\n  EnumInvalidMemberName: \"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",\n  EnumNumberMemberNotInitialized: \"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",\n  EnumStringMemberInconsistentlyInitailized: \"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment\",\n  OptionalBindingPattern: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  SpreadVariance: \"Spread properties cannot have variance\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object\",\n  UnexpectedReservedType: \"Unexpected reserved type %0\",\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\"',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",\n  UnsupportedDeclareExportKind: \"`declare export %0` is not supported. Use `%1` instead\",\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module\",\n  UnterminatedFlowComment: \"Unterminated flow-comment\"\n});\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(state) {\n  return (state.type === types.name || !!state.type.keyword) && state.value !== \"from\";\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass => {\n  var _temp;\n\n  return _temp = class extends superClass {\n    constructor(...args) {\n      super(...args);\n      this.flowPragma = undefined;\n    }\n\n    getScopeHandler() {\n      return FlowScopeHandler;\n    }\n\n    shouldParseTypes() {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    shouldParseEnums() {\n      return !!this.getPluginOption(\"flow\", \"enums\");\n    }\n\n    finishToken(type, val) {\n      if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n\n      return super.finishToken(type, val);\n    }\n\n    addComment(comment) {\n      if (this.flowPragma === undefined) {\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n\n        if (!matches) ; else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n\n      return super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok) {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || types.colon);\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate() {\n      const node = this.startNode();\n      const moduloLoc = this.state.startLoc;\n      const moduloPos = this.state.start;\n      this.expect(types.modulo);\n      const checksLoc = this.state.startLoc;\n      this.expectContextual(\"checks\");\n\n      if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n        this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);\n      }\n\n      if (this.eat(types.parenL)) {\n        node.value = this.parseExpression();\n        this.expect(types.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser() {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(types.colon);\n      let type = null;\n      let predicate = null;\n\n      if (this.match(types.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n\n        if (this.match(types.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(node) {\n      this.next();\n      this.flowParseInterfaceish(node, true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(node) {\n      this.next();\n      const id = node.id = this.parseIdentifier();\n      const typeNode = this.startNode();\n      const typeContainer = this.startNode();\n\n      if (this.isRelational(\"<\")) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(types.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      this.expect(types.parenR);\n      [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n      this.resetEndLocation(id);\n      this.semicolon();\n      this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(node, insideModule) {\n      if (this.match(types._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(types._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(types._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(\"module\")) {\n        if (this.match(types.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);\n          }\n\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(\"type\")) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(\"opaque\")) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(\"interface\")) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(types._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        throw this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(node) {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(true);\n      this.scope.declareName(node.id.name, BIND_VAR, node.id.start);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(node) {\n      this.scope.enter(SCOPE_OTHER);\n\n      if (this.match(types.string)) {\n        node.id = this.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = node.body = this.startNode();\n      const body = bodyNode.body = [];\n      this.expect(types.braceL);\n\n      while (!this.match(types.braceR)) {\n        let bodyNode = this.startNode();\n\n        if (this.match(types._import)) {\n          this.next();\n\n          if (!this.isContextual(\"type\") && !this.match(types._typeof)) {\n            this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);\n          }\n\n          this.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\"declare\", FlowErrors.UnsupportedStatementInDeclareModule);\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n      this.expect(types.braceR);\n      this.finishNode(bodyNode, \"BlockStatement\");\n      let kind = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n          }\n\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);\n          }\n\n          if (kind === \"ES\") {\n            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n          }\n\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(node, insideModule) {\n      this.expect(types._export);\n\n      if (this.eat(types._default)) {\n        if (this.match(types._function) || this.match(types._class)) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n\n        node.default = true;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (this.match(types._const) || this.isLet() || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !insideModule) {\n          const label = this.state.value;\n          const suggestion = exportSuggestions[label];\n          throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);\n        }\n\n        if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual(\"opaque\")) {\n            node.declaration = this.flowParseDeclare(this.startNode());\n            node.default = false;\n            return this.finishNode(node, \"DeclareExportDeclaration\");\n          } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual(\"interface\") || this.isContextual(\"type\") || this.isContextual(\"opaque\")) {\n            node = this.parseExport(node);\n\n            if (node.type === \"ExportNamedDeclaration\") {\n              node.type = \"ExportDeclaration\";\n              node.default = false;\n              delete node.exportKind;\n            }\n\n            node.type = \"Declare\" + node.type;\n            return node;\n          }\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(node) {\n      this.next();\n      this.expectContextual(\"exports\");\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(node) {\n      this.next();\n      this.flowParseTypeAlias(node);\n      node.type = \"DeclareTypeAlias\";\n      return node;\n    }\n\n    flowParseDeclareOpaqueType(node) {\n      this.next();\n      this.flowParseOpaqueType(node, true);\n      node.type = \"DeclareOpaqueType\";\n      return node;\n    }\n\n    flowParseDeclareInterface(node) {\n      this.next();\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    flowParseInterfaceish(node, isClass = false) {\n      node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n      this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n      node.implements = [];\n      node.mixins = [];\n\n      if (this.eat(types._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(types.comma));\n      }\n\n      if (this.isContextual(\"mixins\")) {\n        this.next();\n\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      if (this.isContextual(\"implements\")) {\n        this.next();\n\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false\n      });\n    }\n\n    flowParseInterfaceExtends() {\n      const node = this.startNode();\n      node.id = this.flowParseQualifiedTypeIdentifier();\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node) {\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word) {\n      if (word === \"_\") {\n        this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);\n      }\n    }\n\n    checkReservedType(word, startLoc, declaration) {\n      if (!reservedTypes.has(word)) return;\n      this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);\n    }\n\n    flowParseRestrictedIdentifier(liberal, declaration) {\n      this.checkReservedType(this.state.value, this.state.start, declaration);\n      return this.parseIdentifier(liberal);\n    }\n\n    flowParseTypeAlias(node) {\n      node.id = this.flowParseRestrictedIdentifier(false, true);\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(types.eq);\n      this.semicolon();\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(node, declare) {\n      this.expectContextual(\"type\");\n      node.id = this.flowParseRestrictedIdentifier(true, true);\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.supertype = null;\n\n      if (this.match(types.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(types.colon);\n      }\n\n      node.impltype = null;\n\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(types.eq);\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    flowParseTypeParameter(requireDefault = false) {\n      const nodeStart = this.state.start;\n      const node = this.startNode();\n      const variance = this.flowParseVariance();\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      node.variance = variance;\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(types.eq)) {\n        this.eat(types.eq);\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration() {\n      const oldInType = this.state.inType;\n      const node = this.startNode();\n      node.params = [];\n      this.state.inType = true;\n\n      if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      } while (!this.isRelational(\">\"));\n\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    flowParseTypeParameterInstantiation() {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n      this.state.inType = true;\n      this.expectRelational(\"<\");\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n\n      while (!this.isRelational(\">\")) {\n        node.params.push(this.flowParseType());\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      }\n\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew() {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n      this.state.inType = true;\n      this.expectRelational(\"<\");\n\n      while (!this.isRelational(\">\")) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      }\n\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType() {\n      const node = this.startNode();\n      this.expectContextual(\"interface\");\n      node.extends = [];\n\n      if (this.eat(types._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false\n      });\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey() {\n      return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(node, isStatic, variance) {\n      node.static = isStatic;\n\n      if (this.lookahead().type === types.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n\n      this.expect(types.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(node, isStatic) {\n      node.static = isStatic;\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(types.bracketR);\n      this.expect(types.bracketR);\n\n      if (this.isRelational(\"<\") || this.match(types.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n      } else {\n        node.method = false;\n\n        if (this.eat(types.question)) {\n          node.optional = true;\n        }\n\n        node.value = this.flowParseTypeInitialiser();\n      }\n\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(node) {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(types.parenL);\n\n      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam());\n\n        if (!this.match(types.parenR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      if (this.eat(types.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam();\n      }\n\n      this.expect(types.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(node, isStatic) {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact\n    }) {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const nodeStart = this.startNode();\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n      let endDelim;\n      let exact;\n      let inexact = false;\n\n      if (allowExact && this.match(types.braceBarL)) {\n        this.expect(types.braceBarL);\n        endDelim = types.braceBarR;\n        exact = true;\n      } else {\n        this.expect(types.braceL);\n        endDelim = types.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStart = null;\n        let inexactStart = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(\"proto\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n            this.next();\n            protoStart = this.state.start;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(\"static\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(types.bracketL)) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n\n          if (this.eat(types.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.start);\n            }\n\n            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n          } else {\n            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n          }\n        } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n            const lookahead = this.lookahead();\n\n            if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStart = this.state.lastTokStart;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n          this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);\n        }\n      }\n\n      this.expect(endDelim);\n\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n      this.state.inType = oldInType;\n      return out;\n    }\n\n    flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {\n      if (this.eat(types.ellipsis)) {\n        const isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);\n          } else if (!allowInexact) {\n            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);\n          }\n\n          if (variance) {\n            this.raise(variance.start, FlowErrors.InexactVariance);\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);\n        }\n\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.raise(variance.start, FlowErrors.SpreadVariance);\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStart != null;\n        node.kind = kind;\n        let optional = false;\n\n        if (this.isRelational(\"<\") || this.match(types.parenL)) {\n          node.method = true;\n\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n          node.method = false;\n\n          if (this.eat(types.question)) {\n            optional = true;\n          }\n\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    flowCheckGetterSetterParams(property) {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const start = property.start;\n      const length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (length !== paramCount) {\n        if (property.kind === \"get\") {\n          this.raise(start, ErrorMessages.BadGetterArity);\n        } else {\n          this.raise(start, ErrorMessages.BadSetterArity);\n        }\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(start, ErrorMessages.BadSetterRestParameter);\n      }\n    }\n\n    flowObjectTypeSemicolon() {\n      if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n      startPos = startPos || this.state.start;\n      startLoc = startLoc || this.state.startLoc;\n      let node = id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(types.dot)) {\n        const node2 = this.startNodeAt(startPos, startLoc);\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(startPos, startLoc, id) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType() {\n      const node = this.startNode();\n      this.expect(types._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType() {\n      const node = this.startNode();\n      node.types = [];\n      this.expect(types.bracketL);\n\n      while (this.state.pos < this.length && !this.match(types.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(types.bracketR)) break;\n        this.expect(types.comma);\n      }\n\n      this.expect(types.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam() {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode();\n      const lh = this.lookahead();\n\n      if (lh.type === types.colon || lh.type === types.question) {\n        name = this.parseIdentifier();\n\n        if (this.eat(types.question)) {\n          optional = true;\n        }\n\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(type) {\n      const node = this.startNodeAt(type.start, type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(params = []) {\n      let rest = null;\n\n      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam());\n\n        if (!this.match(types.parenR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      if (this.eat(types.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam();\n      }\n\n      return {\n        params,\n        rest\n      };\n    }\n\n    flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startPos, startLoc, id);\n      }\n    }\n\n    flowParsePrimaryType() {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.startNode();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case types.name:\n          if (this.isContextual(\"interface\")) {\n            return this.flowParseInterfaceType();\n          }\n\n          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n        case types.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true\n          });\n\n        case types.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false\n          });\n\n        case types.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case types.relational:\n          if (this.state.value === \"<\") {\n            node.typeParameters = this.flowParseTypeParameterDeclaration();\n            this.expect(types.parenL);\n            tmp = this.flowParseFunctionTypeParams();\n            node.params = tmp.params;\n            node.rest = tmp.rest;\n            this.expect(types.parenR);\n            this.expect(types.arrow);\n            node.returnType = this.flowParseType();\n            return this.finishNode(node, \"FunctionTypeAnnotation\");\n          }\n\n          break;\n\n        case types.parenL:\n          this.next();\n\n          if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n            if (this.match(types.name)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== types.question && token !== types.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n              this.expect(types.parenR);\n              return type;\n            } else {\n              this.eat(types.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          this.expect(types.parenR);\n          this.expect(types.arrow);\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case types.string:\n          return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n        case types._true:\n        case types._false:\n          node.value = this.match(types._true);\n          this.next();\n          return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n        case types.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n\n            if (this.match(types.num)) {\n              return this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", node.start, node.loc.start);\n            }\n\n            if (this.match(types.bigint)) {\n              return this.parseLiteral(-this.state.value, \"BigIntLiteralTypeAnnotation\", node.start, node.loc.start);\n            }\n\n            throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);\n          }\n\n          throw this.unexpected();\n\n        case types.num:\n          return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n        case types.bigint:\n          return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n        case types._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case types._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case types._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case types.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        default:\n          if (this.state.type.keyword === \"typeof\") {\n            return this.flowParseTypeofType();\n          } else if (this.state.type.keyword) {\n            const label = this.state.type.label;\n            this.next();\n            return super.createIdentifier(node, label);\n          }\n\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParsePostfixType() {\n      const startPos = this.state.start,\n            startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n\n      while (this.match(types.bracketL) && !this.canInsertSemicolon()) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.elementType = type;\n        this.expect(types.bracketL);\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      }\n\n      return type;\n    }\n\n    flowParsePrefixType() {\n      const node = this.startNode();\n\n      if (this.eat(types.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens() {\n      const param = this.flowParsePrefixType();\n\n      if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n        const node = this.startNodeAt(param.start, param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n\n      return param;\n    }\n\n    flowParseIntersectionType() {\n      const node = this.startNode();\n      this.eat(types.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n\n      while (this.eat(types.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n\n      return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType() {\n      const node = this.startNode();\n      this.eat(types.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n\n      while (this.eat(types.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n\n      return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType() {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation() {\n      if (this.state.type === types.name && this.state.value === \"_\") {\n        const startPos = this.state.start;\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startPos, startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation() {\n      const node = this.startNode();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n      if (this.match(types.colon)) {\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n\n      return ident;\n    }\n\n    typeCastToParameter(node) {\n      node.expression.typeAnnotation = node.typeAnnotation;\n      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n      return node.expression;\n    }\n\n    flowParseVariance() {\n      let variance = null;\n\n      if (this.match(types.plusMin)) {\n        variance = this.startNode();\n\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n\n        this.next();\n        this.finishNode(variance, \"Variance\");\n      }\n\n      return variance;\n    }\n\n    parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n      if (allowExpressionBody) {\n        return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      }\n\n      return super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish(node, type, isMethod = false) {\n      if (this.match(types.colon)) {\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n      }\n\n      super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    parseStatement(context, topLevel) {\n      if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type === types.name || isKeyword(lookahead.value)) {\n          const node = this.startNode();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n\n      const stmt = super.parseStatement(context, topLevel);\n\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n\n      return stmt;\n    }\n\n    parseExpressionStatement(node, expr) {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n            return this.flowParseDeclare(node);\n          }\n        } else if (this.match(types.name)) {\n          if (expr.name === \"interface\") {\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr);\n    }\n\n    shouldParseExportDeclaration() {\n      return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || this.shouldParseEnums() && this.isContextual(\"enum\") || super.shouldParseExportDeclaration();\n    }\n\n    isExportDefaultSpecifier() {\n      if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value === \"opaque\" || this.shouldParseEnums() && this.state.value === \"enum\")) {\n        return false;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression() {\n      if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {\n      if (!this.match(types.question)) return expr;\n\n      if (refNeedsArrowPos) {\n        const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));\n\n        if (!result.node) {\n          refNeedsArrowPos.start = result.error.pos || this.state.start;\n          return expr;\n        }\n\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n\n      this.expect(types.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt(startPos, startLoc);\n      let {\n        consequent,\n        failed\n      } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({\n            consequent,\n            failed\n          } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt.concat(valid[0].start);\n          ({\n            consequent,\n            failed\n          } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(types.colon);\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined, undefined));\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent() {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(types.colon);\n      this.state.noArrowParamsConversionAt.pop();\n      return {\n        consequent,\n        failed\n      };\n    }\n\n    getArrowLikeExpressions(node, disallowInvalid) {\n      const stack = [node];\n      const arrows = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n\n        if (node.type === \"ArrowFunctionExpression\") {\n          if (node.typeParameters || !node.returnType) {\n            this.finishArrowValidation(node);\n          } else {\n            arrows.push(node);\n          }\n\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n    }\n\n    finishArrowValidation(node) {\n      var _node$extra;\n\n      this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);\n      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt(node, parse) {\n      let result;\n\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem(node, startPos, startLoc) {\n      node = super.parseParenItem(node, startPos, startLoc);\n\n      if (this.eat(types.question)) {\n        node.optional = true;\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(types.colon)) {\n        const typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    assertModuleNodeAllowed(node) {\n      if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExport(node) {\n      const decl = super.parseExport(node);\n\n      if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n        decl.exportKind = decl.exportKind || \"value\";\n      }\n\n      return decl;\n    }\n\n    parseExportDeclaration(node) {\n      if (this.isContextual(\"type\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(types.braceL)) {\n          node.specifiers = this.parseExportSpecifiers();\n          this.parseExportFrom(node);\n          return null;\n        } else {\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(\"opaque\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(\"interface\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseInterface(declarationNode);\n      } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(node) {\n      if (super.eatExportStar(...arguments)) return true;\n\n      if (this.isContextual(\"type\") && this.lookahead().type === types.star) {\n        node.exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(node) {\n      const pos = this.state.start;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(pos);\n      }\n\n      return hasNamespace;\n    }\n\n    parseClassId(node, isStatement, optionalId) {\n      super.parseClassId(node, isStatement, optionalId);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(classBody, member, state) {\n      const pos = this.state.start;\n\n      if (this.isContextual(\"declare\")) {\n        if (this.parseClassMemberFromModifier(classBody, member)) {\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\") {\n          this.raise(pos, FlowErrors.DeclareClassElement);\n        } else if (member.value) {\n          this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);\n        }\n      }\n    }\n\n    getTokenFromCode(code) {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 123 && next === 124) {\n        return this.finishOp(types.braceBarL, 2);\n      } else if (this.state.inType && (code === 62 || code === 60)) {\n        return this.finishOp(types.relational, 1);\n      } else if (this.state.inType && code === 63) {\n        return this.finishOp(types.question, 1);\n      } else if (isIteratorStart(code, next)) {\n        this.state.isIterator = true;\n        return super.readWord();\n      } else {\n        return super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node, isBinding) {\n      switch (node.type) {\n        case \"Identifier\":\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"AssignmentPattern\":\n          return true;\n\n        case \"ObjectExpression\":\n          {\n            const last = node.properties.length - 1;\n            return node.properties.every((prop, i) => {\n              return prop.type !== \"ObjectMethod\" && (i === last || prop.type === \"SpreadElement\") && this.isAssignable(prop);\n            });\n          }\n\n        case \"ObjectProperty\":\n          return this.isAssignable(node.value);\n\n        case \"SpreadElement\":\n          return this.isAssignable(node.argument);\n\n        case \"ArrayExpression\":\n          return node.elements.every(element => this.isAssignable(element));\n\n        case \"AssignmentExpression\":\n          return node.operator === \"=\";\n\n        case \"ParenthesizedExpression\":\n        case \"TypeCastExpression\":\n          return this.isAssignable(node.expression);\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return !isBinding;\n\n        default:\n          return false;\n      }\n    }\n\n    toAssignable(node, isLHS = false) {\n      if (node.type === \"TypeCastExpression\") {\n        return super.toAssignable(this.typeCastToParameter(node), isLHS);\n      } else {\n        return super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableList(exprList, trailingCommaPos, isLHS) {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n\n        if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n\n      return super.toAssignableList(exprList, trailingCommaPos, isLHS);\n    }\n\n    toReferencedList(exprList, isParenthesizedExpr) {\n      for (let i = 0; i < exprList.length; i++) {\n        var _expr$extra;\n\n        const expr = exprList[i];\n\n        if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) == null ? void 0 : _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n          this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n      const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    checkLVal(expr, ...args) {\n      if (expr.type !== \"TypeCastExpression\") {\n        return super.checkLVal(expr, ...args);\n      }\n    }\n\n    parseClassProperty(node) {\n      if (this.match(types.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(node) {\n      if (this.match(types.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      return super.parseClassPrivateProperty(node);\n    }\n\n    isClassMethod() {\n      return this.isRelational(\"<\") || super.isClassMethod();\n    }\n\n    isClassProperty() {\n      return this.match(types.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method) {\n      return !this.match(types.colon) && super.isNonstaticConstructor(method);\n    }\n\n    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n      if (method.variance) {\n        this.unexpected(method.variance.start);\n      }\n\n      delete method.variance;\n\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    }\n\n    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n      if (method.variance) {\n        this.unexpected(method.variance.start);\n      }\n\n      delete method.variance;\n\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    parseClassSuper(node) {\n      super.parseClassSuper(node);\n\n      if (node.superClass && this.isRelational(\"<\")) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      if (this.isContextual(\"implements\")) {\n        this.next();\n        const implemented = node.implements = [];\n\n        do {\n          const node = this.startNode();\n          node.id = this.flowParseRestrictedIdentifier(true);\n\n          if (this.isRelational(\"<\")) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(types.comma));\n      }\n    }\n\n    parsePropertyName(node, isPrivateNameAllowed) {\n      const variance = this.flowParseVariance();\n      const key = super.parsePropertyName(node, isPrivateNameAllowed);\n      node.variance = variance;\n      return key;\n    }\n\n    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n      if (prop.variance) {\n        this.unexpected(prop.variance.start);\n      }\n\n      delete prop.variance;\n      let typeParameters;\n\n      if (this.isRelational(\"<\") && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(types.parenL)) this.unexpected();\n      }\n\n      super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n\n      if (typeParameters) {\n        (prop.value || prop).typeParameters = typeParameters;\n      }\n    }\n\n    parseAssignableListItemTypes(param) {\n      if (this.eat(types.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(param.start, FlowErrors.OptionalBindingPattern);\n        }\n\n        param.optional = true;\n      }\n\n      if (this.match(types.colon)) {\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(startPos, startLoc, left) {\n      const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n      if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n        this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);\n      }\n\n      return node;\n    }\n\n    shouldParseDefaultImport(node) {\n      if (!hasTypeImportKind(node)) {\n        return super.shouldParseDefaultImport(node);\n      }\n\n      return isMaybeDefaultImport(this.state);\n    }\n\n    parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n      node.specifiers.push(this.finishNode(specifier, type));\n    }\n\n    maybeParseDefaultImportSpecifier(node) {\n      node.importKind = \"value\";\n      let kind = null;\n\n      if (this.match(types._typeof)) {\n        kind = \"typeof\";\n      } else if (this.isContextual(\"type\")) {\n        kind = \"type\";\n      }\n\n      if (kind) {\n        const lh = this.lookahead();\n\n        if (kind === \"type\" && lh.type === types.star) {\n          this.unexpected(lh.start);\n        }\n\n        if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      return super.maybeParseDefaultImportSpecifier(node);\n    }\n\n    parseImportSpecifier(node) {\n      const specifier = this.startNode();\n      const firstIdentLoc = this.state.start;\n      const firstIdent = this.parseModuleExportName();\n      let specifierTypeKind = null;\n\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n\n      if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n\n        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = as_ident.__clone();\n        } else {\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n\n        if (this.eatContextual(\"as\")) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = specifier.imported.__clone();\n        }\n      } else {\n        if (firstIdent.type === \"StringLiteral\") {\n          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);\n        }\n\n        isBinding = true;\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = specifier.imported.__clone();\n      }\n\n      const nodeIsTypeImport = hasTypeImportKind(node);\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (nodeIsTypeImport && specifierIsTypeImport) {\n        this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);\n      }\n\n      if (nodeIsTypeImport || specifierIsTypeImport) {\n        this.checkReservedType(specifier.local.name, specifier.local.start, true);\n      }\n\n      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n        this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n      }\n\n      this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n      node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n    }\n\n    parseFunctionParams(node, allowModifiers) {\n      const kind = node.kind;\n\n      if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.parseFunctionParams(node, allowModifiers);\n    }\n\n    parseVarId(decl, kind) {\n      super.parseVarId(decl, kind);\n\n      if (this.match(types.colon)) {\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id);\n      }\n    }\n\n    parseAsyncArrowFromCallExpression(node, call) {\n      if (this.match(types.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    shouldParseAsyncArrow() {\n      return this.match(types.colon) || super.shouldParseAsyncArrow();\n    }\n\n    parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n      var _jsx;\n\n      let state = null;\n      let jsx;\n\n      if (this.hasPlugin(\"jsx\") && (this.match(types.jsxTagStart) || this.isRelational(\"<\"))) {\n        state = this.state.clone();\n        jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos), state);\n        if (!jsx.error) return jsx.node;\n        const {\n          context\n        } = this.state;\n\n        if (context[context.length - 1] === types$1.j_oTag) {\n          context.length -= 2;\n        } else if (context[context.length - 1] === types$1.j_expr) {\n          context.length -= 1;\n        }\n      }\n\n      if (((_jsx = jsx) == null ? void 0 : _jsx.error) || this.isRelational(\"<\")) {\n        var _jsx2, _jsx3;\n\n        state = state || this.state.clone();\n        let typeParameters;\n        const arrow = this.tryParse(abort => {\n          var _arrowExpression$extr;\n\n          typeParameters = this.flowParseTypeParameterDeclaration();\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);\n            this.resetStartLocationFromNode(result, typeParameters);\n            return result;\n          });\n\n          if (arrowExpression.type !== \"ArrowFunctionExpression\" && ((_arrowExpression$extr = arrowExpression.extra) == null ? void 0 : _arrowExpression$extr.parenthesized)) {\n            abort();\n          }\n\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n          return arrowExpression;\n        }, state);\n        let arrowExpression = null;\n\n        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n          if (!arrow.error && !arrow.aborted) {\n            if (arrow.node.async) {\n              this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);\n            }\n\n            return arrow.node;\n          }\n\n          arrowExpression = arrow.node;\n        }\n\n        if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n        throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);\n      }\n\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);\n    }\n\n    parseArrow(node) {\n      if (this.match(types.colon)) {\n        const result = this.tryParse(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n          const typeNode = this.startNode();\n          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(types.arrow)) this.unexpected();\n          return typeNode;\n        });\n        if (result.thrown) return null;\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow() {\n      return this.match(types.colon) || super.shouldParseArrow();\n    }\n\n    setArrowFunctionParameters(node, params) {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(node, allowDuplicates, isArrowFunction) {\n      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        return;\n      }\n\n      return super.checkParams(...arguments);\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow) {\n      return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n    }\n\n    parseSubscripts(base, startPos, startLoc, noCalls) {\n      if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n        this.next();\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (base.type === \"Identifier\" && base.name === \"async\" && this.isRelational(\"<\")) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n        const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startPos, startLoc, noCalls);\n    }\n\n    parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {\n      if (this.match(types.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n\n        this.next();\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\n        this.expect(types.parenL);\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, true);\n      } else if (!noCalls && this.shouldParseTypes() && this.isRelational(\"<\")) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const result = this.tryParse(() => {\n          node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(types.parenL);\n          node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n          if (subscriptState.optionalChainMember) node.optional = false;\n          return this.finishCallExpression(node, subscriptState.optionalChainMember);\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);\n    }\n\n    parseNewArguments(node) {\n      let targs = null;\n\n      if (this.shouldParseTypes() && this.isRelational(\"<\")) {\n        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n      }\n\n      node.typeArguments = targs;\n      super.parseNewArguments(node);\n    }\n\n    parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n      const node = this.startNodeAt(startPos, startLoc);\n      this.parseFunctionParams(node);\n      if (!this.parseArrow(node)) return;\n      return this.parseArrowExpression(node, undefined, true);\n    }\n\n    readToken_mult_modulo(code) {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 42 && next === 47 && this.state.hasFlowComment) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code) {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 124 && next === 125) {\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file, program) {\n      const fileNode = super.parseTopLevel(file, program);\n\n      if (this.state.hasFlowComment) {\n        this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);\n      }\n\n      return fileNode;\n    }\n\n    skipBlockComment() {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          this.unexpected(null, FlowErrors.NestedFlowComment);\n        }\n\n        this.hasFlowCommentCompletion();\n        this.state.pos += this.skipFlowComment();\n        this.state.hasFlowComment = true;\n        return;\n      }\n\n      if (this.state.hasFlowComment) {\n        const end = this.input.indexOf(\"*-/\", this.state.pos += 2);\n\n        if (end === -1) {\n          throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);\n        }\n\n        this.state.pos = end + 3;\n        return;\n      }\n\n      super.skipBlockComment();\n    }\n\n    skipFlowComment() {\n      const {\n        pos\n      } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n\n      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === 58 && ch3 === 58) {\n        return shiftToFirstNonWhiteSpace + 2;\n      }\n\n      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n        return shiftToFirstNonWhiteSpace + 12;\n      }\n\n      if (ch2 === 58 && ch3 !== 58) {\n        return shiftToFirstNonWhiteSpace;\n      }\n\n      return false;\n    }\n\n    hasFlowCommentCompletion() {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n\n      if (end === -1) {\n        throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);\n      }\n    }\n\n    flowEnumErrorBooleanMemberNotInitialized(pos, {\n      enumName,\n      memberName\n    }) {\n      this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);\n    }\n\n    flowEnumErrorInvalidMemberName(pos, {\n      enumName,\n      memberName\n    }) {\n      const suggestion = memberName[0].toUpperCase() + memberName.slice(1);\n      this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);\n    }\n\n    flowEnumErrorDuplicateMemberName(pos, {\n      enumName,\n      memberName\n    }) {\n      this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);\n    }\n\n    flowEnumErrorInconsistentMemberValues(pos, {\n      enumName\n    }) {\n      this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);\n    }\n\n    flowEnumErrorInvalidExplicitType(pos, {\n      enumName,\n      suppliedType\n    }) {\n      return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);\n    }\n\n    flowEnumErrorInvalidMemberInitializer(pos, {\n      enumName,\n      explicitType,\n      memberName\n    }) {\n      let message = null;\n\n      switch (explicitType) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;\n          break;\n\n        case \"symbol\":\n          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;\n          break;\n\n        default:\n          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;\n      }\n\n      return this.raise(pos, message, enumName, memberName, explicitType);\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(pos, {\n      enumName,\n      memberName\n    }) {\n      this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitailized(pos, {\n      enumName\n    }) {\n      this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);\n    }\n\n    flowEnumMemberInit() {\n      const startPos = this.state.start;\n\n      const endOfInit = () => this.match(types.comma) || this.match(types.braceR);\n\n      switch (this.state.type) {\n        case types.num:\n          {\n            const literal = this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n            if (endOfInit()) {\n              return {\n                type: \"number\",\n                pos: literal.start,\n                value: literal\n              };\n            }\n\n            return {\n              type: \"invalid\",\n              pos: startPos\n            };\n          }\n\n        case types.string:\n          {\n            const literal = this.parseLiteral(this.state.value, \"StringLiteral\");\n\n            if (endOfInit()) {\n              return {\n                type: \"string\",\n                pos: literal.start,\n                value: literal\n              };\n            }\n\n            return {\n              type: \"invalid\",\n              pos: startPos\n            };\n          }\n\n        case types._true:\n        case types._false:\n          {\n            const literal = this.parseBooleanLiteral();\n\n            if (endOfInit()) {\n              return {\n                type: \"boolean\",\n                pos: literal.start,\n                value: literal\n              };\n            }\n\n            return {\n              type: \"invalid\",\n              pos: startPos\n            };\n          }\n\n        default:\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n      }\n    }\n\n    flowEnumMemberRaw() {\n      const pos = this.state.start;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(types.eq) ? this.flowEnumMemberInit() : {\n        type: \"none\",\n        pos\n      };\n      return {\n        id,\n        init\n      };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {\n      const {\n        explicitType\n      } = context;\n\n      if (explicitType === null) {\n        return;\n      }\n\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(pos, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType\n    }) {\n      const seenNames = new Set();\n      const members = {\n        booleanMembers: [],\n        numberMembers: [],\n        stringMembers: [],\n        defaultedMembers: []\n      };\n\n      while (!this.match(types.braceR)) {\n        const memberNode = this.startNode();\n        const {\n          id,\n          init\n        } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n\n        if (memberName === \"\") {\n          continue;\n        }\n\n        if (/^[a-z]/.test(memberName)) {\n          this.flowEnumErrorInvalidMemberName(id.start, {\n            enumName,\n            memberName\n          });\n        }\n\n        if (seenNames.has(memberName)) {\n          this.flowEnumErrorDuplicateMemberName(id.start, {\n            enumName,\n            memberName\n          });\n        }\n\n        seenNames.add(memberName);\n        const context = {\n          enumName,\n          explicitType,\n          memberName\n        };\n        memberNode.id = id;\n\n        switch (init.type) {\n          case \"boolean\":\n            {\n              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"boolean\");\n              memberNode.init = init.value;\n              members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n              break;\n            }\n\n          case \"number\":\n            {\n              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"number\");\n              memberNode.init = init.value;\n              members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n              break;\n            }\n\n          case \"string\":\n            {\n              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"string\");\n              memberNode.init = init.value;\n              members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n              break;\n            }\n\n          case \"invalid\":\n            {\n              throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);\n            }\n\n          case \"none\":\n            {\n              switch (explicitType) {\n                case \"boolean\":\n                  this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);\n                  break;\n\n                case \"number\":\n                  this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);\n                  break;\n\n                default:\n                  members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n              }\n            }\n        }\n\n        if (!this.match(types.braceR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      return members;\n    }\n\n    flowEnumStringMembers(initializedMembers, defaultedMembers, {\n      enumName\n    }) {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (let _i = 0; _i < initializedMembers.length; _i++) {\n          const member = initializedMembers[_i];\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n            enumName\n          });\n        }\n\n        return defaultedMembers;\n      } else {\n        for (let _i2 = 0; _i2 < defaultedMembers.length; _i2++) {\n          const member = defaultedMembers[_i2];\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n            enumName\n          });\n        }\n\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName\n    }) {\n      if (this.eatContextual(\"of\")) {\n        if (!this.match(types.name)) {\n          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: null\n          });\n        }\n\n        const {\n          value\n        } = this.state;\n        this.next();\n\n        if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n          this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: value\n          });\n        }\n\n        return value;\n      }\n\n      return null;\n    }\n\n    flowEnumBody(node, {\n      enumName,\n      nameLoc\n    }) {\n      const explicitType = this.flowEnumParseExplicitType({\n        enumName\n      });\n      this.expect(types.braceL);\n      const members = this.flowEnumMembers({\n        enumName,\n        explicitType\n      });\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n            enumName\n          });\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n\n        default:\n          {\n            const empty = () => {\n              node.members = [];\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumStringBody\");\n            };\n\n            node.explicitType = false;\n            const boolsLen = members.booleanMembers.length;\n            const numsLen = members.numberMembers.length;\n            const strsLen = members.stringMembers.length;\n            const defaultedLen = members.defaultedMembers.length;\n\n            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n              return empty();\n            } else if (!boolsLen && !numsLen) {\n              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n                enumName\n              });\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumStringBody\");\n            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n              for (let _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {\n                const member = _members$defaultedMem[_i3];\n                this.flowEnumErrorBooleanMemberNotInitialized(member.start, {\n                  enumName,\n                  memberName: member.id.name\n                });\n              }\n\n              node.members = members.booleanMembers;\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumBooleanBody\");\n            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n              for (let _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {\n                const member = _members$defaultedMem2[_i4];\n                this.flowEnumErrorNumberMemberNotInitialized(member.start, {\n                  enumName,\n                  memberName: member.id.name\n                });\n              }\n\n              node.members = members.numberMembers;\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumNumberBody\");\n            } else {\n              this.flowEnumErrorInconsistentMemberValues(nameLoc, {\n                enumName\n              });\n              return empty();\n            }\n          }\n      }\n    }\n\n    flowParseEnumDeclaration(node) {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), {\n        enumName: id.name,\n        nameLoc: id.start\n      });\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    updateContext(prevType) {\n      if (this.match(types.name) && this.state.value === \"of\" && prevType === types.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === \"interface\") {\n        this.state.exprAllowed = false;\n      } else {\n        super.updateContext(prevType);\n      }\n    }\n\n    isLookaheadToken_lt() {\n      const next = this.nextTokenStart();\n\n      if (this.input.charCodeAt(next) === 60) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return afterNext !== 60 && afterNext !== 61;\n      }\n\n      return false;\n    }\n\n    maybeUnwrapTypeCastExpression(node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n\n  }, _temp;\n});\n\nconst entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\nconst JsxErrors = Object.freeze({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression\",\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>\",\n  MissingClosingTagElement: \"Expected corresponding JSX closing tag for <%0>\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text\",\n  UnterminatedJsxContent: \"Unterminated JSX contents\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", {\n  beforeExpr: true\n});\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", {\n  startsExpr: true\n});\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr);\n  this.state.context.push(types$1.j_oTag);\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  const out = this.state.context.pop();\n\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsx = (superClass => class extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.exprAllowed) {\n              ++this.state.pos;\n              return this.finishToken(types.jsxTagStart);\n            }\n\n            return super.getTokenFromCode(ch);\n          }\n\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(types.jsxText, out);\n\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n\n        case 62:\n        case 125:\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n\n      }\n    }\n  }\n\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(types.string, out);\n  }\n\n  jsxReadEntity() {\n    let str = \"\";\n    let count = 0;\n    let entity;\n    let ch = this.input[this.state.pos];\n    const startPos = ++this.state.pos;\n\n    while (this.state.pos < this.length && count++ < 10) {\n      ch = this.input[this.state.pos++];\n\n      if (ch === \";\") {\n        if (str[0] === \"#\") {\n          if (str[1] === \"x\") {\n            str = str.substr(2);\n\n            if (HEX_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 16));\n            }\n          } else {\n            str = str.substr(1);\n\n            if (DECIMAL_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 10));\n            }\n          }\n        } else {\n          entity = entities[str];\n        }\n\n        break;\n      }\n\n      str += ch;\n    }\n\n    if (!entity) {\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    return entity;\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n\n    return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n\n    if (this.match(types.jsxName)) {\n      node.name = this.state.value;\n    } else if (this.state.type.keyword) {\n      node.name = this.state.type.keyword;\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(types.colon)) return name;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n\n    while (this.eat(types.dot)) {\n      const newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n\n    switch (this.state.type) {\n      case types.braceL:\n        node = this.startNode();\n        this.next();\n        node = this.jsxParseExpressionContainer(node);\n\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(node.start, JsxErrors.AttributeIsEmpty);\n        }\n\n        return node;\n\n      case types.jsxTagStart:\n      case types.string:\n        return this.parseExprAtom();\n\n      default:\n        throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node) {\n    if (this.match(types.braceR)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n\n    if (this.eat(types.braceL)) {\n      this.expect(types.ellipsis);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.expect(types.braceR);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n\n    while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n\n    node.attributes = attributes;\n    node.selfClosing = this.eat(types.slash);\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n    let closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case types.jsxTagStart:\n            startPos = this.state.start;\n            startLoc = this.state.startLoc;\n            this.next();\n\n            if (this.eat(types.slash)) {\n              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n\n            children.push(this.jsxParseElementAt(startPos, startLoc));\n            break;\n\n          case types.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case types.braceL:\n            {\n              const node = this.startNode();\n              this.next();\n\n              if (this.match(types.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node));\n              }\n\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      if (isFragment(openingElement) && !isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n        }\n      }\n    }\n\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n\n    node.children = children;\n\n    if (this.isRelational(\"<\")) {\n      throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);\n    }\n\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startPos, startLoc);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(types.jsxText)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(types.jsxTagStart)) {\n      return this.jsxParseElement();\n    } else if (this.isRelational(\"<\") && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.finishToken(types.jsxTagStart);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inPropertyName) return super.getTokenFromCode(code);\n    const context = this.curContext();\n\n    if (context === types$1.j_expr) {\n      return this.jsxReadToken();\n    }\n\n    if (context === types$1.j_oTag || context === types$1.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(types.jsxTagEnd);\n      }\n\n      if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n\n    if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(types.jsxTagStart);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  updateContext(prevType) {\n    if (this.match(types.braceL)) {\n      const curContext = this.curContext();\n\n      if (curContext === types$1.j_oTag) {\n        this.state.context.push(types$1.braceExpression);\n      } else if (curContext === types$1.j_expr) {\n        this.state.context.push(types$1.templateQuasi);\n      } else {\n        super.updateContext(prevType);\n      }\n\n      this.state.exprAllowed = true;\n    } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n      this.state.context.length -= 2;\n      this.state.context.push(types$1.j_cTag);\n      this.state.exprAllowed = false;\n    } else {\n      return super.updateContext(prevType);\n    }\n  }\n\n});\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = [];\n    this.enums = [];\n    this.constEnums = [];\n    this.classes = [];\n    this.exportOnlyBindings = [];\n  }\n\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        this.maybeExportDefined(scope, name);\n      }\n\n      scope.types.push(name);\n    }\n\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.indexOf(name) > -1) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.indexOf(name) > -1;\n        return isConst !== wasConst;\n      }\n\n      return true;\n    }\n\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {\n      if (scope.lexical.indexOf(name) > -1) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nconst PARAM = 0b0000,\n      PARAM_YIELD = 0b0001,\n      PARAM_AWAIT = 0b0010,\n      PARAM_RETURN = 0b0100,\n      PARAM_IN = 0b1000;\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n  get hasIn() {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nconst TSErrors = Object.freeze({\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateModifier: \"Duplicate modifier: '%0'\",\n  DuplicateAccessibilityModifier: \"Accessibility modifier already seen.\",\n  EmptyHeritageClauseType: \"'%0' list cannot be empty.\",\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier\",\n  IndexSignatureHasAccessibility: \"Index signatures cannot have an accessibility modifier ('%0')\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier\",\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier\",\n  InvalidModifierOnTypeMember: \"'%0' modifier cannot appear on a type member.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MixedLabeledAndUnlabeledElements: \"Tuple members must all have names or all not have names.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: \"Private elements cannot have an accessibility modifier ('%0')\",\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0\"\n});\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\n\nvar typescript = (superClass => class extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n\n  tsIsIdentifier() {\n    return this.match(types.name);\n  }\n\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return (this.match(types.bracketL) || this.match(types.braceL) || this.match(types.star) || this.match(types.ellipsis) || this.match(types.hash) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n\n  tsParseModifier(allowedModifiers) {\n    if (!this.match(types.name)) {\n      return undefined;\n    }\n\n    const modifier = this.state.value;\n\n    if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n      return modifier;\n    }\n\n    return undefined;\n  }\n\n  tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate) {\n    for (;;) {\n      const startPos = this.state.start;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []));\n      if (!modifier) break;\n\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);\n        } else {\n          modified.accessibility = modifier;\n        }\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(startPos, TSErrors.DuplicateModifier, modifier);\n        }\n\n        modified[modifier] = true;\n      }\n\n      if (disallowedModifiers == null ? void 0 : disallowedModifiers.includes(modifier)) {\n        this.raise(startPos, errorTemplate, modifier);\n      }\n    }\n  }\n\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(types.braceR);\n\n      case \"HeritageClauseElement\":\n        return this.match(types.braceL);\n\n      case \"TupleElementTypes\":\n        return this.match(types.bracketR);\n\n      case \"TypeParametersOrArguments\":\n        return this.isRelational(\">\");\n    }\n\n    throw new Error(\"Unreachable\");\n  }\n\n  tsParseList(kind, parseElement) {\n    const result = [];\n\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n\n    return result;\n  }\n\n  tsParseDelimitedList(kind, parseElement) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {\n    const result = [];\n\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      const element = parseElement();\n\n      if (element == null) {\n        return undefined;\n      }\n\n      result.push(element);\n\n      if (this.eat(types.comma)) {\n        continue;\n      }\n\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      if (expectSuccess) {\n        this.expect(types.comma);\n      }\n\n      return undefined;\n    }\n\n    return result;\n  }\n\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(types.bracketL);\n      } else {\n        this.expectRelational(\"<\");\n      }\n    }\n\n    const result = this.tsParseDelimitedList(kind, parseElement);\n\n    if (bracket) {\n      this.expect(types.bracketR);\n    } else {\n      this.expectRelational(\">\");\n    }\n\n    return result;\n  }\n\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(types._import);\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);\n    }\n\n    node.argument = this.parseExprAtom();\n    this.expect(types.parenR);\n\n    if (this.eat(types.dot)) {\n      node.qualifier = this.tsParseEntityName(true);\n    }\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSImportType\");\n  }\n\n  tsParseEntityName(allowReservedWords) {\n    let entity = this.parseIdentifier();\n\n    while (this.eat(types.dot)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n\n    return entity;\n  }\n\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(false);\n\n    if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(types._typeof);\n\n    if (this.match(types._import)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName(true);\n    }\n\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n\n  tsParseTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsEatThenParseType(types._extends);\n    node.default = this.tsEatThenParseType(types.eq);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsTryParseTypeParameters() {\n    if (this.isRelational(\"<\")) {\n      return this.tsParseTypeParameters();\n    }\n  }\n\n  tsParseTypeParameters() {\n    const node = this.startNode();\n\n    if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), false, true);\n\n    if (node.params.length === 0) {\n      this.raise(node.start, TSErrors.EmptyTypeParameters);\n    }\n\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsTryNextParseConstantContext() {\n    if (this.lookahead().type === types._const) {\n      this.next();\n      return this.tsParseTypeReference();\n    }\n\n    return null;\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === types.arrow;\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(types.parenL);\n    signature.parameters = this.tsParseBindingListForSignature();\n\n    if (returnTokenRequired) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n\n  tsParseBindingListForSignature() {\n    return this.parseBindingList(types.parenR, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);\n      }\n\n      return pattern;\n    });\n  }\n\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(types.comma)) {\n      this.semicolon();\n    }\n  }\n\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(types.colon, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    return this.eat(types.name) && this.match(types.colon);\n  }\n\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n\n    this.expect(types.bracketL);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(types.bracketR);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(types.question)) node.optional = true;\n    const nodeAny = node;\n\n    if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      if (readonly) {\n        this.raise(node.start, TSErrors.ReadonlyForMethodSignature);\n      }\n\n      const method = nodeAny;\n      this.tsFillSignature(types.colon, method);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n\n  tsParseTypeMember() {\n    const node = this.startNode();\n\n    if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n\n    if (this.match(types._new)) {\n      const id = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n\n    this.tsParseModifiers(node, [\"readonly\"], [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\"], TSErrors.InvalidModifierOnTypeMember);\n    const idx = this.tsTryParseIndexSignature(node);\n\n    if (idx) {\n      return idx;\n    }\n\n    this.parsePropertyName(node, false);\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n\n  tsParseObjectTypeMembers() {\n    this.expect(types.braceL);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(types.braceR);\n    return members;\n  }\n\n  tsIsStartOfMappedType() {\n    this.next();\n\n    if (this.eat(types.plusMin)) {\n      return this.isContextual(\"readonly\");\n    }\n\n    if (this.isContextual(\"readonly\")) {\n      this.next();\n    }\n\n    if (!this.match(types.bracketL)) {\n      return false;\n    }\n\n    this.next();\n\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n\n    this.next();\n    return this.match(types._in);\n  }\n\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsExpectThenParseType(types._in);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(types.braceL);\n\n    if (this.match(types.plusMin)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(\"readonly\");\n    } else if (this.eatContextual(\"readonly\")) {\n      node.readonly = true;\n    }\n\n    this.expect(types.bracketL);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(\"as\") ? this.tsParseType() : null;\n    this.expect(types.bracketR);\n\n    if (this.match(types.plusMin)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(types.question);\n    } else if (this.eat(types.question)) {\n      node.optional = true;\n    }\n\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    let labeledElements = null;\n    node.elementTypes.forEach(elementNode => {\n      var _labeledElements;\n\n      let {\n        type\n      } = elementNode;\n\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);\n      }\n\n      seenOptionalElement = seenOptionalElement || type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\";\n\n      if (type === \"TSRestType\") {\n        elementNode = elementNode.typeAnnotation;\n        type = elementNode.type;\n      }\n\n      const isLabeled = type === \"TSNamedTupleMember\";\n      labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;\n\n      if (labeledElements !== isLabeled) {\n        this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n\n  tsParseTupleElementType() {\n    const {\n      start: startPos,\n      startLoc\n    } = this.state;\n    const rest = this.eat(types.ellipsis);\n    let type = this.tsParseType();\n    const optional = this.eat(types.question);\n    const labeled = this.eat(types.colon);\n\n    if (labeled) {\n      const labeledNode = this.startNodeAtNode(type);\n      labeledNode.optional = optional;\n\n      if (type.type === \"TSTypeReference\" && !type.typeParameters && type.typeName.type === \"Identifier\") {\n        labeledNode.label = type.typeName;\n      } else {\n        this.raise(type.start, TSErrors.InvalidTupleMemberLabel);\n        labeledNode.label = type;\n      }\n\n      labeledNode.elementType = this.tsParseType();\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n\n    if (rest) {\n      const restNode = this.startNodeAt(startPos, startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n\n    return type;\n  }\n\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(types.parenL);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n\n  tsParseFunctionOrConstructorType(type) {\n    const node = this.startNode();\n\n    if (type === \"TSConstructorType\") {\n      this.expect(types._new);\n    }\n\n    this.tsFillSignature(types.arrow, node);\n    return this.finishNode(node, type);\n  }\n\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n\n    node.literal = (() => {\n      switch (this.state.type) {\n        case types.num:\n        case types.bigint:\n        case types.string:\n        case types._true:\n        case types._false:\n          return this.parseExprAtom();\n\n        default:\n          throw this.unexpected();\n      }\n    })();\n\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = this.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case types.name:\n      case types._void:\n      case types._null:\n        {\n          const type = this.match(types._void) ? \"TSVoidKeyword\" : this.match(types._null) ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n          if (type !== undefined && this.lookaheadCharCode() !== 46) {\n            const node = this.startNode();\n            this.next();\n            return this.finishNode(node, type);\n          }\n\n          return this.tsParseTypeReference();\n        }\n\n      case types.string:\n      case types.num:\n      case types.bigint:\n      case types._true:\n      case types._false:\n        return this.tsParseLiteralTypeNode();\n\n      case types.plusMin:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n\n          if (nextToken.type !== types.num && nextToken.type !== types.bigint) {\n            throw this.unexpected();\n          }\n\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n\n        break;\n\n      case types._this:\n        return this.tsParseThisTypeOrThisTypePredicate();\n\n      case types._typeof:\n        return this.tsParseTypeQuery();\n\n      case types._import:\n        return this.tsParseImportType();\n\n      case types.braceL:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n      case types.bracketL:\n        return this.tsParseTupleType();\n\n      case types.parenL:\n        return this.tsParseParenthesizedType();\n\n      case types.backQuote:\n        return this.tsParseTemplateLiteralType();\n    }\n\n    throw this.unexpected();\n  }\n\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n\n    while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {\n      if (this.match(types.bracketR)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n\n    return type;\n  }\n\n  tsParseTypeOperator(operator) {\n    const node = this.startNode();\n    this.expectContextual(operator);\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n\n      default:\n        this.raise(node.start, TSErrors.UnexpectedReadonly);\n    }\n  }\n\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(\"infer\");\n    const typeParameter = this.startNode();\n    typeParameter.name = this.parseIdentifierName(typeParameter.start);\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n\n  tsParseTypeOperatorOrHigher() {\n    const operator = [\"keyof\", \"unique\", \"readonly\"].find(kw => this.isContextual(kw));\n    return operator ? this.tsParseTypeOperator(operator) : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n  }\n\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);\n  }\n\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);\n  }\n\n  tsIsStartOfFunctionType() {\n    if (this.isRelational(\"<\")) {\n      return true;\n    }\n\n    return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n\n  tsSkipParameterStart() {\n    if (this.match(types.name) || this.match(types._this)) {\n      this.next();\n      return true;\n    }\n\n    if (this.match(types.braceL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.braceL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.braceR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    if (this.match(types.bracketL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.bracketL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.bracketR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n\n    if (this.match(types.parenR) || this.match(types.ellipsis)) {\n      return true;\n    }\n\n    if (this.tsSkipParameterStart()) {\n      if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {\n        return true;\n      }\n\n      if (this.match(types.parenR)) {\n        this.next();\n\n        if (this.match(types.arrow)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n      if (asserts && this.match(types._this)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;\n  }\n\n  tsTryParseTypeAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;\n  }\n\n  tsTryParseType() {\n    return this.tsEatThenParseType(types.colon);\n  }\n\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n\n  tsParseTypePredicateAsserts() {\n    if (!this.match(types.name) || this.state.value !== \"asserts\" || this.hasPrecedingLineBreak()) {\n      return false;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.next();\n\n    if (!this.match(types.name) && !this.match(types._this)) {\n      return false;\n    }\n\n    if (containsEsc) {\n      this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, \"asserts\");\n    }\n\n    return true;\n  }\n\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(types.colon);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n\n    if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {\n      return type;\n    }\n\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsParseNonConditionalType();\n    this.expect(types.question);\n    node.trueType = this.tsParseType();\n    this.expect(types.colon);\n    node.falseType = this.tsParseType();\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n\n    if (this.match(types._new)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    }\n\n    return this.tsParseUnionTypeOrHigher();\n  }\n\n  tsParseTypeAssertion() {\n    const node = this.startNode();\n\n    const _const = this.tsTryNextParseConstantContext();\n\n    node.typeAnnotation = _const || this.tsNextThenParseType();\n    this.expectRelational(\">\");\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n\n  tsParseHeritageClause(descriptor) {\n    const originalStart = this.state.start;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n\n    if (!delimitedList.length) {\n      this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);\n    }\n\n    return delimitedList;\n  }\n\n  tsParseExpressionWithTypeArguments() {\n    const node = this.startNode();\n    node.expression = this.tsParseEntityName(false);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n  }\n\n  tsParseInterfaceDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript interface declaration\", BIND_TS_INTERFACE);\n    node.typeParameters = this.tsTryParseTypeParameters();\n\n    if (this.eat(types._extends)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript type alias\", BIND_TS_TYPE);\n    node.typeParameters = this.tsTryParseTypeParameters();\n    node.typeAnnotation = this.tsInType(() => {\n      this.expect(types.eq);\n\n      if (this.isContextual(\"intrinsic\") && this.lookahead().type !== types.dot) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n\n    if (this.eat(types.eq)) {\n      node.initializer = this.parseMaybeAssignAllowIn();\n    }\n\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n\n  tsParseEnumDeclaration(node, isConst) {\n    if (isConst) node.const = true;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript enum declaration\", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);\n    this.expect(types.braceL);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.braceL);\n    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n\n    if (!nested) {\n      this.checkLVal(node.id, \"module or namespace declaration\", BIND_TS_NAMESPACE);\n    }\n\n    if (this.eat(types.dot)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(\"global\")) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(types.string)) {\n      node.id = this.parseExprAtom();\n    } else {\n      this.unexpected();\n    }\n\n    if (this.match(types.braceL)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"import equals declaration\", BIND_LEXICAL);\n    this.expect(types.eq);\n    node.moduleReference = this.tsParseModuleReference();\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n\n  tsIsExternalModuleReference() {\n    return this.isContextual(\"require\") && this.lookaheadCharCode() === 40;\n  }\n\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(\"require\");\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      throw this.unexpected();\n    }\n\n    node.expression = this.parseExprAtom();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n\n    let starttype = this.state.type;\n    let kind;\n\n    if (this.isContextual(\"let\")) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    return this.tsInDeclareContext(() => {\n      switch (starttype) {\n        case types._function:\n          nany.declare = true;\n          return this.parseFunctionStatement(nany, false, true);\n\n        case types._class:\n          nany.declare = true;\n          return this.parseClass(nany, true, false);\n\n        case types._const:\n          if (this.match(types._const) && this.isLookaheadContextual(\"enum\")) {\n            this.expect(types._const);\n            this.expectContextual(\"enum\");\n            return this.tsParseEnumDeclaration(nany, true);\n          }\n\n        case types._var:\n          kind = kind || this.state.value;\n          return this.parseVarStatement(nany, kind);\n\n        case types.name:\n          {\n            const value = this.state.value;\n\n            if (value === \"global\") {\n              return this.tsParseAmbientExternalModuleDeclaration(nany);\n            } else {\n              return this.tsParseDeclaration(nany, value, true);\n            }\n          }\n      }\n    });\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n  }\n\n  tsParseExpressionStatement(node, expr) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n\n          break;\n        }\n\n      case \"global\":\n        if (this.match(types.braceL)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n\n        break;\n\n      default:\n        return this.tsParseDeclaration(node, expr.name, false);\n    }\n  }\n\n  tsParseDeclaration(node, value, next) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(types._class) || this.match(types.name))) {\n          return this.tsParseAbstractDeclaration(node);\n        }\n\n        break;\n\n      case \"enum\":\n        if (next || this.match(types.name)) {\n          if (next) this.next();\n          return this.tsParseEnumDeclaration(node, false);\n        }\n\n        break;\n\n      case \"interface\":\n        if (this.tsCheckLineTerminator(next) && this.match(types.name)) {\n          return this.tsParseInterfaceDeclaration(node);\n        }\n\n        break;\n\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(types.string)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (this.match(types.name)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n\n        break;\n\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && this.match(types.name)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && this.match(types.name)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n\n        break;\n    }\n  }\n\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n\n    return !this.isLineTerminator();\n  }\n\n  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n    if (!this.isRelational(\"<\")) {\n      return undefined;\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(types.arrow);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    if (!res) {\n      return undefined;\n    }\n\n    return this.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expectRelational(\"<\");\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n\n    if (node.params.length === 0) {\n      this.raise(node.start, TSErrors.EmptyTypeArguments);\n    }\n\n    this.state.exprAllowed = false;\n    this.expectRelational(\">\");\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n\n  tsIsDeclarationStart() {\n    if (this.match(types.name)) {\n      switch (this.state.value) {\n        case \"abstract\":\n        case \"declare\":\n        case \"enum\":\n        case \"interface\":\n        case \"module\":\n        case \"namespace\":\n        case \"type\":\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n\n    if (allowModifiers !== undefined) {\n      accessibility = this.parseAccessModifier();\n      readonly = !!this.tsParseModifier([\"readonly\"]);\n\n      if (allowModifiers === false && (accessibility || readonly)) {\n        this.raise(startPos, TSErrors.UnexpectedParameterModifier);\n      }\n    }\n\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (accessibility || readonly) {\n      const pp = this.startNodeAt(startPos, startLoc);\n\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);\n      }\n\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n    }\n\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" ? \"TSDeclareMethod\" : undefined;\n\n    if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {\n      this.finishNode(node, bodilessType);\n      return;\n    }\n\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isDeclareContext) {\n      this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);\n\n      if (node.declare) {\n        super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n        return;\n      }\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkLVal(node.id, \"function name\", BIND_TS_AMBIENT);\n    } else {\n      super.registerFunctionStatementId(...arguments);\n    }\n  }\n\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);\n      }\n    });\n  }\n\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n\n  parseArrayLike(...args) {\n    const node = super.parseArrayLike(...args);\n\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {\n      this.state.exprAllowed = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startPos, startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n\n    if (this.isRelational(\"<\")) {\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const typeArguments = this.tsParseTypeArguments();\n\n        if (typeArguments) {\n          if (!noCalls && this.eat(types.parenL)) {\n            node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n            this.tsCheckForInvalidTypeCasts(node.arguments);\n            node.typeParameters = typeArguments;\n\n            if (state.optionalChainMember) {\n              node.optional = false;\n            }\n\n            return this.finishCallExpression(node, state.optionalChainMember);\n          } else if (this.match(types.backQuote)) {\n            const result = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n            result.typeParameters = typeArguments;\n            return result;\n          }\n        }\n\n        this.unexpected();\n      });\n      if (result) return result;\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n  }\n\n  parseNewArguments(node) {\n    if (this.isRelational(\"<\")) {\n      const typeParameters = this.tsTryParseAndCatch(() => {\n        const args = this.tsParseTypeArguments();\n        if (!this.match(types.parenL)) this.unexpected();\n        return args;\n      });\n\n      if (typeParameters) {\n        node.typeParameters = typeParameters;\n      }\n    }\n\n    super.parseNewArguments(node);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(\"as\")) {\n      const node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.expression = left;\n\n      const _const = this.tsTryNextParseConstantContext();\n\n      if (_const) {\n        node.typeAnnotation = _const;\n      } else {\n        node.typeAnnotation = this.tsNextThenParseType();\n      }\n\n      this.finishNode(node, \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n    }\n\n    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}\n\n  checkDuplicateExports() {}\n\n  parseImport(node) {\n    if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {\n      const ahead = this.lookahead();\n\n      if (this.match(types.name) && ahead.type === types.eq) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n\n      if (this.isContextual(\"type\") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === \"from\")) {\n        node.importKind = \"type\";\n        this.next();\n      }\n    }\n\n    if (!node.importKind) {\n      node.importKind = \"value\";\n    }\n\n    const importNode = super.parseImport(node);\n\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(importNode.start, \"A type-only import can specify a default import or named bindings, but not both.\");\n    }\n\n    return importNode;\n  }\n\n  parseExport(node) {\n    if (this.match(types._import)) {\n      this.expect(types._import);\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(types.eq)) {\n      const assign = node;\n      assign.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(\"as\")) {\n      const decl = node;\n      this.expectContextual(\"namespace\");\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(\"type\") && this.lookahead().type === types.braceL) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n\n      return super.parseExport(node);\n    }\n  }\n\n  isAbstractClass() {\n    return this.isContextual(\"abstract\") && this.lookahead().type === types._class;\n  }\n\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      this.parseClass(cls, true, true);\n      return cls;\n    }\n\n    if (this.state.value === \"interface\") {\n      const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);\n      if (result) return result;\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseStatementContent(context, topLevel) {\n    if (this.state.type === types._const) {\n      const ahead = this.lookahead();\n\n      if (ahead.type === types.name && ahead.value === \"enum\") {\n        const node = this.startNode();\n        this.expect(types._const);\n        this.expectContextual(\"enum\");\n        return this.tsParseEnumDeclaration(node, true);\n      }\n    }\n\n    return super.parseStatementContent(context, topLevel);\n  }\n\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n\n  parseClassMember(classBody, member, state) {\n    this.tsParseModifiers(member, [\"declare\", \"private\", \"public\", \"protected\"]);\n\n    const callParseClassMember = () => {\n      super.parseClassMember(classBody, member, state);\n    };\n\n    if (member.declare) {\n      this.tsInDeclareContext(callParseClassMember);\n    } else {\n      callParseClassMember();\n    }\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    this.tsParseModifiers(member, [\"abstract\", \"readonly\", \"declare\"]);\n    const idx = this.tsTryParseIndexSignature(member);\n\n    if (idx) {\n      classBody.body.push(idx);\n\n      if (member.abstract) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAbstract);\n      }\n\n      if (isStatic) {\n        this.raise(member.start, TSErrors.IndexSignatureHasStatic);\n      }\n\n      if (member.accessibility) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);\n      }\n\n      if (member.declare) {\n        this.raise(member.start, TSErrors.IndexSignatureHasDeclare);\n      }\n\n      return;\n    }\n\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(types.question);\n    if (optional) methodOrProp.optional = true;\n\n    if (methodOrProp.readonly && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);\n    }\n\n    if (methodOrProp.declare && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n    return decl || super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {\n    if (!refNeedsArrowPos || !this.match(types.question)) {\n      return super.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);\n    }\n\n    const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));\n\n    if (!result.node) {\n      refNeedsArrowPos.start = result.error.pos || this.state.start;\n      return expr;\n    }\n\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(types.question)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(types.colon)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  parseExportDeclaration(node) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(\"declare\");\n\n    if (isDeclare && (this.isContextual(\"declare\") || !this.shouldParseExportDeclaration())) {\n      throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);\n    }\n\n    let declaration;\n\n    if (this.match(types.name)) {\n      declaration = this.tsTryParseExportDeclaration();\n    }\n\n    if (!declaration) {\n      declaration = super.parseExportDeclaration(node);\n    }\n\n    if (declaration && (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare)) {\n      node.exportKind = \"type\";\n    }\n\n    if (declaration && isDeclare) {\n      this.resetStartLocation(declaration, startPos, startLoc);\n      declaration.declare = true;\n    }\n\n    return declaration;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\n      return;\n    }\n\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(types.bang)) {\n      node.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n\n    if (this.state.isDeclareContext && this.match(types.eq)) {\n      this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(node.start, TSErrors.PrivateElementHasAbstract);\n    }\n\n    if (node.accessibility) {\n      this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);\n    }\n\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n\n    if (typeParameters && isConstructor) {\n      this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);\n    }\n\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.tsParseTypeArguments();\n    }\n\n    if (this.eatContextual(\"implements\")) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n\n  parseObjPropValue(prop, ...args) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    super.parseObjPropValue(prop, ...args);\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (decl.id.type === \"Identifier\" && this.eat(types.bang)) {\n      decl.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  parseMaybeAssign(...args) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;\n\n    let state;\n    let jsx;\n    let typeCast;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(types.jsxTagStart) || this.isRelational(\"<\"))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types$1.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types$1.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (!((_jsx = jsx) == null ? void 0 : _jsx.error) && !this.isRelational(\"<\")) {\n      return super.parseMaybeAssign(...args);\n    }\n\n    let typeParameters;\n    state = state || this.state.clone();\n    const arrow = this.tryParse(abort => {\n      var _typeParameters;\n\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(...args);\n\n      if (expr.type !== \"ArrowFunctionExpression\" || expr.extra && expr.extra.parenthesized) {\n        abort();\n      }\n\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) return arrow.node;\n\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n\n    if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n\n    if (arrow.node) {\n      this.state = arrow.failState;\n      return arrow.node;\n    }\n\n    if ((_typeCast = typeCast) == null ? void 0 : _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n\n    if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.thrown) throw typeCast.error;\n    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (!this.hasPlugin(\"jsx\") && this.isRelational(\"<\")) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors);\n    }\n  }\n\n  parseArrow(node) {\n    if (this.match(types.colon)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n        if (this.canInsertSemicolon() || !this.match(types.arrow)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(types.question)) {\n      if (param.type !== \"Identifier\" && !this.state.isDeclareContext && !this.state.inType) {\n        this.raise(param.start, TSErrors.PatternIsOptional);\n      }\n\n      param.optional = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return super.toAssignable(this.typeCastToParameter(node), isLHS);\n\n      case \"TSParameterProperty\":\n        return super.toAssignable(node, isLHS);\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        node.expression = this.toAssignable(node.expression, isLHS);\n        return node;\n\n      default:\n        return super.toAssignable(node, isLHS);\n    }\n  }\n\n  checkLVal(expr, contextDescription, ...args) {\n    switch (expr.type) {\n      case \"TSTypeCastExpression\":\n        return;\n\n      case \"TSParameterProperty\":\n        this.checkLVal(expr.parameter, \"parameter property\", ...args);\n        return;\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        this.checkLVal(expr.expression, contextDescription, ...args);\n        return;\n\n      default:\n        super.checkLVal(expr, contextDescription, ...args);\n        return;\n    }\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types._this:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsParseTypeArguments();\n\n      if (this.match(types.parenL)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n\n      this.unexpected(this.state.start, types.parenL);\n    }\n\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();\n  }\n\n  parseMaybeDefault(...args) {\n    const node = super.parseMaybeDefault(...args);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);\n    }\n\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(types.relational, 1);\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  reScan_lt_gt() {\n    if (this.match(types.relational)) {\n      const code = this.input.charCodeAt(this.state.start);\n\n      if (code === 60 || code === 62) {\n        this.state.pos -= 1;\n        this.readToken_lt_gt(code);\n      }\n    }\n  }\n\n  toAssignableList(exprList) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if (!expr) continue;\n\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          exprList[i] = this.typeCastToParameter(expr);\n          break;\n\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n          if (!this.state.maybeInArrowParameters) {\n            exprList[i] = this.typeCastToParameter(expr);\n          } else {\n            this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);\n          }\n\n          break;\n      }\n    }\n\n    return super.toAssignableList(...arguments);\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  shouldParseArrow() {\n    return this.match(types.colon) || super.shouldParseArrow();\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.colon) || super.shouldParseAsyncArrow();\n  }\n\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && firstParam.type === \"Identifier\" && firstParam.name === \"this\";\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n\n    return param;\n  }\n\n  tsInDeclareContext(cb) {\n    const oldIsDeclareContext = this.state.isDeclareContext;\n    this.state.isDeclareContext = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.isDeclareContext = oldIsDeclareContext;\n    }\n  }\n\n  parseClass(node, ...args) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n\n    try {\n      return super.parseClass(node, ...args);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n\n  tsParseAbstractDeclaration(node) {\n    if (this.match(types._class)) {\n      node.abstract = true;\n      return this.parseClass(node, true, false);\n    } else if (this.isContextual(\"interface\")) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(node.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);\n        this.next();\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, types._class);\n    }\n  }\n\n});\n\ntypes.placeholder = new TokenType(\"%%\", {\n  startsExpr: true\n});\nvar placeholders = (superClass => class extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(types.placeholder)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      this.expect(types.placeholder);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(types.placeholder, 2);\n    }\n\n    return super.getTokenFromCode(...arguments);\n  }\n\n  parseExprAtom() {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments);\n  }\n\n  parseIdentifier() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(...arguments);\n  }\n\n  checkReservedWord(word) {\n    if (word !== undefined) super.checkReservedWord(...arguments);\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments);\n  }\n\n  checkLVal(expr) {\n    if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\n  }\n\n  toAssignable(node) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n      return node;\n    }\n\n    return super.toAssignable(...arguments);\n  }\n\n  isLet(context) {\n    if (super.isLet(context)) {\n      return true;\n    }\n\n    if (!this.isContextual(\"let\")) {\n      return false;\n    }\n\n    if (context) return false;\n    const nextToken = this.lookahead();\n\n    if (nextToken.type === types.placeholder) {\n      return true;\n    }\n\n    return false;\n  }\n\n  verifyBreakContinue(node) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(...arguments);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(...arguments);\n    }\n\n    if (this.match(types.colon)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = this.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n\n  parseBlock() {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(...arguments);\n  }\n\n  parseFunctionId() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(...arguments);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n\n    if (placeholder) {\n      if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        this.unexpected(null, \"A class name is required\");\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n\n    this.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n\n  parseExport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(...arguments);\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types._default)) {\n      const next = this.nextTokenStart();\n\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(types.placeholder.label, this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n\n    return super.maybeParseExportDefaultSpecifier(...arguments);\n  }\n\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n\n    if (specifiers == null ? void 0 : specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(...arguments);\n    node.specifiers = [];\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    this.finishNode(specifier, \"ImportDefaultSpecifier\");\n    node.specifiers.push(specifier);\n\n    if (this.eat(types.comma)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n\n    this.expectContextual(\"from\");\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource(...arguments);\n  }\n\n});\n\nvar v8intrinsic = (superClass => class extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(types.modulo)) {\n      const v8IntrinsicStart = this.state.start;\n      const node = this.startNode();\n      this.eat(types.modulo);\n\n      if (this.match(types.name)) {\n        const name = this.parseIdentifierName(this.state.start);\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n\n        if (this.match(types.parenL)) {\n          return identifier;\n        }\n      }\n\n      this.unexpected(v8IntrinsicStart);\n    }\n  }\n\n  parseExprAtom() {\n    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n  }\n\n});\n\nfunction hasPlugin(plugins, name) {\n  return plugins.some(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"smart\", \"fsharp\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you are migrating from\" + \" Babylon/Babel 6 or want to use the old decorators proposal, you\" + \" should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, \"pipelineOperator\", \"proposal\"))) {\n    throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \" + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(\", \"));\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    if (hasPlugin(plugins, \"importAssertions\")) {\n      throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");\n    }\n\n    const moduleAttributesVerionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n\n    if (moduleAttributesVerionPluginOption !== \"may-2020\") {\n      throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"recordAndTuple\") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false\n};\nfunction getOptions(opts) {\n  const options = {};\n\n  for (let _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {\n    const key = _Object$keys[_i];\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nclass State {\n  constructor() {\n    this.strict = void 0;\n    this.curLine = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.maybeInArrowParameters = false;\n    this.inPipeline = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.inPropertyName = false;\n    this.hasFlowComment = false;\n    this.isIterator = false;\n    this.isDeclareContext = false;\n    this.inAbstractClass = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.comments = [];\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = [];\n    this.commentPreviousNode = null;\n    this.pos = 0;\n    this.lineStart = 0;\n    this.type = types.eof;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.lastTokEnd = 0;\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n    this.containsEsc = false;\n    this.strictErrors = new Map();\n    this.exportedIdentifiers = [];\n    this.tokensLength = 0;\n  }\n\n  init(options) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n    this.curLine = options.startLine;\n    this.startLoc = this.endLoc = this.curPosition();\n  }\n\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n\n    return state;\n  }\n\n}\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst VALID_REGEX_FLAGS = new Set([\"g\", \"m\", \"s\", \"i\", \"y\", \"u\"]);\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n  hex: [46, 88, 95, 120]\n};\nconst allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [48, 49];\nallowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];\nallowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];\nallowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n}\nclass Tokenizer extends ParserError {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  next() {\n    if (!this.isLookahead) {\n      this.checkKeywordEscapes();\n\n      if (this.options.tokens) {\n        this.pushToken(new Token(this.state));\n      }\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = old.clone(true);\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    const skip = skipWhiteSpace.exec(this.input);\n    return pos + skip[0].length;\n  }\n\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n\n    if (strict) {\n      this.state.strictErrors.forEach((message, pos) => this.raise(pos, message));\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    const curContext = this.curContext();\n    if (!(curContext == null ? void 0 : curContext.preserveSpace)) this.skipSpace();\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.length) {\n      this.finishToken(types.eof);\n      return;\n    }\n\n    const override = curContext == null ? void 0 : curContext.override;\n\n    if (override) {\n      override(this);\n    } else {\n      this.getTokenFromCode(this.input.codePointAt(this.state.pos));\n    }\n  }\n\n  pushComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    this.state.comments.push(comment);\n    this.addComment(comment);\n  }\n\n  skipBlockComment() {\n    const startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", this.state.pos + 2);\n    if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    let match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipSpace() {\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) this.updateContext(prevType);\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.input.charCodeAt(nextPos);\n\n    if (next >= 48 && next <= 57) {\n      throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);\n    }\n\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);\n      }\n\n      if (next === 123) {\n        this.finishToken(types.braceHashL);\n      } else {\n        this.finishToken(types.bracketHashL);\n      }\n\n      this.state.pos += 2;\n    } else {\n      this.finishOp(types.hash, 1);\n    }\n  }\n\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.dot);\n    }\n  }\n\n  readToken_slash() {\n    if (this.state.exprAllowed && !this.state.inType) {\n      ++this.state.pos;\n      this.readRegexp();\n      return;\n    }\n\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.slash, 1);\n    }\n  }\n\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(types.interpreterDirective, value);\n    return true;\n  }\n\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? types.star : types.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    const exprAllowed = this.state.exprAllowed;\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61 && !exprAllowed) {\n      width++;\n      type = types.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n      }\n\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(types.pipeline, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.bracketBarR, 2);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  }\n\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())) {\n        this.skipLineComment(3);\n        this.skipSpace();\n        this.nextToken();\n        return;\n      }\n\n      this.finishOp(types.incDec, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.plusMin, 1);\n    }\n  }\n\n  readToken_lt_gt(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    let size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.state.pos + size) === 61) {\n        this.finishOp(types.assign, size + 1);\n        return;\n      }\n\n      this.finishOp(types.bitShift, size);\n      return;\n    }\n\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      this.skipLineComment(4);\n      this.skipSpace();\n      this.nextToken();\n      return;\n    }\n\n    if (next === 61) {\n      size = 2;\n    }\n\n    this.finishOp(types.relational, size);\n  }\n\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(types.arrow);\n      return;\n    }\n\n    this.finishOp(code === 61 ? types.eq : types.bang, 1);\n  }\n\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(types.nullishCoalescing, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(types.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.question);\n    }\n  }\n\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(types.parenL);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(types.parenR);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(types.semi);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(types.comma);\n        return;\n\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.bracketBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.bracketL);\n        }\n\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(types.bracketR);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.braceBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.braceL);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(types.braceR);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.colon);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 96:\n        ++this.state.pos;\n        this.finishToken(types.backQuote);\n        return;\n\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n      case 62:\n        this.readToken_lt_gt(code);\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(types.tilde, 1);\n        return;\n\n      case 64:\n        ++this.state.pos;\n        this.finishToken(types.at);\n        return;\n\n      case 35:\n        this.readToken_numberSign();\n        return;\n\n      case 92:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord();\n          return;\n        }\n\n    }\n\n    throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));\n  }\n\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp() {\n    const start = this.state.pos;\n    let escaped, inClass;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(start, ErrorMessages.UnterminatedRegExp);\n      }\n\n      const ch = this.input.charAt(this.state.pos);\n\n      if (lineBreak.test(ch)) {\n        throw this.raise(start, ErrorMessages.UnterminatedRegExp);\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n\n        escaped = ch === \"\\\\\";\n      }\n\n      ++this.state.pos;\n    }\n\n    const content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n    let mods = \"\";\n\n    while (this.state.pos < this.length) {\n      const char = this.input[this.state.pos];\n      const charCode = this.input.codePointAt(this.state.pos);\n\n      if (VALID_REGEX_FLAGS.has(char)) {\n        if (mods.indexOf(char) > -1) {\n          this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags);\n        }\n      } else if (isIdentifierChar(charCode) || charCode === 92) {\n        this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);\n      } else {\n        break;\n      }\n\n      ++this.state.pos;\n      mods += char;\n    }\n\n    this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen, allowNumSeparator = true) {\n    const start = this.state.pos;\n    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (code === 95) {\n        const prev = this.input.charCodeAt(this.state.pos - 1);\n        const next = this.input.charCodeAt(this.state.pos + 1);\n\n        if (allowedSiblings.indexOf(next) === -1) {\n          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);\n        } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {\n          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);\n        }\n\n        if (!allowNumSeparator) {\n          this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);\n        }\n\n        ++this.state.pos;\n        continue;\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } else if (code >= 65) {\n        val = code - 65 + 10;\n      } else if (_isDigit(code)) {\n        val = code - 48;\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) {\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);\n    }\n\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(start, ErrorMessages.InvalidDecimal);\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    this.finishToken(types.num, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, ErrorMessages.InvalidNumber);\n    }\n\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);\n\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n\n        if (underscorePos > 0) {\n          this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);\n        }\n      }\n\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) {\n        this.raise(start, ErrorMessages.InvalidOrMissingExponent);\n      }\n\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(start, ErrorMessages.InvalidBigIntLiteral);\n      }\n\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.pos);\n\n      if (hasExponent || hasLeadingZero) {\n        this.raise(start, ErrorMessages.InvalidDecimal);\n      }\n\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(types.decimal, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(types.num, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === 123) {\n      const codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, true, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code !== null && code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, ErrorMessages.InvalidCodePoint);\n        } else {\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n\n    return code;\n  }\n\n  readString(quote) {\n    let out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (ch === 8232 || ch === 8233) {\n        ++this.state.pos;\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(types.string, out);\n  }\n\n  readTmplToken() {\n    let out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            this.finishToken(types.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(types.backQuote);\n            return;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(types.template, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) {\n              ++this.state.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  recordStrictModeErrors(pos, message) {\n    if (this.state.strict && !this.state.strictErrors.has(pos)) {\n      this.raise(pos, message);\n    } else {\n      this.state.strictErrors.set(pos, message);\n    }\n  }\n\n  readEscapedChar(inTemplate) {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n\n      case 114:\n        return \"\\r\";\n\n      case 120:\n        {\n          const code = this.readHexChar(2, false, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          const code = this.readCodePoint(throwOnInvalid);\n          return code === null ? null : String.fromCodePoint(code);\n        }\n\n      case 116:\n        return \"\\t\";\n\n      case 98:\n        return \"\\b\";\n\n      case 118:\n        return \"\\u000b\";\n\n      case 102:\n        return \"\\f\";\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n        }\n\n      case 10:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n\n      case 8232:\n      case 8233:\n        return \"\";\n\n      case 56:\n      case 57:\n        if (inTemplate) {\n          return null;\n        } else {\n          this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);\n        }\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          const codePos = this.state.pos - 1;\n          const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);\n          let octalStr = match[0];\n          let octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n\n          if (octalStr !== \"0\" || next === 56 || next === 57) {\n            if (inTemplate) {\n              return null;\n            } else {\n              this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  readHexChar(len, forceLen, throwOnInvalid) {\n    const codePos = this.state.pos;\n    const n = this.readInt(16, len, forceLen, false);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, ErrorMessages.InvalidEscapeSequence);\n      } else {\n        this.state.pos = codePos - 1;\n      }\n    }\n\n    return n;\n  }\n\n  readWord1() {\n    let word = \"\";\n    this.state.containsEsc = false;\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    while (this.state.pos < this.length) {\n      const ch = this.input.codePointAt(this.state.pos);\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (this.state.isIterator && ch === 64) {\n        ++this.state.pos;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.pos;\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  isIterator(word) {\n    return word === \"@@iterator\" || word === \"@@asyncIterator\";\n  }\n\n  readWord() {\n    const word = this.readWord1();\n    const type = keywords.get(word) || types.name;\n\n    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {\n      this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word);\n    }\n\n    this.finishToken(type, word);\n  }\n\n  checkKeywordEscapes() {\n    const kw = this.state.type.keyword;\n\n    if (kw && this.state.containsEsc) {\n      this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);\n    }\n  }\n\n  braceIsBlock(prevType) {\n    const parent = this.curContext();\n\n    if (parent === types$1.functionExpression || parent === types$1.functionStatement) {\n      return true;\n    }\n\n    if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {\n      return !parent.isExpr;\n    }\n\n    if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {\n      return this.hasPrecedingLineBreak();\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return parent === types$1.braceStatement;\n    }\n\n    if (prevType === types._var || prevType === types._const || prevType === types.name) {\n      return false;\n    }\n\n    if (prevType === types.relational) {\n      return true;\n    }\n\n    return !this.state.exprAllowed;\n  }\n\n  updateContext(prevType) {\n    const type = this.state.type;\n    let update;\n\n    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  }\n\n}\n\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, val) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    extra[key] = val;\n  }\n\n  isRelational(op) {\n    return this.match(types.relational) && this.state.value === op;\n  }\n\n  expectRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, types.relational);\n    }\n  }\n\n  isContextual(name) {\n    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));\n  }\n\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(name) {\n    return this.isContextual(name) && this.eat(types.name);\n  }\n\n  expectContextual(name, message) {\n    if (!this.eatContextual(name)) this.unexpected(null, message);\n  }\n\n  canInsertSemicolon() {\n    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();\n  }\n\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n  }\n\n  hasFollowingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.end, this.nextTokenStart()));\n  }\n\n  isLineTerminator() {\n    return this.eat(types.semi) || this.canInsertSemicolon();\n  }\n\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(types.semi)) return;\n    this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);\n  }\n\n  expect(type, pos) {\n    this.eat(type) || this.unexpected(pos, type);\n  }\n\n  assertNoSpace(message = \"Unexpected space.\") {\n    if (this.state.start > this.state.lastTokEnd) {\n      this.raise(this.state.lastTokEnd, message);\n    }\n  }\n\n  unexpected(pos, messageOrType = \"Unexpected token\") {\n    if (typeof messageOrType !== \"string\") {\n      messageOrType = `Unexpected token, expected \"${messageOrType.label}\"`;\n    }\n\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n  }\n\n  expectPlugin(name, pos) {\n    if (!this.hasPlugin(name)) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: [name]\n      }, `This experimental syntax requires enabling the parser plugin: '${name}'`);\n    }\n\n    return true;\n  }\n\n  expectOnePlugin(names, pos) {\n    if (!names.some(n => this.hasPlugin(n))) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: names\n      }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\", \")}'`);\n    }\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssign,\n      doubleProto\n    } = refExpressionErrors;\n    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;\n\n    if (shorthandAssign >= 0) {\n      this.unexpected(shorthandAssign);\n    }\n\n    if (doubleProto >= 0) {\n      this.raise(doubleProto, ErrorMessages.DuplicateProto);\n    }\n  }\n\n  isLiteralPropertyName() {\n    return this.match(types.name) || !!this.state.type.keyword || this.match(types.string) || this.match(types.num) || this.match(types.bigint) || this.match(types.decimal);\n  }\n\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssign = -1;\n    this.doubleProto = -1;\n  }\n\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.loc = void 0;\n    this.range = void 0;\n    this.leadingComments = void 0;\n    this.trailingComments = void 0;\n    this.innerComments = void 0;\n    this.extra = void 0;\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser == null ? void 0 : parser.options.ranges) this.range = [pos, 0];\n    if (parser == null ? void 0 : parser.filename) this.loc.filename = parser.filename;\n  }\n\n  __clone() {\n    const newNode = new Node();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  }\n\n}\n\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, pos, loc) {\n\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {\n    node.end = end;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = end;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n\n}\n\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\n\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n\n    let parenthesized = undefined;\n\n    if (node.type === \"ParenthesizedExpression\" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {\n      parenthesized = unwrapParenthesizedExpression(node);\n\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n        }\n      } else {\n        this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (isLast && prop.type === \"RestElement\" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {\n            this.raiseRestNotLast(node.extra.trailingComma);\n          }\n        }\n\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value, isLHS);\n        break;\n\n      case \"SpreadElement\":\n        {\n          this.checkToRestConversion(node);\n          node.type = \"RestElement\";\n          const arg = node.argument;\n          this.toAssignable(arg, isLHS);\n          break;\n        }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n\n    return node;\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      const error = prop.kind === \"get\" || prop.kind === \"set\" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;\n      this.raise(prop.key.start, error);\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raiseRestNotLast(prop.start);\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaPos, isLHS) {\n    let end = exprList.length;\n\n    if (end) {\n      const last = exprList[end - 1];\n\n      if ((last == null ? void 0 : last.type) === \"RestElement\") {\n        --end;\n      } else if ((last == null ? void 0 : last.type) === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        let arg = last.argument;\n        this.toAssignable(arg, isLHS);\n        arg = unwrapParenthesizedExpression(arg);\n\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\" && arg.type !== \"ObjectPattern\") {\n          this.unexpected(arg.start);\n        }\n\n        if (trailingCommaPos) {\n          this.raiseTrailingCommaAfterRest(trailingCommaPos);\n        }\n\n        --end;\n      }\n    }\n\n    for (let i = 0; i < end; i++) {\n      const elt = exprList[i];\n\n      if (elt) {\n        this.toAssignable(elt, isLHS);\n\n        if (elt.type === \"RestElement\") {\n          this.raiseRestNotLast(elt.start);\n        }\n      }\n    }\n\n    return exprList;\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (let _i = 0; _i < exprList.length; _i++) {\n      const expr = exprList[_i];\n\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refExpressionErrors, refNeedsArrowPos) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types.bracketL:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(types.bracketR, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case types.braceL:\n        return this.parseObjectLike(types.braceR, true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n      }\n\n      if (allowEmpty && this.match(types.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(types.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        this.checkCommaAfterRest(closeCharCode);\n        this.expect(close);\n        break;\n      } else {\n        const decorators = [];\n\n        if (this.match(types.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);\n        }\n\n        while (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    var _startLoc, _startPos, _left;\n\n    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;\n    startPos = (_startPos = startPos) != null ? _startPos : this.state.start;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(types.eq)) return left;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  checkLVal(expr, contextDescription, bindingType = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged = false) {\n    switch (expr.type) {\n      case \"Identifier\":\n        {\n          const {\n            name\n          } = expr;\n\n          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {\n            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);\n          }\n\n          if (checkClashes) {\n            if (checkClashes.has(name)) {\n              this.raise(expr.start, ErrorMessages.ParamDupe);\n            } else {\n              checkClashes.add(name);\n            }\n          }\n\n          if (disallowLetBinding && name === \"let\") {\n            this.raise(expr.start, ErrorMessages.LetInLexicalBinding);\n          }\n\n          if (!(bindingType & BIND_NONE)) {\n            this.scope.declareName(name, bindingType, expr.start);\n          }\n\n          break;\n        }\n\n      case \"MemberExpression\":\n        if (bindingType !== BIND_NONE) {\n          this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n        for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {\n          let prop = _expr$properties[_i2];\n          if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;\n          this.checkLVal(prop, \"object destructuring pattern\", bindingType, checkClashes, disallowLetBinding);\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {\n          const elem = _expr$elements[_i3];\n\n          if (elem) {\n            this.checkLVal(elem, \"array destructuring pattern\", bindingType, checkClashes, disallowLetBinding);\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, \"assignment pattern\", bindingType, checkClashes);\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, \"rest element\", bindingType, checkClashes);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, \"parenthesized expression\", bindingType, checkClashes);\n        break;\n\n      default:\n        {\n          this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);\n        }\n    }\n  }\n\n  checkToRestConversion(node) {\n    if (node.argument.type !== \"Identifier\" && node.argument.type !== \"MemberExpression\") {\n      this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);\n    }\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.match(types.comma)) {\n      if (this.lookaheadCharCode() === close) {\n        this.raiseTrailingCommaAfterRest(this.state.start);\n      } else {\n        this.raiseRestNotLast(this.state.start);\n      }\n    }\n  }\n\n  raiseRestNotLast(pos) {\n    throw this.raise(pos, ErrorMessages.ElementAfterRest);\n  }\n\n  raiseTrailingCommaAfterRest(pos) {\n    this.raise(pos, ErrorMessages.RestTrailingComma);\n  }\n\n}\n\nconst kExpression = 0,\n      kMaybeArrowParameterDeclaration = 1,\n      kMaybeAsyncArrowParameterDeclaration = 2,\n      kParameterDeclaration = 3;\n\nclass ExpressionScope {\n  constructor(type = kExpression) {\n    this.type = void 0;\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration() {\n    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n\n}\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.errors = new Map();\n  }\n\n  recordDeclarationError(pos, message) {\n    this.errors.set(pos, message);\n  }\n\n  clearDeclarationError(pos) {\n    this.errors.delete(pos);\n  }\n\n  iterateErrors(iterator) {\n    this.errors.forEach(iterator);\n  }\n\n}\n\nclass ExpressionScopeHandler {\n  constructor(raise) {\n    this.stack = [new ExpressionScope()];\n    this.raise = raise;\n  }\n\n  enter(scope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  recordParameterInitializerError(pos, message) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(pos, message);\n      } else {\n        return;\n      }\n\n      scope = stack[--i];\n    }\n\n    this.raise(pos, message);\n  }\n\n  recordParenthesizedIdentifierError(pos, message) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.raise(pos, message);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(pos, message);\n    } else {\n      return;\n    }\n  }\n\n  recordAsyncArrowParametersError(pos, message) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        scope.recordDeclarationError(pos, message);\n      }\n\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors((message, pos) => {\n      this.raise(pos, message);\n      let i = stack.length - 2;\n      let scope = stack[i];\n\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(pos);\n        scope = stack[--i];\n      }\n    });\n  }\n\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\n\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(key.start, ErrorMessages.RecordNoProto);\n        return;\n      }\n\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProto === -1) {\n            refExpressionErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raise(key.start, ErrorMessages.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n\n  getExpression() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    this.nextToken();\n    const expr = this.parseExpression();\n\n    if (!this.match(types.eof)) {\n      this.unexpected();\n    }\n\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    return expr;\n  }\n\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  parseExpressionBase(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n\n    if (this.match(types.comma)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(types.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));\n  }\n\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    if (this.isContextual(\"yield\")) {\n      if (this.prodParam.hasYield) {\n        this.state.exprAllowed = true;\n        let left = this.parseYield();\n\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n\n    if (this.match(types.parenL) || this.match(types.name)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors, refNeedsArrowPos);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (this.state.type.isAssign) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(types.eq)) {\n        node.left = this.toAssignable(left, true);\n        refExpressionErrors.doubleProto = -1;\n      } else {\n        node.left = left;\n      }\n\n      if (refExpressionErrors.shorthandAssign >= node.left.start) {\n        refExpressionErrors.shorthandAssign = -1;\n      }\n\n      this.checkLVal(left, \"assignment expression\");\n      this.next();\n      node.right = this.parseMaybeAssign();\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  parseMaybeConditional(refExpressionErrors, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);\n  }\n\n  parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {\n    if (this.eat(types.question)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprOps(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnary(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    let prec = this.state.type.binop;\n\n    if (prec != null && (this.prodParam.hasIn || !this.match(types._in))) {\n      if (prec > minPrec) {\n        const op = this.state.type;\n\n        if (op === types.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n\n          this.state.inPipeline = true;\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\n        }\n\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n\n        if (op === types.exponent && left.type === \"UnaryExpression\" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {\n          this.raise(left.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);\n        }\n\n        const logical = op === types.logicalOR || op === types.logicalAND;\n        const coalesce = op === types.nullishCoalescing;\n\n        if (coalesce) {\n          prec = types.logicalAND.binop;\n        }\n\n        this.next();\n\n        if (op === types.pipeline && this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\") {\n          if (this.match(types.name) && this.state.value === \"await\" && this.prodParam.hasAwait) {\n            throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n\n        if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {\n          throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);\n        }\n\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n      }\n    }\n\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    switch (op) {\n      case types.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"smart\":\n            return this.withTopicPermittingContext(() => {\n              return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(\"await\");\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      return this.parseAwait(startPos, startLoc);\n    }\n\n    const update = this.match(types.incDec);\n    const node = this.startNode();\n\n    if (this.state.type.prefix) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(types._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      const isDelete = this.match(types._delete);\n      this.next();\n      node.argument = this.parseMaybeUnary();\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(node.start, ErrorMessages.StrictDelete);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(node.start, ErrorMessages.DeletePrivateField);\n        }\n      }\n\n      if (!update) {\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n\n    if (isAwait) {\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(types.modulo);\n\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(startPos, this.hasPlugin(\"topLevelAwait\") ? ErrorMessages.AwaitNotInAsyncContext : ErrorMessages.AwaitNotInAsyncFunction);\n        return this.parseAwait(startPos, startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      this.checkLVal(node.argument, \"prefix operation\");\n      return this.finishNode(node, \"UpdateExpression\");\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.checkLVal(expr, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(node, \"UpdateExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprSubscripts(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n\n    return base;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      return this.parseBind(base, startPos, startLoc, noCalls, state);\n    } else if (this.match(types.backQuote)) {\n      return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (this.match(types.questionDot)) {\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(types.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);\n    } else if (optional || this.match(types.bracketL) || this.eat(types.dot)) {\n      return this.parseMember(base, startPos, startLoc, state, optional);\n    } else {\n      state.stop = true;\n      return base;\n    }\n  }\n\n  parseMember(base, startPos, startLoc, state, optional) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const computed = this.eat(types.bracketL);\n    node.object = base;\n    node.computed = computed;\n    const property = computed ? this.parseExpression() : this.parseMaybePrivateName(true);\n\n    if (this.isPrivateName(property)) {\n      if (node.object.type === \"Super\") {\n        this.raise(startPos, ErrorMessages.SuperPrivateField);\n      }\n\n      this.classScope.usePrivateName(this.getPrivateNameSV(property), property.start);\n    }\n\n    node.property = property;\n\n    if (computed) {\n      this.expect(types.bracketR);\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  parseBind(base, startPos, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n  }\n\n  parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    let node = this.startNodeAt(startPos, startLoc);\n    node.callee = base;\n\n    if (state.maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === \"Import\", base.type !== \"Super\", node);\n    }\n\n    this.finishCallExpression(node, state.optionalChainMember);\n\n    if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);\n    } else {\n      if (state.maybeAsyncArrow) {\n        this.expressionScope.exit();\n      }\n\n      this.toReferencedArguments(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  parseTaggedTemplateExpression(base, startPos, startLoc, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n\n    if (state.optionalChainMember) {\n      this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);\n    }\n\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        if (!this.hasPlugin(\"moduleAttributes\")) {\n          this.expectPlugin(\"importAssertions\");\n        }\n      }\n\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? \"one or two arguments\" : \"one argument\");\n      } else {\n        for (let _i = 0, _node$arguments = node.arguments; _i < _node$arguments.length; _i++) {\n          const arg = _node$arguments[_i];\n\n          if (arg.type === \"SpreadElement\") {\n            this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);\n          }\n        }\n      }\n    }\n\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n\n  parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);\n          }\n\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, allowPlaceholder));\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.state.type === types.slash) this.readRegexp();\n    const canBeArrow = this.state.potentialArrowAt === this.state.start;\n    let node;\n\n    switch (this.state.type) {\n      case types._super:\n        return this.parseSuper();\n\n      case types._import:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(types.dot)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(types.parenL)) {\n          this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case types._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case types.name:\n        {\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            if (this.match(types._function)) {\n              const last = this.state.context.length - 1;\n\n              if (this.state.context[last] !== types$1.functionStatement) {\n                throw new Error(\"Internal error\");\n              }\n\n              this.state.context[last] = types$1.functionExpression;\n              this.next();\n              return this.parseFunction(this.startNodeAtNode(id), undefined, true);\n            } else if (this.match(types.name)) {\n              return this.parseAsyncArrowUnaryFunction(id);\n            }\n          }\n\n          if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n\n          return id;\n        }\n\n      case types._do:\n        {\n          return this.parseDo();\n        }\n\n      case types.regexp:\n        {\n          const value = this.state.value;\n          node = this.parseLiteral(value.value, \"RegExpLiteral\");\n          node.pattern = value.pattern;\n          node.flags = value.flags;\n          return node;\n        }\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n      case types.decimal:\n        return this.parseLiteral(this.state.value, \"DecimalLiteral\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n      case types._null:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"NullLiteral\");\n\n      case types._true:\n      case types._false:\n        return this.parseBooleanLiteral();\n\n      case types.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case types.bracketBarL:\n      case types.bracketHashL:\n        {\n          return this.parseArrayLike(this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR, false, true, refExpressionErrors);\n        }\n\n      case types.bracketL:\n        {\n          return this.parseArrayLike(types.bracketR, true, false, refExpressionErrors);\n        }\n\n      case types.braceBarL:\n      case types.braceHashL:\n        {\n          return this.parseObjectLike(this.state.type === types.braceBarL ? types.braceBarR : types.braceR, false, true, refExpressionErrors);\n        }\n\n      case types.braceL:\n        {\n          return this.parseObjectLike(types.braceR, false, false, refExpressionErrors);\n        }\n\n      case types._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case types.at:\n        this.parseDecorators();\n\n      case types._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case types._new:\n        return this.parseNewOrNewTarget();\n\n      case types.backQuote:\n        return this.parseTemplate(false);\n\n      case types.doubleColon:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(callee.start, ErrorMessages.UnsupportedBind);\n          }\n        }\n\n      case types.hash:\n        {\n          if (this.state.inPipeline) {\n            node = this.startNode();\n\n            if (this.getPluginOption(\"pipelineOperator\", \"proposal\") !== \"smart\") {\n              this.raise(node.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);\n            }\n\n            this.next();\n\n            if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {\n              this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed);\n            }\n\n            this.registerTopicReference();\n            return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n          }\n\n          const nextCh = this.input.codePointAt(this.state.end);\n\n          if (isIdentifierStart(nextCh) || nextCh === 92) {\n            const start = this.state.start;\n            node = this.parseMaybePrivateName(true);\n\n            if (this.match(types._in)) {\n              this.expectPlugin(\"privateIn\");\n              this.classScope.usePrivateName(node.id.name, node.start);\n            } else if (this.hasPlugin(\"privateIn\")) {\n              this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, node.id.name);\n            } else {\n              throw this.unexpected(start);\n            }\n\n            return node;\n          }\n        }\n\n      case types.relational:\n        {\n          if (this.state.value === \"<\") {\n            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n\n            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n                this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n              }\n          }\n        }\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseAsyncArrowUnaryFunction(id) {\n    const node = this.startNodeAtNode(id);\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);\n    }\n\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, params, true);\n    return node;\n  }\n\n  parseDo() {\n    this.expectPlugin(\"doExpressions\");\n    const node = this.startNode();\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    node.body = this.parseBlock();\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(node.start, ErrorMessages.SuperNotAllowed);\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(node.start, ErrorMessages.UnexpectedSuper);\n    }\n\n    if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n      this.raise(node.start, ErrorMessages.UnsupportedSuper);\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parseBooleanLiteral() {\n    const node = this.startNode();\n    node.value = this.match(types._true);\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseMaybePrivateName(isPrivateNameAllowed) {\n    const isPrivate = this.match(types.hash);\n\n    if (isPrivate) {\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n\n      if (!isPrivateNameAllowed) {\n        this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);\n      }\n\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space between # and identifier\");\n      node.id = this.parseIdentifier(true);\n      return this.finishNode(node, \"PrivateName\");\n    } else {\n      return this.parseIdentifier(true);\n    }\n  }\n\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.prodParam.hasYield && this.match(types.dot)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n\n    if (meta.name === \"function\" && propertyName === \"sent\") {\n      if (this.isContextual(propertyName)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n    }\n\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n\n    if (this.isContextual(\"meta\")) {\n      if (!this.inModule) {\n        this.raiseWithData(id.start, {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        }, ErrorMessages.ImportMetaOutsideModule);\n      }\n\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    const node = this.startNodeAt(startPos, startLoc);\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    const refNeedsArrowPos = {\n      start: 0\n    };\n    let first = true;\n    let spreadStart;\n    let optionalCommaStart;\n\n    while (!this.match(types.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma, refNeedsArrowPos.start || null);\n\n        if (this.match(types.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(types.ellipsis)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));\n        this.checkCommaAfterRest(41);\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos));\n      }\n    }\n\n    const innerEndPos = this.state.lastTokEnd;\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(types.parenR);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n    this.toReferencedListDeep(exprList, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(val, \"parenthesized\", true);\n      this.addExtra(val, \"parenStart\", startPos);\n      return val;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = val;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  shouldParseArrow() {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node) {\n    if (this.eat(types.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    return node;\n  }\n\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(types.dot)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        let error = ErrorMessages.UnexpectedNewTarget;\n\n        if (this.hasPlugin(\"classProperties\")) {\n          error += \" or class properties\";\n        }\n\n        this.raise(metaProp.start, error);\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node);\n  }\n\n  parseNew(node) {\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"Import\") {\n      this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);\n    } else if (this.eat(types.questionDot)) {\n      this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewArguments(node) {\n    if (this.eat(types.parenL)) {\n      const args = this.parseExprList(types.parenR);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const elem = this.startNode();\n\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);\n      }\n    }\n\n    elem.value = {\n      raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value\n    };\n    this.next();\n    elem.tail = this.match(types.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    this.next();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n          break;\n        }\n      }\n\n      const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);\n\n      if (!isPattern) {\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(prop.start, ErrorMessages.InvalidRecordProperty);\n      }\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    this.state.exprAllowed = false;\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n\n    return this.finishNode(node, type);\n  }\n\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(types.bracketL) || this.match(types.star));\n  }\n\n  parsePropertyDefinition(isPattern, refExpressionErrors) {\n    let decorators = [];\n\n    if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);\n      }\n\n      while (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isGenerator = false;\n    let isAsync = false;\n    let isAccessor = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(types.ellipsis)) {\n      if (decorators.length) this.unexpected();\n\n      if (isPattern) {\n        this.next();\n        prop.argument = this.parseIdentifier();\n        this.checkCommaAfterRest(125);\n        return this.finishNode(prop, \"RestElement\");\n      }\n\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (isPattern || refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, false);\n\n    if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        isGenerator = this.eat(types.star);\n        this.parsePropertyName(prop, false);\n      }\n\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        prop.kind = keyName;\n\n        if (this.match(types.star)) {\n          isGenerator = true;\n          this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);\n          this.next();\n        }\n\n        this.parsePropertyName(prop, false);\n      }\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    return prop;\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n\n  checkGetterSetterParams(method) {\n    var _params;\n\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const start = method.start;\n\n    if (params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, ErrorMessages.BadGetterArity);\n      } else {\n        this.raise(start, ErrorMessages.BadSetterArity);\n      }\n    }\n\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(start, ErrorMessages.BadSetterRestParameter);\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n\n    if (isAsync || isGenerator || this.match(types.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else if (this.match(types.eq) && refExpressionErrors) {\n        if (refExpressionErrors.shorthandAssign === -1) {\n          refExpressionErrors.shorthandAssign = this.state.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else {\n        prop.value = prop.key.__clone();\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop, isPrivateNameAllowed) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(types.bracketR);\n    } else {\n      const oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true;\n      prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) || this.match(types.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);\n\n      if (!this.isPrivateName(prop.key)) {\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return node;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaPos) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n\n    if (!this.match(types.bracketL) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaPos);\n    }\n\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(node, params, trailingCommaPos) {\n    node.params = this.toAssignableList(params, trailingCommaPos, false);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(types.braceL);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n\n        if (hasStrictModeDirective && nonSimple) {\n          const errorPos = (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.end : node.start;\n          this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);\n        }\n\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n\n        if (this.state.strict && node.id) {\n          this.checkLVal(node.id, \"function name\", BIND_OUTSIDE, undefined, undefined, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.expressionScope.exit();\n      this.state.labels = oldLabels;\n    }\n  }\n\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (params[i].type !== \"Identifier\") return false;\n    }\n\n    return true;\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = new Set();\n\n    for (let _i2 = 0, _node$params = node.params; _i2 < _node$params.length; _i2++) {\n      const param = _node$params[_i2];\n      this.checkLVal(param, \"function parameter list\", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);\n    }\n  }\n\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n\n    return elts;\n  }\n\n  parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {\n    let elt;\n\n    if (this.match(types.comma)) {\n      if (!allowEmpty) {\n        this.raise(this.state.pos, ErrorMessages.UnexpectedToken, \",\");\n      }\n\n      elt = null;\n    } else if (this.match(types.ellipsis)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);\n    } else if (this.match(types.question)) {\n      this.expectPlugin(\"partialApplication\");\n\n      if (!allowPlaceholder) {\n        this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);\n      }\n\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos);\n    }\n\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos, liberal) {\n    let name;\n    const {\n      start,\n      type\n    } = this.state;\n\n    if (type === types.name) {\n      name = this.state.value;\n    } else if (type.keyword) {\n      name = type.keyword;\n      const curContext = this.curContext();\n\n      if ((type === types._class || type === types._function) && (curContext === types$1.functionStatement || curContext === types$1.functionExpression)) {\n        this.state.context.pop();\n      }\n    } else {\n      throw this.unexpected();\n    }\n\n    if (liberal) {\n      this.state.type = types.name;\n    } else {\n      this.checkReservedWord(name, start, !!type.keyword, false);\n    }\n\n    this.next();\n    return name;\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (this.prodParam.hasYield && word === \"yield\") {\n      this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);\n      return;\n    }\n\n    if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);\n        return;\n      } else if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction) {\n        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);\n        return;\n      } else {\n        this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);\n      }\n    }\n\n    if (this.scope.inClass && !this.scope.inNonArrowFunction && word === \"arguments\") {\n      this.raise(startLoc, ErrorMessages.ArgumentsInClass);\n      return;\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);\n      return;\n    }\n\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);\n    }\n  }\n\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait) return true;\n\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n\n    return false;\n  }\n\n  parseAwait(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);\n\n    if (this.eat(types.star)) {\n      this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary();\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait() {\n    return this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin(\"v8intrinsic\") && this.match(types.modulo);\n  }\n\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);\n    this.next();\n\n    if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartPos) {\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);\n      }\n    }\n  }\n\n  parseSmartPipelineBody(childExpression, startPos, startLoc) {\n    this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);\n    return this.parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc);\n  }\n\n  checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {\n    if (this.match(types.arrow)) {\n      throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);\n    } else if (childExpression.type === \"SequenceExpression\") {\n      this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n    const isSimpleReference = this.isSimpleReference(childExpression);\n\n    if (isSimpleReference) {\n      bodyNode.callee = childExpression;\n    } else {\n      if (!this.topicReferenceWasUsedInCurrentTopicContext()) {\n        this.raise(startPos, ErrorMessages.PipelineTopicUnused);\n      }\n\n      bodyNode.expression = childExpression;\n    }\n\n    return this.finishNode(bodyNode, isSimpleReference ? \"PipelineBareFunction\" : \"PipelineTopicExpression\");\n  }\n\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  withTopicPermittingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withTopicForbiddingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  primaryTopicReferenceIsAllowedInCurrentTopicContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentTopicContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n\n  parseFSharpPipelineBody(prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n}\n\nconst loopLabel = {\n  kind: \"loop\"\n},\n      switchLabel = {\n  kind: \"switch\"\n};\nconst FUNC_NO_FLAGS = 0b000,\n      FUNC_STATEMENT = 0b001,\n      FUNC_HANGING_STATEMENT = 0b010,\n      FUNC_NULLABLE_ID = 0b100;\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    program.sourceType = this.options.sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, types.eof);\n\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (let _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {\n        const [name] = _Array$from[_i];\n        const pos = this.scope.undefinedExports.get(name);\n        this.raise(pos, ErrorMessages.ModuleExportUndefined, name);\n      }\n    }\n\n    file.program = this.finishNode(program, \"Program\");\n    file.comments = this.state.comments;\n    if (this.options.tokens) file.tokens = this.tokens;\n    return this.finishNode(file, \"File\");\n  }\n\n  stmtToDirective(stmt) {\n    const expr = stmt.expression;\n    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n    const directive = this.startNodeAt(stmt.start, stmt.loc.start);\n    const raw = this.input.slice(expr.start, expr.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n  }\n\n  parseInterpreterDirective() {\n    if (!this.match(types.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context) {\n    if (!this.isContextual(\"let\")) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const nextCh = this.input.charCodeAt(next);\n    if (nextCh === 91) return true;\n    if (context) return false;\n    if (nextCh === 123) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      let pos = next + 1;\n\n      while (isIdentifierChar(this.input.charCodeAt(pos))) {\n        ++pos;\n      }\n\n      const ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) return true;\n    }\n\n    return false;\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.match(types.at)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context, topLevel) {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case types._break:\n      case types._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case types._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case types._do:\n        return this.parseDoStatement(node);\n\n      case types._for:\n        return this.parseForStatement(node);\n\n      case types._function:\n        if (this.lookaheadCharCode() === 46) break;\n\n        if (context) {\n          if (this.state.strict) {\n            this.raise(this.state.start, ErrorMessages.StrictFunction);\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(this.state.start, ErrorMessages.SloppyFunction);\n          }\n        }\n\n        return this.parseFunctionStatement(node, false, !context);\n\n      case types._class:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case types._if:\n        return this.parseIfStatement(node);\n\n      case types._return:\n        return this.parseReturnStatement(node);\n\n      case types._switch:\n        return this.parseSwitchStatement(node);\n\n      case types._throw:\n        return this.parseThrowStatement(node);\n\n      case types._try:\n        return this.parseTryStatement(node);\n\n      case types._const:\n      case types._var:\n        kind = kind || this.state.value;\n\n        if (context && kind !== \"var\") {\n          this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case types._while:\n        return this.parseWhileStatement(node);\n\n      case types._with:\n        return this.parseWithStatement(node);\n\n      case types.braceL:\n        return this.parseBlock();\n\n      case types.semi:\n        return this.parseEmptyStatement(node);\n\n      case types._import:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n              break;\n            }\n        }\n\n      case types._export:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);\n          }\n\n          this.next();\n          let result;\n\n          if (starttype === types._import) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);\n            }\n\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raiseWithData(node.start, {\n        code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n      }, ErrorMessages.ImportOutsideModule);\n    }\n  }\n\n  takeDecorators(node) {\n    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator() {\n    return this.match(types._class);\n  }\n\n  parseDecorators(allowExport) {\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(types.at)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(types._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, ErrorMessages.DecoratorExportClass);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);\n    }\n  }\n\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      this.state.decoratorStack.push([]);\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr;\n\n      if (this.eat(types.parenL)) {\n        expr = this.parseExpression();\n        this.expect(types.parenR);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(types.dot)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(types.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(node, keyword) {\n    const isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, keyword);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n\n  verifyBreakContinue(node, keyword) {\n    const isBreak = keyword === \"break\";\n    let i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);\n    }\n  }\n\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression() {\n    this.expect(types.parenL);\n    const val = this.parseExpression();\n    this.expect(types.parenR);\n    return val;\n  }\n\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(types.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = -1;\n\n    if (this.isAwaitAllowed() && this.eatContextual(\"await\")) {\n      awaitAt = this.state.lastTokStart;\n    }\n\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.parenL);\n\n    if (this.match(types.semi)) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    const isLet = this.isLet();\n\n    if (this.match(types._var) || this.match(types._const) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if ((this.match(types._in) || this.isContextual(\"of\")) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init);\n    }\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      this.toAssignable(init, true);\n      const description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n      this.checkLVal(init, description);\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, ErrorMessages.IllegalReturn);\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(types.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n\n    for (let sawDefault; !this.match(types.braceR);) {\n      if (this.match(types._case) || this.match(types._default)) {\n        const isCase = this.match(types._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(types.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node) {\n    this.next();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, \"catch clause\", BIND_LEXICAL);\n    return param;\n  }\n\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(types._catch)) {\n      const clause = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL)) {\n        this.expect(types.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(types.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, ErrorMessages.NoCatchOrFinally);\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(this.state.start, ErrorMessages.StrictWith);\n    }\n\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (let _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {\n      const label = _this$state$labels[_i2];\n\n      if (label.name === maybeName) {\n        this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);\n      }\n    }\n\n    const kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n\n    this.expect(types.braceL);\n\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n\n    this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);\n\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(types.semi) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(types.parenR) ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(types._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt > -1) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt > -1;\n    }\n\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? \"for-in\" : \"for-of\");\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, ErrorMessages.InvalidLhs, \"for-loop\");\n    }\n\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind) {\n    const declarations = node.declarations = [];\n    const isTypescript = this.hasPlugin(\"typescript\");\n    node.kind = kind;\n\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n\n      if (this.eat(types.eq)) {\n        decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      } else {\n        if (kind === \"const\" && !(this.match(types._in) || this.isContextual(\"of\"))) {\n          if (!isTypescript) {\n            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, \"Const declarations\");\n          }\n        } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n          this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, \"Complex binding patterns\");\n        }\n\n        decl.init = null;\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) break;\n    }\n\n    return node;\n  }\n\n  parseVarId(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, \"variable declaration\", kind === \"var\" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== \"var\");\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n\n    if (this.match(types.star) && isHangingStatement) {\n      this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);\n    }\n\n    node.generator = this.eat(types.star);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, false);\n    this.withTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  parseFunctionId(requireId) {\n    return requireId || this.match(types.name) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    this.expect(types.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n\n  isClassProperty() {\n    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n  }\n\n  isClassMethod() {\n    return this.match(types.parenL);\n  }\n\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n\n  parseClassBody(constructorAllowsSuper, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      constructorAllowsSuper,\n      hadConstructor: false,\n      hadStaticBlock: false\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(types.braceL);\n    this.withTopicForbiddingContext(() => {\n      while (!this.match(types.braceR)) {\n        if (this.eat(types.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);\n          }\n\n          continue;\n        }\n\n        if (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(member.start, ErrorMessages.DecoratorConstructor);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n\n    if (decorators.length) {\n      throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);\n    }\n\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n\n    return false;\n  }\n\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(\"static\");\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      if (this.eat(types.braceL)) {\n        this.parseClassStaticBlock(classBody, member, state);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n\n    if (this.eat(types.star)) {\n      method.kind = \"method\";\n      this.parseClassElementName(method);\n\n      if (this.isPrivateName(method.key)) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parseClassElementName(member);\n    const isPrivate = this.isPrivateName(key);\n    const isSimple = key.type === \"Identifier\";\n    const maybeQuestionTokenStart = this.state.start;\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, ErrorMessages.DuplicateConstructor);\n        }\n\n        state.hadConstructor = true;\n        allowsDirectSuper = state.constructorAllowsSuper;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isSimple && key.name === \"async\" && !containsEsc && !this.isLineTerminator()) {\n      const isGenerator = this.eat(types.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStart);\n      }\n\n      method.kind = \"method\";\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (this.isPrivateName(method.key)) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isSimple && (key.name === \"get\" || key.name === \"set\") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {\n      method.kind = key.name;\n      this.parseClassElementName(publicMethod);\n\n      if (this.isPrivateName(method.key)) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassElementName(member) {\n    const key = this.parsePropertyName(member, true);\n\n    if (!member.computed && member.static && (key.name === \"prototype\" || key.value === \"prototype\")) {\n      this.raise(key.start, ErrorMessages.StaticPrototype);\n    }\n\n    if (this.isPrivateName(key) && this.getPrivateNameSV(key) === \"constructor\") {\n      this.raise(key.start, ErrorMessages.ConstructorClassPrivateField);\n    }\n\n    return key;\n  }\n\n  parseClassStaticBlock(classBody, member, state) {\n    var _member$decorators;\n\n    this.expectPlugin(\"classStaticBlock\", member.start);\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(PARAM);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, types.braceR);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n\n    if (state.hadStaticBlock) {\n      this.raise(member.start, ErrorMessages.DuplicateStaticBlock);\n    }\n\n    if ((_member$decorators = member.decorators) == null ? void 0 : _member$decorators.length) {\n      this.raise(member.start, ErrorMessages.DecoratorStaticBlock);\n    }\n\n    state.hadStaticBlock = true;\n  }\n\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(prop.key.start, ErrorMessages.ConstructorClassField);\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(classBody, prop) {\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {}\n\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    if (!node.typeAnnotation || this.match(types.eq)) {\n      this.expectPlugin(\"classProperties\");\n    }\n\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseInitializer(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(types.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (this.match(types.name)) {\n      node.id = this.parseIdentifier();\n\n      if (isStatement) {\n        this.checkLVal(node.id, \"class name\", bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, ErrorMessages.MissingClassName);\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(types.comma);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, types.braceL);\n    }\n\n    let hasDeclaration;\n\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(types._default)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, types.braceL);\n  }\n\n  eatExportStar(node) {\n    return this.eat(types.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(\"as\")) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(types.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      node.specifiers.push(...this.parseExportSpecifiers());\n      node.source = null;\n      node.declaration = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  isAsyncFunction() {\n    if (!this.isContextual(\"async\")) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(types._function) || isAsync) {\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    } else if (this.match(types._class)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);\n      }\n\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {\n      throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);\n    } else {\n      const res = this.parseMaybeAssignAllowIn();\n      this.semicolon();\n      return res;\n    }\n  }\n\n  parseExportDeclaration(node) {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types.name)) {\n      const value = this.state.value;\n\n      if (value === \"async\" && !this.state.containsEsc || value === \"let\") {\n        return false;\n      }\n\n      if ((value === \"type\" || value === \"interface\") && !this.state.containsEsc) {\n        const l = this.lookahead();\n\n        if (l.type === types.name && l.value !== \"from\" || l.type === types.braceL) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(types._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n\n    if (this.input.charCodeAt(next) === 44 || this.match(types.name) && hasFrom) {\n      return true;\n    }\n\n    if (this.match(types._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n\n    return false;\n  }\n\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(\"from\")) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n\n      if (assertions) {\n        node.assertions = assertions;\n      }\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.match(types.at)) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isLet() || this.isAsyncFunction();\n  }\n\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n\n          const declaration = node.declaration;\n\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) == null ? void 0 : _declaration$extra.parenthesized)) {\n            this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        for (let _i3 = 0, _node$specifiers = node.specifiers; _i3 < _node$specifiers.length; _i3++) {\n          const specifier = _node$specifiers[_i3];\n          const {\n            exported\n          } = specifier;\n          const exportedName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportedName);\n\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n\n            if (local.type === \"StringLiteral\") {\n              this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);\n            } else {\n              this.checkReservedWord(local.name, local.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (let _i4 = 0, _node$declaration$dec = node.declaration.declarations; _i4 < _node$declaration$dec.length; _i4++) {\n            const declaration = _node$declaration$dec[_i4];\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);\n    }\n  }\n\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (let _i5 = 0, _node$properties = node.properties; _i5 < _node$properties.length; _i5++) {\n        const prop = _node$properties[_i5];\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (let _i6 = 0, _node$elements = node.elements; _i6 < _node$elements.length; _i6++) {\n        const elem = _node$elements[_i6];\n\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(node, name) {\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n      this.raise(node.start, name === \"default\" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);\n    }\n\n    this.state.exportedIdentifiers.push(name);\n  }\n\n  parseExportSpecifiers() {\n    const nodes = [];\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local.__clone();\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }\n\n  parseModuleExportName() {\n    if (this.match(types.string)) {\n      this.expectPlugin(\"moduleStringNames\");\n      const result = this.parseLiteral(this.state.value, \"StringLiteral\");\n      const surrogate = result.value.match(loneSurrogate);\n\n      if (surrogate) {\n        this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));\n      }\n\n      return result;\n    }\n\n    return this.parseIdentifier(true);\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n\n    if (!this.match(types.string)) {\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(types.comma);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(\"from\");\n    }\n\n    node.source = this.parseImportSource();\n    const assertions = this.maybeParseImportAssertions();\n\n    if (assertions) {\n      node.assertions = assertions;\n    } else {\n        const attributes = this.maybeParseModuleAttributes();\n\n        if (attributes) {\n          node.attributes = attributes;\n        }\n      }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    if (!this.match(types.string)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return this.match(types.name);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  parseAssertEntries() {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(types.braceR)) {\n        break;\n      }\n\n      const node = this.startNode();\n      const keyName = this.state.value;\n\n      if (this.match(types.string)) {\n        node.key = this.parseLiteral(keyName, \"StringLiteral\");\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n\n      this.expect(types.colon);\n\n      if (keyName !== \"type\") {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, keyName);\n      }\n\n      if (attrNames.has(keyName)) {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);\n      }\n\n      attrNames.add(keyName);\n\n      if (!this.match(types.string)) {\n        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);\n      }\n\n      node.value = this.parseLiteral(this.state.value, \"StringLiteral\");\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(types.comma));\n\n    return attrs;\n  }\n\n  maybeParseModuleAttributes() {\n    if (this.match(types._with) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n\n    const attrs = [];\n    const attributes = new Set();\n\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);\n      }\n\n      attributes.add(node.key.name);\n      this.expect(types.colon);\n\n      if (!this.match(types.string)) {\n        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);\n      }\n\n      node.value = this.parseLiteral(this.state.value, \"StringLiteral\");\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(types.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    if (this.isContextual(\"assert\") && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n\n    this.eat(types.braceL);\n    const attrs = this.parseAssertEntries();\n    this.eat(types.braceR);\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(types.star)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(types.colon)) {\n          throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);\n        }\n\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    specifier.imported = this.parseModuleExportName();\n\n    if (this.eatContextual(\"as\")) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n\n      if (imported.type === \"StringLiteral\") {\n        throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);\n      }\n\n      this.checkReservedWord(imported.name, specifier.start, true, true);\n      specifier.local = imported.__clone();\n    }\n\n    this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n}\n\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n\n}\nclass ClassScopeHandler {\n  constructor(raise) {\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n  }\n\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n\n    for (let _i = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i < _Array$from.length; _i++) {\n      const [name, pos] = _Array$from[_i];\n\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, pos);\n        }\n      } else {\n        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);\n      }\n    }\n  }\n\n  declarePrivateName(name, elementType, pos) {\n    const classScope = this.current();\n    let redefined = classScope.privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && classScope.loneAccessors.get(name);\n\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) classScope.loneAccessors.delete(name);\n      } else if (!redefined) {\n        classScope.loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);\n    }\n\n    classScope.privateNames.add(name);\n    classScope.undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name, pos) {\n    let classScope;\n\n    for (let _i2 = 0, _this$stack = this.stack; _i2 < _this$stack.length; _i2++) {\n      classScope = _this$stack[_i2];\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, pos);\n    } else {\n      this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);\n    }\n  }\n\n}\n\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    const ScopeHandler = this.getScopeHandler();\n    this.options = options;\n    this.inModule = this.options.sourceType === \"module\";\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\n    this.prodParam = new ProductionParameterHandler();\n    this.classScope = new ClassScopeHandler(this.raise.bind(this));\n    this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n\n  parse() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n\n}\n\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n\n  for (let _i = 0; _i < plugins.length; _i++) {\n    const plugin = plugins[_i];\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  var _options;\n\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\n\nfunction getParser(options, input) {\n  let cls = Parser;\n\n  if (options == null ? void 0 : options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (let _i = 0; _i < pluginList.length; _i++) {\n      const plugin = pluginList[_i];\n      cls = mixinPlugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n//# sourceMappingURL=index.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/Users/philopian/Development/PROJECTS/BLOG/dev-blog/node_modules/@babel/parser/lib/index.js"],"names":[],"mappings":";;;;;;AAAa;;AAEb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,GAAG;AACH,6BAA6B;AAC7B;AACA;AACA,GAAG;AACH,+BAA+B;AAC/B;AACA;AACA,GAAG;AACH,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,wBAAwB;AACxB;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iCAAiC;AACjC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,uCAAuC;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,uCAAuC;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kLAAkL;AAClL,gGAAgG,MAAM;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,eAAe;AACzI;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,mFAAmF;AACnF,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,SAAS,QAAQ,EAAE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,4DAA4D,2EAA2E,yDAAyD,uEAAuE;AACvQ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iFAAiF,SAAS,GAAG,WAAW;;AAExG;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,iFAAiF,SAAS,GAAG,WAAW;AACxG;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC,sCAAsC;AACtC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0IAA0I,yBAAyB;AACnK;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;AACP,yBAAyB,+BAA+B;AACxD;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb,iFAAiF,oCAAoC;AACrH;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,aAAa;AACb,kFAAkF,qCAAqC;AACvH;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,EAAE;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qIAAqI,EAAE;AACvI;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gJAAgJ,EAAE;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,0BAA0B;AACxF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,YAAY;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,OAAO;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,oBAAoB;AACzE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,oEAAoE,KAAK;AAChF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,wFAAwF,iBAAiB;AAChH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,YAAY;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2EAA2E,YAAY;AACvF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6DAA6D,+BAA+B;AAC5F;AACA,6DAA6D;AAC7D;AACA;;AAEA;;AAEA;AACA,yDAAyD,6BAA6B;AACtF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,0DAA0D,6BAA6B;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iDAAiD,2BAA2B;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6EAA6E,yBAAyB;AACtG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,8BAA8B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,iCAAiC;AAC9F;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,6DAA6D,+BAA+B;AAC5F;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,kFAAkF,oCAAoC;AACtH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,2DAA2D,+BAA+B;AAC1F;AACA;AACA;AACA,KAAK;AACL,uDAAuD,6BAA6B;AACpF;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mFAAmF,yBAAyB;AAC5G;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,0BAA0B;AACzE;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA,wEAAwE;AACxE,+DAA+D;AAC/D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA","file":"x","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass TokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.updateContext = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n\n}\nconst keywords = new Map();\n\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = new TokenType(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name, binop) {\n  return new TokenType(name, {\n    beforeExpr,\n    binop\n  });\n}\n\nconst types = {\n  num: new TokenType(\"num\", {\n    startsExpr\n  }),\n  bigint: new TokenType(\"bigint\", {\n    startsExpr\n  }),\n  decimal: new TokenType(\"decimal\", {\n    startsExpr\n  }),\n  regexp: new TokenType(\"regexp\", {\n    startsExpr\n  }),\n  string: new TokenType(\"string\", {\n    startsExpr\n  }),\n  name: new TokenType(\"name\", {\n    startsExpr\n  }),\n  eof: new TokenType(\"eof\"),\n  bracketL: new TokenType(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: new TokenType(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: new TokenType(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: new TokenType(\"]\"),\n  bracketBarR: new TokenType(\"|]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: new TokenType(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: new TokenType(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", {\n    beforeExpr\n  }),\n  semi: new TokenType(\";\", {\n    beforeExpr\n  }),\n  colon: new TokenType(\":\", {\n    beforeExpr\n  }),\n  doubleColon: new TokenType(\"::\", {\n    beforeExpr\n  }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", {\n    beforeExpr\n  }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", {\n    beforeExpr\n  }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", {\n    beforeExpr\n  }),\n  backQuote: new TokenType(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: new TokenType(\"#!...\"),\n  eq: new TokenType(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: new TokenType(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: new TokenType(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: new TokenType(\"%\", {\n    beforeExpr,\n    binop: 10,\n    startsExpr\n  }),\n  star: new TokenType(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: new TokenType(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  })\n};\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass Position {\n  constructor(line, col) {\n    this.line = void 0;\n    this.column = void 0;\n    this.line = line;\n    this.column = col;\n  }\n\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n\n}\nfunction getLineInfo(input, offset) {\n  let line = 1;\n  let lineStart = 0;\n  let match;\n  lineBreakG.lastIndex = 0;\n\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\n    line++;\n    lineStart = lineBreakG.lastIndex;\n  }\n\n  return new Position(line, offset - lineStart);\n}\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n\n  hasPlugin(name) {\n    return this.plugins.has(name);\n  }\n\n  getPluginOption(plugin, name) {\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\n  }\n\n}\n\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.trailingComments.push(comment);\n    this.state.leadingComments.push(comment);\n  }\n\n  adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {\n    if (this.state.leadingComments.length === 0) {\n      return;\n    }\n\n    let lastElement = null;\n    let i = elements.length;\n\n    while (lastElement === null && i > 0) {\n      lastElement = elements[--i];\n    }\n\n    if (lastElement === null) {\n      return;\n    }\n\n    for (let j = 0; j < this.state.leadingComments.length; j++) {\n      if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n        this.state.leadingComments.splice(j, 1);\n        j--;\n      }\n    }\n\n    const newTrailingComments = [];\n\n    for (let i = 0; i < this.state.leadingComments.length; i++) {\n      const leadingComment = this.state.leadingComments[i];\n\n      if (leadingComment.end < node.end) {\n        newTrailingComments.push(leadingComment);\n\n        if (!takeAllComments) {\n          this.state.leadingComments.splice(i, 1);\n          i--;\n        }\n      } else {\n        if (node.trailingComments === undefined) {\n          node.trailingComments = [];\n        }\n\n        node.trailingComments.push(leadingComment);\n      }\n    }\n\n    if (takeAllComments) this.state.leadingComments = [];\n\n    if (newTrailingComments.length > 0) {\n      lastElement.trailingComments = newTrailingComments;\n    } else if (lastElement.trailingComments !== undefined) {\n      lastElement.trailingComments = [];\n    }\n  }\n\n  processComment(node) {\n    if (node.type === \"Program\" && node.body.length > 0) return;\n    const stack = this.state.commentStack;\n    let firstChild, lastChild, trailingComments, i, j;\n\n    if (this.state.trailingComments.length > 0) {\n      if (this.state.trailingComments[0].start >= node.end) {\n        trailingComments = this.state.trailingComments;\n        this.state.trailingComments = [];\n      } else {\n        this.state.trailingComments.length = 0;\n      }\n    } else if (stack.length > 0) {\n      const lastInStack = last(stack);\n\n      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n        trailingComments = lastInStack.trailingComments;\n        delete lastInStack.trailingComments;\n      }\n    }\n\n    if (stack.length > 0 && last(stack).start >= node.start) {\n      firstChild = stack.pop();\n    }\n\n    while (stack.length > 0 && last(stack).start >= node.start) {\n      lastChild = stack.pop();\n    }\n\n    if (!lastChild && firstChild) lastChild = firstChild;\n\n    if (firstChild) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties);\n          break;\n\n        case \"ObjectPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties, true);\n          break;\n\n        case \"CallExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.arguments);\n          break;\n\n        case \"ArrayExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements);\n          break;\n\n        case \"ArrayPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements, true);\n          break;\n      }\n    } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === \"ImportSpecifier\" && node.type !== \"ImportSpecifier\" || this.state.commentPreviousNode.type === \"ExportSpecifier\" && node.type !== \"ExportSpecifier\")) {\n      this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);\n    }\n\n    if (lastChild) {\n      if (lastChild.leadingComments) {\n        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        } else {\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n            if (lastChild.leadingComments[i].end <= node.start) {\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n              break;\n            }\n          }\n        }\n      }\n    } else if (this.state.leadingComments.length > 0) {\n      if (last(this.state.leadingComments).end <= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n        }\n\n        if (this.state.leadingComments.length > 0) {\n          node.leadingComments = this.state.leadingComments;\n          this.state.leadingComments = [];\n        }\n      } else {\n        for (i = 0; i < this.state.leadingComments.length; i++) {\n          if (this.state.leadingComments[i].end > node.start) {\n            break;\n          }\n        }\n\n        const leadingComments = this.state.leadingComments.slice(0, i);\n\n        if (leadingComments.length) {\n          node.leadingComments = leadingComments;\n        }\n\n        trailingComments = this.state.leadingComments.slice(i);\n\n        if (trailingComments.length === 0) {\n          trailingComments = null;\n        }\n      }\n    }\n\n    this.state.commentPreviousNode = node;\n\n    if (trailingComments) {\n      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n        node.innerComments = trailingComments;\n      } else {\n        const firstTrailingCommentIndex = trailingComments.findIndex(comment => comment.end >= node.end);\n\n        if (firstTrailingCommentIndex > 0) {\n          node.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);\n          node.trailingComments = trailingComments.slice(firstTrailingCommentIndex);\n        } else {\n          node.trailingComments = trailingComments;\n        }\n      }\n    }\n\n    stack.push(node);\n  }\n\n}\n\nconst ErrorMessages = Object.freeze({\n  AccessorIsGenerator: \"A %0ter cannot be a generator\",\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block\",\n  AwaitExpressionFormalParameter: \"await is not allowed in async function parameters\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions\",\n  BadGetterArity: \"getter must not have any formal parameters\",\n  BadSetterArity: \"setter must have exactly one formal parameter\",\n  BadSetterRestParameter: \"setter function argument must not be a rest parameter\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor\",\n  ConstructorIsAsync: \"Constructor can't be an async function\",\n  ConstructorIsGenerator: \"Constructor can't be a generator\",\n  DeclarationMissingInitializer: \"%0 require an initialization value\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block\",\n  DeletePrivateField: \"Deleting a private field is not allowed\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: \"`%0` has already been exported. Exported identifiers must be unique.\",\n  DuplicateProto: \"Redefinition of __proto__ property\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag\",\n  DuplicateStaticBlock: \"Duplicate static block in the same class\",\n  ElementAfterRest: \"Rest element must be last element\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape\",\n  ExportBindingIsString: \"A string literal cannot be used as an exported binding without `from`.\\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?\",\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'\",\n  ForInOfLoopInitializer: \"%0 loop variable declaration may not have an initializer\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block\",\n  IllegalBreakContinue: \"Unsyntactic %0\",\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list\",\n  IllegalReturn: \"'return' outside of function\",\n  ImportBindingIsString: 'A string literal cannot be used as an imported binding.\\n- Did you mean `import { \"%0\" as foo }`?',\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments\",\n  ImportCallArity: \"import() requires exactly %0\",\n  ImportCallNotNewExpression: \"Cannot use new with import(...)\",\n  ImportCallSpreadArgument: \"... is not allowed in import()\",\n  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: \"module\"'`,\n  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral\",\n  InvalidCodePoint: \"Code point out of bounds\",\n  InvalidDecimal: \"Invalid decimal\",\n  InvalidDigit: \"Expected number in radix %0\",\n  InvalidEscapeSequence: \"Bad character escape sequence\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template\",\n  InvalidEscapedReservedWord: \"Escape sequence in keyword %0\",\n  InvalidIdentifier: \"Invalid identifier %0\",\n  InvalidLhs: \"Invalid left-hand side in %0\",\n  InvalidLhsBinding: \"Binding invalid left-hand side in %0\",\n  InvalidNumber: \"Invalid number\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'\",\n  InvalidOrUnexpectedToken: \"Unexpected character '%0'\",\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern\",\n  InvalidPrivateFieldResolution: \"Private name #%0 is not defined\",\n  InvalidPropertyBindingPattern: \"Binding member expression\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument\",\n  LabelRedeclaration: \"Label '%0' is already declared\",\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'\",\n  MalformedRegExpFlags: \"Invalid regular expression flag\",\n  MissingClassName: \"A class name is required\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon\",\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values\",\n  ModuleAttributesWithDuplicateKeys: 'Duplicate key \"%0\" is not allowed in module attributes',\n  ModuleExportNameHasLoneSurrogate: \"An export name cannot include a lone surrogate, found '\\\\u%0'\",\n  ModuleExportUndefined: \"Export '%0' is not defined\",\n  MultipleDefaultsInSwitch: \"Multiple default clauses\",\n  NewlineAfterThrow: \"Illegal newline after throw\",\n  NoCatchOrFinally: \"Missing catch or finally clause\",\n  NumberIdentifier: \"Identifier directly after number\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\",\n  ObsoleteAwaitStar: \"await* has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"constructors in/after an Optional Chain are not allowed\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain\",\n  ParamDupe: \"Argument name clash\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter\",\n  PatternHasMethod: \"Object pattern can't contain methods\",\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding\",\n  PrimaryTopicRequiresSmartPipeline: \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",\n  PrivateInExpectedIn: \"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)\",\n  PrivateNameRedeclaration: \"Duplicate private name #%0\",\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement\",\n  StaticPrototype: \"Classes may not have static property named prototype\",\n  StrictDelete: \"Deleting local variable in strict mode\",\n  StrictEvalArguments: \"Assigning to '%0' in strict mode\",\n  StrictEvalArgumentsBinding: \"Binding '%0' in strict mode\",\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode\",\n  StrictWith: \"'with' in strict mode\",\n  SuperNotAllowed: \"super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super\",\n  TrailingDecorator: \"Decorators must be attached to a class element\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level\",\n  UnexpectedKeyword: \"Unexpected keyword '%0'\",\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context\",\n  UnexpectedNewTarget: \"new.target can only be used in functions\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits\",\n  UnexpectedPrivateField: \"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",\n  UnexpectedReservedWord: \"Unexpected reserved word '%0'\",\n  UnexpectedSuper: \"super is only allowed in object methods and classes\",\n  UnexpectedToken: \"Unexpected token '%0'\",\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"import can only be used in import() or import.meta\",\n  UnsupportedMetaProperty: \"The only valid meta property for %0 is %0.%1\",\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties\",\n  UnsupportedSuper: \"super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])\",\n  UnterminatedComment: \"Unterminated comment\",\n  UnterminatedRegExp: \"Unterminated regular expression\",\n  UnterminatedString: \"Unterminated string constant\",\n  UnterminatedTemplate: \"Unterminated template\",\n  VarRedeclaration: \"Identifier '%0' has already been declared\",\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0\"\n});\n\nclass ParserError extends CommentsParser {\n  getLocationForPosition(pos) {\n    let loc;\n    if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);\n    return loc;\n  }\n\n  raise(pos, errorTemplate, ...params) {\n    return this.raiseWithData(pos, undefined, errorTemplate, ...params);\n  }\n\n  raiseOverwrite(pos, errorTemplate, ...params) {\n    const loc = this.getLocationForPosition(pos);\n    const message = errorTemplate.replace(/%(\\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;\n\n    if (this.options.errorRecovery) {\n      const errors = this.state.errors;\n\n      for (let i = errors.length - 1; i >= 0; i--) {\n        const error = errors[i];\n\n        if (error.pos === pos) {\n          return Object.assign(error, {\n            message\n          });\n        } else if (error.pos < pos) {\n          break;\n        }\n      }\n    }\n\n    return this._raise({\n      loc,\n      pos\n    }, message);\n  }\n\n  raiseWithData(pos, data, errorTemplate, ...params) {\n    const loc = this.getLocationForPosition(pos);\n    const message = errorTemplate.replace(/%(\\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;\n    return this._raise(Object.assign({\n      loc,\n      pos\n    }, data), message);\n  }\n\n  _raise(errorContext, message) {\n    const err = new SyntaxError(message);\n    Object.assign(err, errorContext);\n\n    if (this.options.errorRecovery) {\n      if (!this.isLookahead) this.state.errors.push(err);\n      return err;\n    } else {\n      throw err;\n    }\n  }\n\n}\n\nvar estree = (superClass => class extends superClass {\n  estreeParseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  estreeParseBigIntLiteral(value) {\n    let bigInt;\n\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  estreeParseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  directiveToStmt(directive) {\n    const directiveLiteral = directive.value;\n    const stmt = this.startNodeAt(directive.start, directive.loc.start);\n    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n    expression.value = directiveLiteral.extra.expressionValue;\n    expression.raw = directiveLiteral.extra.raw;\n    stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n    return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) == null ? void 0 : _stmt$expression$extr.parenthesized);\n  }\n\n  stmtToDirective(stmt) {\n    const directive = super.stmtToDirective(stmt);\n    const value = stmt.expression.value;\n    this.addExtra(directive.value, \"expressionValue\", value);\n    return directive;\n  }\n\n  parseBlockBody(node, ...args) {\n    super.parseBlockBody(node, ...args);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n\n    classBody.body.push(method);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    switch (this.state.type) {\n      case types.num:\n      case types.string:\n        return this.estreeParseLiteral(this.state.value);\n\n      case types.regexp:\n        return this.estreeParseRegExpLiteral(this.state.value);\n\n      case types.bigint:\n        return this.estreeParseBigIntLiteral(this.state.value);\n\n      case types.decimal:\n        return this.estreeParseDecimalLiteral(this.state.value);\n\n      case types._null:\n        return this.estreeParseLiteral(null);\n\n      case types._true:\n        return this.estreeParseLiteral(true);\n\n      case types._false:\n        return this.estreeParseLiteral(false);\n\n      default:\n        return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    const node = super.parseLiteral(value, type, startPos, startLoc);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    type = type === \"ClassMethod\" ? \"MethodDefinition\" : type;\n    return this.finishNode(node, type);\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") node.kind = \"init\";\n      node.shorthand = false;\n    }\n\n    return node;\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n\n    return node;\n  }\n\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.toAssignable(node.value, isLHS);\n      return node;\n    }\n\n    return super.toAssignable(node, isLHS);\n  }\n\n  toAssignableObjectExpressionProp(prop, ...args) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);\n    } else if (prop.method) {\n      this.raise(prop.key.start, ErrorMessages.PatternHasMethod);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, ...args);\n    }\n  }\n\n  finishCallExpression(node, optional) {\n    super.finishCallExpression(node, optional);\n\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      delete node.arguments;\n      delete node.callee;\n    }\n\n    return node;\n  }\n\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n\n    super.toReferencedArguments(node);\n  }\n\n  parseExport(node) {\n    super.parseExport(node);\n\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n\n        break;\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);\n\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n\n    return node;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n\n    return super.hasPropertyAsPrivateName(node);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"ChainExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n\n});\n\nclass TokContext {\n  constructor(token, isExpr, preserveSpace, override) {\n    this.token = void 0;\n    this.isExpr = void 0;\n    this.preserveSpace = void 0;\n    this.override = void 0;\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n  }\n\n}\nconst types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  recordExpression: new TokContext(\"#{\", true),\n  templateQuasi: new TokContext(\"${\", false),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, p => p.readTmplToken()),\n  functionExpression: new TokContext(\"function\", true),\n  functionStatement: new TokContext(\"function\", false)\n};\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  let out = this.state.context.pop();\n\n  if (out === types$1.braceStatement && this.curContext().token === \"function\") {\n    out = this.state.context.pop();\n  }\n\n  this.state.exprAllowed = !out.isExpr;\n};\n\ntypes.name.updateContext = function (prevType) {\n  let allowed = false;\n\n  if (prevType !== types.dot) {\n    if (this.state.value === \"of\" && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class) {\n      allowed = true;\n    }\n  }\n\n  this.state.exprAllowed = allowed;\n\n  if (this.state.isIterator) {\n    this.state.isIterator = false;\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {};\n\ntypes._function.updateContext = types._class.updateContext = function (prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && this.hasPrecedingLineBreak()) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n    this.state.context.push(types$1.functionExpression);\n  } else {\n    this.state.context.push(types$1.functionStatement);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.braceHashL.updateContext = function () {\n  this.state.context.push(types$1.recordExpression);\n  this.state.exprAllowed = true;\n};\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords$1 = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords$1.has(word);\n}\n\nconst keywordRelationalOperator = /^in(stanceof)?$/;\nfunction isIteratorStart(current, next) {\n  return current === 64 && next === 64;\n}\n\nconst SCOPE_OTHER = 0b000000000,\n      SCOPE_PROGRAM = 0b000000001,\n      SCOPE_FUNCTION = 0b000000010,\n      SCOPE_ARROW = 0b000000100,\n      SCOPE_SIMPLE_CATCH = 0b000001000,\n      SCOPE_SUPER = 0b000010000,\n      SCOPE_DIRECT_SUPER = 0b000100000,\n      SCOPE_CLASS = 0b001000000,\n      SCOPE_STATIC_BLOCK = 0b010000000,\n      SCOPE_TS_MODULE = 0b100000000,\n      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b000000000001,\n      BIND_KIND_TYPE = 0b000000000010,\n      BIND_SCOPE_VAR = 0b000000000100,\n      BIND_SCOPE_LEXICAL = 0b000000001000,\n      BIND_SCOPE_FUNCTION = 0b000000010000,\n      BIND_FLAGS_NONE = 0b000001000000,\n      BIND_FLAGS_CLASS = 0b000010000000,\n      BIND_FLAGS_TS_ENUM = 0b000100000000,\n      BIND_FLAGS_TS_CONST_ENUM = 0b001000000000,\n      BIND_FLAGS_TS_EXPORT_ONLY = 0b010000000000,\n      BIND_FLAGS_FLOW_DECLARE_FN = 0b100000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n      CLASS_ELEMENT_KIND_GETTER = 0b010,\n      CLASS_ELEMENT_KIND_SETTER = 0b001,\n      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n      CLASS_ELEMENT_OTHER = 0;\n\nclass Scope {\n  constructor(flags) {\n    this.flags = void 0;\n    this.var = [];\n    this.lexical = [];\n    this.functions = [];\n    this.flags = flags;\n  }\n\n}\nclass ScopeHandler {\n  constructor(raise, inModule) {\n    this.scopeStack = [];\n    this.undefinedExports = new Map();\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get allowSuper() {\n    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;\n  }\n\n  get allowDirectSuper() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n  }\n\n  get inClass() {\n    return (this.currentThisScope().flags & SCOPE_CLASS) > 0;\n  }\n\n  get inStaticBlock() {\n    return (this.currentThisScope().flags & SCOPE_STATIC_BLOCK) > 0;\n  }\n\n  get inNonArrowFunction() {\n    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags) {\n    return new Scope(flags);\n  }\n\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n\n  declareName(name, bindingType, pos) {\n    let scope = this.currentScope();\n\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.push(name);\n      } else {\n        scope.lexical.push(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        scope.var.push(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope, name) {\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(scope, name, bindingType, pos) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.raise(pos, ErrorMessages.VarRedeclaration, name);\n    }\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;\n    }\n\n    return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {\n      this.undefinedExports.set(id.name, id.start);\n    }\n  }\n\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if (scope.flags & SCOPE_VAR) {\n        return scope;\n      }\n    }\n  }\n\n  currentThisScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {\n        return scope;\n      }\n    }\n  }\n\n}\n\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = [];\n  }\n\n}\n\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(...arguments)) return true;\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      return !scope.declareFunctions.includes(name) && (scope.lexical.includes(name) || scope.functions.includes(name));\n    }\n\n    return false;\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].declareFunctions.indexOf(id.name) === -1) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = Object.freeze({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\",\n  AssignReservedType: \"Cannot overwrite reserved type %0\",\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement\",\n  EnumBooleanMemberNotInitialized: \"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",\n  EnumDuplicateMemberName: \"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",\n  EnumInconsistentMemberValues: \"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",\n  EnumInvalidExplicitType: \"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidExplicitTypeUnknownSupplied: \"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidMemberInitializerPrimaryType: \"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",\n  EnumInvalidMemberInitializerSymbolType: \"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",\n  EnumInvalidMemberInitializerUnknownType: \"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",\n  EnumInvalidMemberName: \"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",\n  EnumNumberMemberNotInitialized: \"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",\n  EnumStringMemberInconsistentlyInitailized: \"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment\",\n  OptionalBindingPattern: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  SpreadVariance: \"Spread properties cannot have variance\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object\",\n  UnexpectedReservedType: \"Unexpected reserved type %0\",\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\"',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",\n  UnsupportedDeclareExportKind: \"`declare export %0` is not supported. Use `%1` instead\",\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module\",\n  UnterminatedFlowComment: \"Unterminated flow-comment\"\n});\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(state) {\n  return (state.type === types.name || !!state.type.keyword) && state.value !== \"from\";\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass => {\n  var _temp;\n\n  return _temp = class extends superClass {\n    constructor(...args) {\n      super(...args);\n      this.flowPragma = undefined;\n    }\n\n    getScopeHandler() {\n      return FlowScopeHandler;\n    }\n\n    shouldParseTypes() {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    shouldParseEnums() {\n      return !!this.getPluginOption(\"flow\", \"enums\");\n    }\n\n    finishToken(type, val) {\n      if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n\n      return super.finishToken(type, val);\n    }\n\n    addComment(comment) {\n      if (this.flowPragma === undefined) {\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n\n        if (!matches) ; else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n\n      return super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok) {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || types.colon);\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate() {\n      const node = this.startNode();\n      const moduloLoc = this.state.startLoc;\n      const moduloPos = this.state.start;\n      this.expect(types.modulo);\n      const checksLoc = this.state.startLoc;\n      this.expectContextual(\"checks\");\n\n      if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n        this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);\n      }\n\n      if (this.eat(types.parenL)) {\n        node.value = this.parseExpression();\n        this.expect(types.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser() {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(types.colon);\n      let type = null;\n      let predicate = null;\n\n      if (this.match(types.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n\n        if (this.match(types.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(node) {\n      this.next();\n      this.flowParseInterfaceish(node, true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(node) {\n      this.next();\n      const id = node.id = this.parseIdentifier();\n      const typeNode = this.startNode();\n      const typeContainer = this.startNode();\n\n      if (this.isRelational(\"<\")) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(types.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      this.expect(types.parenR);\n      [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n      this.resetEndLocation(id);\n      this.semicolon();\n      this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(node, insideModule) {\n      if (this.match(types._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(types._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(types._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(\"module\")) {\n        if (this.match(types.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);\n          }\n\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(\"type\")) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(\"opaque\")) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(\"interface\")) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(types._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        throw this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(node) {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(true);\n      this.scope.declareName(node.id.name, BIND_VAR, node.id.start);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(node) {\n      this.scope.enter(SCOPE_OTHER);\n\n      if (this.match(types.string)) {\n        node.id = this.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = node.body = this.startNode();\n      const body = bodyNode.body = [];\n      this.expect(types.braceL);\n\n      while (!this.match(types.braceR)) {\n        let bodyNode = this.startNode();\n\n        if (this.match(types._import)) {\n          this.next();\n\n          if (!this.isContextual(\"type\") && !this.match(types._typeof)) {\n            this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);\n          }\n\n          this.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\"declare\", FlowErrors.UnsupportedStatementInDeclareModule);\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n      this.expect(types.braceR);\n      this.finishNode(bodyNode, \"BlockStatement\");\n      let kind = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n          }\n\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);\n          }\n\n          if (kind === \"ES\") {\n            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n          }\n\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(node, insideModule) {\n      this.expect(types._export);\n\n      if (this.eat(types._default)) {\n        if (this.match(types._function) || this.match(types._class)) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n\n        node.default = true;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (this.match(types._const) || this.isLet() || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !insideModule) {\n          const label = this.state.value;\n          const suggestion = exportSuggestions[label];\n          throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);\n        }\n\n        if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual(\"opaque\")) {\n            node.declaration = this.flowParseDeclare(this.startNode());\n            node.default = false;\n            return this.finishNode(node, \"DeclareExportDeclaration\");\n          } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual(\"interface\") || this.isContextual(\"type\") || this.isContextual(\"opaque\")) {\n            node = this.parseExport(node);\n\n            if (node.type === \"ExportNamedDeclaration\") {\n              node.type = \"ExportDeclaration\";\n              node.default = false;\n              delete node.exportKind;\n            }\n\n            node.type = \"Declare\" + node.type;\n            return node;\n          }\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(node) {\n      this.next();\n      this.expectContextual(\"exports\");\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(node) {\n      this.next();\n      this.flowParseTypeAlias(node);\n      node.type = \"DeclareTypeAlias\";\n      return node;\n    }\n\n    flowParseDeclareOpaqueType(node) {\n      this.next();\n      this.flowParseOpaqueType(node, true);\n      node.type = \"DeclareOpaqueType\";\n      return node;\n    }\n\n    flowParseDeclareInterface(node) {\n      this.next();\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    flowParseInterfaceish(node, isClass = false) {\n      node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n      this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n      node.implements = [];\n      node.mixins = [];\n\n      if (this.eat(types._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(types.comma));\n      }\n\n      if (this.isContextual(\"mixins\")) {\n        this.next();\n\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      if (this.isContextual(\"implements\")) {\n        this.next();\n\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false\n      });\n    }\n\n    flowParseInterfaceExtends() {\n      const node = this.startNode();\n      node.id = this.flowParseQualifiedTypeIdentifier();\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node) {\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word) {\n      if (word === \"_\") {\n        this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);\n      }\n    }\n\n    checkReservedType(word, startLoc, declaration) {\n      if (!reservedTypes.has(word)) return;\n      this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);\n    }\n\n    flowParseRestrictedIdentifier(liberal, declaration) {\n      this.checkReservedType(this.state.value, this.state.start, declaration);\n      return this.parseIdentifier(liberal);\n    }\n\n    flowParseTypeAlias(node) {\n      node.id = this.flowParseRestrictedIdentifier(false, true);\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(types.eq);\n      this.semicolon();\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(node, declare) {\n      this.expectContextual(\"type\");\n      node.id = this.flowParseRestrictedIdentifier(true, true);\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.supertype = null;\n\n      if (this.match(types.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(types.colon);\n      }\n\n      node.impltype = null;\n\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(types.eq);\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    flowParseTypeParameter(requireDefault = false) {\n      const nodeStart = this.state.start;\n      const node = this.startNode();\n      const variance = this.flowParseVariance();\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      node.variance = variance;\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(types.eq)) {\n        this.eat(types.eq);\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration() {\n      const oldInType = this.state.inType;\n      const node = this.startNode();\n      node.params = [];\n      this.state.inType = true;\n\n      if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      } while (!this.isRelational(\">\"));\n\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    flowParseTypeParameterInstantiation() {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n      this.state.inType = true;\n      this.expectRelational(\"<\");\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n\n      while (!this.isRelational(\">\")) {\n        node.params.push(this.flowParseType());\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      }\n\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew() {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n      this.state.inType = true;\n      this.expectRelational(\"<\");\n\n      while (!this.isRelational(\">\")) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      }\n\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType() {\n      const node = this.startNode();\n      this.expectContextual(\"interface\");\n      node.extends = [];\n\n      if (this.eat(types._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false\n      });\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey() {\n      return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(node, isStatic, variance) {\n      node.static = isStatic;\n\n      if (this.lookahead().type === types.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n\n      this.expect(types.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(node, isStatic) {\n      node.static = isStatic;\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(types.bracketR);\n      this.expect(types.bracketR);\n\n      if (this.isRelational(\"<\") || this.match(types.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n      } else {\n        node.method = false;\n\n        if (this.eat(types.question)) {\n          node.optional = true;\n        }\n\n        node.value = this.flowParseTypeInitialiser();\n      }\n\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(node) {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(types.parenL);\n\n      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam());\n\n        if (!this.match(types.parenR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      if (this.eat(types.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam();\n      }\n\n      this.expect(types.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(node, isStatic) {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact\n    }) {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const nodeStart = this.startNode();\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n      let endDelim;\n      let exact;\n      let inexact = false;\n\n      if (allowExact && this.match(types.braceBarL)) {\n        this.expect(types.braceBarL);\n        endDelim = types.braceBarR;\n        exact = true;\n      } else {\n        this.expect(types.braceL);\n        endDelim = types.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStart = null;\n        let inexactStart = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(\"proto\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n            this.next();\n            protoStart = this.state.start;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(\"static\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(types.bracketL)) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n\n          if (this.eat(types.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.start);\n            }\n\n            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n          } else {\n            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n          }\n        } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n            const lookahead = this.lookahead();\n\n            if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStart = this.state.lastTokStart;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n          this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);\n        }\n      }\n\n      this.expect(endDelim);\n\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n      this.state.inType = oldInType;\n      return out;\n    }\n\n    flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {\n      if (this.eat(types.ellipsis)) {\n        const isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);\n          } else if (!allowInexact) {\n            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);\n          }\n\n          if (variance) {\n            this.raise(variance.start, FlowErrors.InexactVariance);\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);\n        }\n\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.raise(variance.start, FlowErrors.SpreadVariance);\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStart != null;\n        node.kind = kind;\n        let optional = false;\n\n        if (this.isRelational(\"<\") || this.match(types.parenL)) {\n          node.method = true;\n\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n          node.method = false;\n\n          if (this.eat(types.question)) {\n            optional = true;\n          }\n\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    flowCheckGetterSetterParams(property) {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const start = property.start;\n      const length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (length !== paramCount) {\n        if (property.kind === \"get\") {\n          this.raise(start, ErrorMessages.BadGetterArity);\n        } else {\n          this.raise(start, ErrorMessages.BadSetterArity);\n        }\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(start, ErrorMessages.BadSetterRestParameter);\n      }\n    }\n\n    flowObjectTypeSemicolon() {\n      if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n      startPos = startPos || this.state.start;\n      startLoc = startLoc || this.state.startLoc;\n      let node = id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(types.dot)) {\n        const node2 = this.startNodeAt(startPos, startLoc);\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(startPos, startLoc, id) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType() {\n      const node = this.startNode();\n      this.expect(types._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType() {\n      const node = this.startNode();\n      node.types = [];\n      this.expect(types.bracketL);\n\n      while (this.state.pos < this.length && !this.match(types.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(types.bracketR)) break;\n        this.expect(types.comma);\n      }\n\n      this.expect(types.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam() {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode();\n      const lh = this.lookahead();\n\n      if (lh.type === types.colon || lh.type === types.question) {\n        name = this.parseIdentifier();\n\n        if (this.eat(types.question)) {\n          optional = true;\n        }\n\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(type) {\n      const node = this.startNodeAt(type.start, type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(params = []) {\n      let rest = null;\n\n      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam());\n\n        if (!this.match(types.parenR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      if (this.eat(types.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam();\n      }\n\n      return {\n        params,\n        rest\n      };\n    }\n\n    flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startPos, startLoc, id);\n      }\n    }\n\n    flowParsePrimaryType() {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.startNode();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case types.name:\n          if (this.isContextual(\"interface\")) {\n            return this.flowParseInterfaceType();\n          }\n\n          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n        case types.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true\n          });\n\n        case types.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false\n          });\n\n        case types.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case types.relational:\n          if (this.state.value === \"<\") {\n            node.typeParameters = this.flowParseTypeParameterDeclaration();\n            this.expect(types.parenL);\n            tmp = this.flowParseFunctionTypeParams();\n            node.params = tmp.params;\n            node.rest = tmp.rest;\n            this.expect(types.parenR);\n            this.expect(types.arrow);\n            node.returnType = this.flowParseType();\n            return this.finishNode(node, \"FunctionTypeAnnotation\");\n          }\n\n          break;\n\n        case types.parenL:\n          this.next();\n\n          if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n            if (this.match(types.name)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== types.question && token !== types.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n              this.expect(types.parenR);\n              return type;\n            } else {\n              this.eat(types.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          this.expect(types.parenR);\n          this.expect(types.arrow);\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case types.string:\n          return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n        case types._true:\n        case types._false:\n          node.value = this.match(types._true);\n          this.next();\n          return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n        case types.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n\n            if (this.match(types.num)) {\n              return this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", node.start, node.loc.start);\n            }\n\n            if (this.match(types.bigint)) {\n              return this.parseLiteral(-this.state.value, \"BigIntLiteralTypeAnnotation\", node.start, node.loc.start);\n            }\n\n            throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);\n          }\n\n          throw this.unexpected();\n\n        case types.num:\n          return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n        case types.bigint:\n          return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n        case types._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case types._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case types._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case types.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        default:\n          if (this.state.type.keyword === \"typeof\") {\n            return this.flowParseTypeofType();\n          } else if (this.state.type.keyword) {\n            const label = this.state.type.label;\n            this.next();\n            return super.createIdentifier(node, label);\n          }\n\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParsePostfixType() {\n      const startPos = this.state.start,\n            startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n\n      while (this.match(types.bracketL) && !this.canInsertSemicolon()) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.elementType = type;\n        this.expect(types.bracketL);\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      }\n\n      return type;\n    }\n\n    flowParsePrefixType() {\n      const node = this.startNode();\n\n      if (this.eat(types.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens() {\n      const param = this.flowParsePrefixType();\n\n      if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n        const node = this.startNodeAt(param.start, param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n\n      return param;\n    }\n\n    flowParseIntersectionType() {\n      const node = this.startNode();\n      this.eat(types.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n\n      while (this.eat(types.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n\n      return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType() {\n      const node = this.startNode();\n      this.eat(types.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n\n      while (this.eat(types.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n\n      return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType() {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation() {\n      if (this.state.type === types.name && this.state.value === \"_\") {\n        const startPos = this.state.start;\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startPos, startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation() {\n      const node = this.startNode();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n      if (this.match(types.colon)) {\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n\n      return ident;\n    }\n\n    typeCastToParameter(node) {\n      node.expression.typeAnnotation = node.typeAnnotation;\n      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n      return node.expression;\n    }\n\n    flowParseVariance() {\n      let variance = null;\n\n      if (this.match(types.plusMin)) {\n        variance = this.startNode();\n\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n\n        this.next();\n        this.finishNode(variance, \"Variance\");\n      }\n\n      return variance;\n    }\n\n    parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n      if (allowExpressionBody) {\n        return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      }\n\n      return super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish(node, type, isMethod = false) {\n      if (this.match(types.colon)) {\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n      }\n\n      super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    parseStatement(context, topLevel) {\n      if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type === types.name || isKeyword(lookahead.value)) {\n          const node = this.startNode();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n\n      const stmt = super.parseStatement(context, topLevel);\n\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n\n      return stmt;\n    }\n\n    parseExpressionStatement(node, expr) {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n            return this.flowParseDeclare(node);\n          }\n        } else if (this.match(types.name)) {\n          if (expr.name === \"interface\") {\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr);\n    }\n\n    shouldParseExportDeclaration() {\n      return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || this.shouldParseEnums() && this.isContextual(\"enum\") || super.shouldParseExportDeclaration();\n    }\n\n    isExportDefaultSpecifier() {\n      if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value === \"opaque\" || this.shouldParseEnums() && this.state.value === \"enum\")) {\n        return false;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression() {\n      if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {\n      if (!this.match(types.question)) return expr;\n\n      if (refNeedsArrowPos) {\n        const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));\n\n        if (!result.node) {\n          refNeedsArrowPos.start = result.error.pos || this.state.start;\n          return expr;\n        }\n\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n\n      this.expect(types.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt(startPos, startLoc);\n      let {\n        consequent,\n        failed\n      } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({\n            consequent,\n            failed\n          } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt.concat(valid[0].start);\n          ({\n            consequent,\n            failed\n          } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(types.colon);\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined, undefined));\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent() {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(types.colon);\n      this.state.noArrowParamsConversionAt.pop();\n      return {\n        consequent,\n        failed\n      };\n    }\n\n    getArrowLikeExpressions(node, disallowInvalid) {\n      const stack = [node];\n      const arrows = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n\n        if (node.type === \"ArrowFunctionExpression\") {\n          if (node.typeParameters || !node.returnType) {\n            this.finishArrowValidation(node);\n          } else {\n            arrows.push(node);\n          }\n\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n    }\n\n    finishArrowValidation(node) {\n      var _node$extra;\n\n      this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);\n      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt(node, parse) {\n      let result;\n\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem(node, startPos, startLoc) {\n      node = super.parseParenItem(node, startPos, startLoc);\n\n      if (this.eat(types.question)) {\n        node.optional = true;\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(types.colon)) {\n        const typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    assertModuleNodeAllowed(node) {\n      if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExport(node) {\n      const decl = super.parseExport(node);\n\n      if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n        decl.exportKind = decl.exportKind || \"value\";\n      }\n\n      return decl;\n    }\n\n    parseExportDeclaration(node) {\n      if (this.isContextual(\"type\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(types.braceL)) {\n          node.specifiers = this.parseExportSpecifiers();\n          this.parseExportFrom(node);\n          return null;\n        } else {\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(\"opaque\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(\"interface\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseInterface(declarationNode);\n      } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(node) {\n      if (super.eatExportStar(...arguments)) return true;\n\n      if (this.isContextual(\"type\") && this.lookahead().type === types.star) {\n        node.exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(node) {\n      const pos = this.state.start;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(pos);\n      }\n\n      return hasNamespace;\n    }\n\n    parseClassId(node, isStatement, optionalId) {\n      super.parseClassId(node, isStatement, optionalId);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(classBody, member, state) {\n      const pos = this.state.start;\n\n      if (this.isContextual(\"declare\")) {\n        if (this.parseClassMemberFromModifier(classBody, member)) {\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\") {\n          this.raise(pos, FlowErrors.DeclareClassElement);\n        } else if (member.value) {\n          this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);\n        }\n      }\n    }\n\n    getTokenFromCode(code) {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 123 && next === 124) {\n        return this.finishOp(types.braceBarL, 2);\n      } else if (this.state.inType && (code === 62 || code === 60)) {\n        return this.finishOp(types.relational, 1);\n      } else if (this.state.inType && code === 63) {\n        return this.finishOp(types.question, 1);\n      } else if (isIteratorStart(code, next)) {\n        this.state.isIterator = true;\n        return super.readWord();\n      } else {\n        return super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node, isBinding) {\n      switch (node.type) {\n        case \"Identifier\":\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"AssignmentPattern\":\n          return true;\n\n        case \"ObjectExpression\":\n          {\n            const last = node.properties.length - 1;\n            return node.properties.every((prop, i) => {\n              return prop.type !== \"ObjectMethod\" && (i === last || prop.type === \"SpreadElement\") && this.isAssignable(prop);\n            });\n          }\n\n        case \"ObjectProperty\":\n          return this.isAssignable(node.value);\n\n        case \"SpreadElement\":\n          return this.isAssignable(node.argument);\n\n        case \"ArrayExpression\":\n          return node.elements.every(element => this.isAssignable(element));\n\n        case \"AssignmentExpression\":\n          return node.operator === \"=\";\n\n        case \"ParenthesizedExpression\":\n        case \"TypeCastExpression\":\n          return this.isAssignable(node.expression);\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return !isBinding;\n\n        default:\n          return false;\n      }\n    }\n\n    toAssignable(node, isLHS = false) {\n      if (node.type === \"TypeCastExpression\") {\n        return super.toAssignable(this.typeCastToParameter(node), isLHS);\n      } else {\n        return super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableList(exprList, trailingCommaPos, isLHS) {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n\n        if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n\n      return super.toAssignableList(exprList, trailingCommaPos, isLHS);\n    }\n\n    toReferencedList(exprList, isParenthesizedExpr) {\n      for (let i = 0; i < exprList.length; i++) {\n        var _expr$extra;\n\n        const expr = exprList[i];\n\n        if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) == null ? void 0 : _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n          this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n      const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    checkLVal(expr, ...args) {\n      if (expr.type !== \"TypeCastExpression\") {\n        return super.checkLVal(expr, ...args);\n      }\n    }\n\n    parseClassProperty(node) {\n      if (this.match(types.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(node) {\n      if (this.match(types.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      return super.parseClassPrivateProperty(node);\n    }\n\n    isClassMethod() {\n      return this.isRelational(\"<\") || super.isClassMethod();\n    }\n\n    isClassProperty() {\n      return this.match(types.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method) {\n      return !this.match(types.colon) && super.isNonstaticConstructor(method);\n    }\n\n    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n      if (method.variance) {\n        this.unexpected(method.variance.start);\n      }\n\n      delete method.variance;\n\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    }\n\n    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n      if (method.variance) {\n        this.unexpected(method.variance.start);\n      }\n\n      delete method.variance;\n\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    parseClassSuper(node) {\n      super.parseClassSuper(node);\n\n      if (node.superClass && this.isRelational(\"<\")) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      if (this.isContextual(\"implements\")) {\n        this.next();\n        const implemented = node.implements = [];\n\n        do {\n          const node = this.startNode();\n          node.id = this.flowParseRestrictedIdentifier(true);\n\n          if (this.isRelational(\"<\")) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(types.comma));\n      }\n    }\n\n    parsePropertyName(node, isPrivateNameAllowed) {\n      const variance = this.flowParseVariance();\n      const key = super.parsePropertyName(node, isPrivateNameAllowed);\n      node.variance = variance;\n      return key;\n    }\n\n    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n      if (prop.variance) {\n        this.unexpected(prop.variance.start);\n      }\n\n      delete prop.variance;\n      let typeParameters;\n\n      if (this.isRelational(\"<\") && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(types.parenL)) this.unexpected();\n      }\n\n      super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n\n      if (typeParameters) {\n        (prop.value || prop).typeParameters = typeParameters;\n      }\n    }\n\n    parseAssignableListItemTypes(param) {\n      if (this.eat(types.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(param.start, FlowErrors.OptionalBindingPattern);\n        }\n\n        param.optional = true;\n      }\n\n      if (this.match(types.colon)) {\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(startPos, startLoc, left) {\n      const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n      if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n        this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);\n      }\n\n      return node;\n    }\n\n    shouldParseDefaultImport(node) {\n      if (!hasTypeImportKind(node)) {\n        return super.shouldParseDefaultImport(node);\n      }\n\n      return isMaybeDefaultImport(this.state);\n    }\n\n    parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n      node.specifiers.push(this.finishNode(specifier, type));\n    }\n\n    maybeParseDefaultImportSpecifier(node) {\n      node.importKind = \"value\";\n      let kind = null;\n\n      if (this.match(types._typeof)) {\n        kind = \"typeof\";\n      } else if (this.isContextual(\"type\")) {\n        kind = \"type\";\n      }\n\n      if (kind) {\n        const lh = this.lookahead();\n\n        if (kind === \"type\" && lh.type === types.star) {\n          this.unexpected(lh.start);\n        }\n\n        if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      return super.maybeParseDefaultImportSpecifier(node);\n    }\n\n    parseImportSpecifier(node) {\n      const specifier = this.startNode();\n      const firstIdentLoc = this.state.start;\n      const firstIdent = this.parseModuleExportName();\n      let specifierTypeKind = null;\n\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n\n      if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n\n        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = as_ident.__clone();\n        } else {\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n\n        if (this.eatContextual(\"as\")) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = specifier.imported.__clone();\n        }\n      } else {\n        if (firstIdent.type === \"StringLiteral\") {\n          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);\n        }\n\n        isBinding = true;\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = specifier.imported.__clone();\n      }\n\n      const nodeIsTypeImport = hasTypeImportKind(node);\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (nodeIsTypeImport && specifierIsTypeImport) {\n        this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);\n      }\n\n      if (nodeIsTypeImport || specifierIsTypeImport) {\n        this.checkReservedType(specifier.local.name, specifier.local.start, true);\n      }\n\n      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n        this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n      }\n\n      this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n      node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n    }\n\n    parseFunctionParams(node, allowModifiers) {\n      const kind = node.kind;\n\n      if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.parseFunctionParams(node, allowModifiers);\n    }\n\n    parseVarId(decl, kind) {\n      super.parseVarId(decl, kind);\n\n      if (this.match(types.colon)) {\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id);\n      }\n    }\n\n    parseAsyncArrowFromCallExpression(node, call) {\n      if (this.match(types.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    shouldParseAsyncArrow() {\n      return this.match(types.colon) || super.shouldParseAsyncArrow();\n    }\n\n    parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n      var _jsx;\n\n      let state = null;\n      let jsx;\n\n      if (this.hasPlugin(\"jsx\") && (this.match(types.jsxTagStart) || this.isRelational(\"<\"))) {\n        state = this.state.clone();\n        jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos), state);\n        if (!jsx.error) return jsx.node;\n        const {\n          context\n        } = this.state;\n\n        if (context[context.length - 1] === types$1.j_oTag) {\n          context.length -= 2;\n        } else if (context[context.length - 1] === types$1.j_expr) {\n          context.length -= 1;\n        }\n      }\n\n      if (((_jsx = jsx) == null ? void 0 : _jsx.error) || this.isRelational(\"<\")) {\n        var _jsx2, _jsx3;\n\n        state = state || this.state.clone();\n        let typeParameters;\n        const arrow = this.tryParse(abort => {\n          var _arrowExpression$extr;\n\n          typeParameters = this.flowParseTypeParameterDeclaration();\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);\n            this.resetStartLocationFromNode(result, typeParameters);\n            return result;\n          });\n\n          if (arrowExpression.type !== \"ArrowFunctionExpression\" && ((_arrowExpression$extr = arrowExpression.extra) == null ? void 0 : _arrowExpression$extr.parenthesized)) {\n            abort();\n          }\n\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n          return arrowExpression;\n        }, state);\n        let arrowExpression = null;\n\n        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n          if (!arrow.error && !arrow.aborted) {\n            if (arrow.node.async) {\n              this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);\n            }\n\n            return arrow.node;\n          }\n\n          arrowExpression = arrow.node;\n        }\n\n        if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n        throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);\n      }\n\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);\n    }\n\n    parseArrow(node) {\n      if (this.match(types.colon)) {\n        const result = this.tryParse(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n          const typeNode = this.startNode();\n          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(types.arrow)) this.unexpected();\n          return typeNode;\n        });\n        if (result.thrown) return null;\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow() {\n      return this.match(types.colon) || super.shouldParseArrow();\n    }\n\n    setArrowFunctionParameters(node, params) {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(node, allowDuplicates, isArrowFunction) {\n      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        return;\n      }\n\n      return super.checkParams(...arguments);\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow) {\n      return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n    }\n\n    parseSubscripts(base, startPos, startLoc, noCalls) {\n      if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n        this.next();\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (base.type === \"Identifier\" && base.name === \"async\" && this.isRelational(\"<\")) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n        const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startPos, startLoc, noCalls);\n    }\n\n    parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {\n      if (this.match(types.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n\n        this.next();\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\n        this.expect(types.parenL);\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, true);\n      } else if (!noCalls && this.shouldParseTypes() && this.isRelational(\"<\")) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const result = this.tryParse(() => {\n          node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(types.parenL);\n          node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n          if (subscriptState.optionalChainMember) node.optional = false;\n          return this.finishCallExpression(node, subscriptState.optionalChainMember);\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);\n    }\n\n    parseNewArguments(node) {\n      let targs = null;\n\n      if (this.shouldParseTypes() && this.isRelational(\"<\")) {\n        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n      }\n\n      node.typeArguments = targs;\n      super.parseNewArguments(node);\n    }\n\n    parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n      const node = this.startNodeAt(startPos, startLoc);\n      this.parseFunctionParams(node);\n      if (!this.parseArrow(node)) return;\n      return this.parseArrowExpression(node, undefined, true);\n    }\n\n    readToken_mult_modulo(code) {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 42 && next === 47 && this.state.hasFlowComment) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code) {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 124 && next === 125) {\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file, program) {\n      const fileNode = super.parseTopLevel(file, program);\n\n      if (this.state.hasFlowComment) {\n        this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);\n      }\n\n      return fileNode;\n    }\n\n    skipBlockComment() {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          this.unexpected(null, FlowErrors.NestedFlowComment);\n        }\n\n        this.hasFlowCommentCompletion();\n        this.state.pos += this.skipFlowComment();\n        this.state.hasFlowComment = true;\n        return;\n      }\n\n      if (this.state.hasFlowComment) {\n        const end = this.input.indexOf(\"*-/\", this.state.pos += 2);\n\n        if (end === -1) {\n          throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);\n        }\n\n        this.state.pos = end + 3;\n        return;\n      }\n\n      super.skipBlockComment();\n    }\n\n    skipFlowComment() {\n      const {\n        pos\n      } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n\n      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === 58 && ch3 === 58) {\n        return shiftToFirstNonWhiteSpace + 2;\n      }\n\n      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n        return shiftToFirstNonWhiteSpace + 12;\n      }\n\n      if (ch2 === 58 && ch3 !== 58) {\n        return shiftToFirstNonWhiteSpace;\n      }\n\n      return false;\n    }\n\n    hasFlowCommentCompletion() {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n\n      if (end === -1) {\n        throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);\n      }\n    }\n\n    flowEnumErrorBooleanMemberNotInitialized(pos, {\n      enumName,\n      memberName\n    }) {\n      this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);\n    }\n\n    flowEnumErrorInvalidMemberName(pos, {\n      enumName,\n      memberName\n    }) {\n      const suggestion = memberName[0].toUpperCase() + memberName.slice(1);\n      this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);\n    }\n\n    flowEnumErrorDuplicateMemberName(pos, {\n      enumName,\n      memberName\n    }) {\n      this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);\n    }\n\n    flowEnumErrorInconsistentMemberValues(pos, {\n      enumName\n    }) {\n      this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);\n    }\n\n    flowEnumErrorInvalidExplicitType(pos, {\n      enumName,\n      suppliedType\n    }) {\n      return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);\n    }\n\n    flowEnumErrorInvalidMemberInitializer(pos, {\n      enumName,\n      explicitType,\n      memberName\n    }) {\n      let message = null;\n\n      switch (explicitType) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;\n          break;\n\n        case \"symbol\":\n          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;\n          break;\n\n        default:\n          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;\n      }\n\n      return this.raise(pos, message, enumName, memberName, explicitType);\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(pos, {\n      enumName,\n      memberName\n    }) {\n      this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitailized(pos, {\n      enumName\n    }) {\n      this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);\n    }\n\n    flowEnumMemberInit() {\n      const startPos = this.state.start;\n\n      const endOfInit = () => this.match(types.comma) || this.match(types.braceR);\n\n      switch (this.state.type) {\n        case types.num:\n          {\n            const literal = this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n            if (endOfInit()) {\n              return {\n                type: \"number\",\n                pos: literal.start,\n                value: literal\n              };\n            }\n\n            return {\n              type: \"invalid\",\n              pos: startPos\n            };\n          }\n\n        case types.string:\n          {\n            const literal = this.parseLiteral(this.state.value, \"StringLiteral\");\n\n            if (endOfInit()) {\n              return {\n                type: \"string\",\n                pos: literal.start,\n                value: literal\n              };\n            }\n\n            return {\n              type: \"invalid\",\n              pos: startPos\n            };\n          }\n\n        case types._true:\n        case types._false:\n          {\n            const literal = this.parseBooleanLiteral();\n\n            if (endOfInit()) {\n              return {\n                type: \"boolean\",\n                pos: literal.start,\n                value: literal\n              };\n            }\n\n            return {\n              type: \"invalid\",\n              pos: startPos\n            };\n          }\n\n        default:\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n      }\n    }\n\n    flowEnumMemberRaw() {\n      const pos = this.state.start;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(types.eq) ? this.flowEnumMemberInit() : {\n        type: \"none\",\n        pos\n      };\n      return {\n        id,\n        init\n      };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {\n      const {\n        explicitType\n      } = context;\n\n      if (explicitType === null) {\n        return;\n      }\n\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(pos, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType\n    }) {\n      const seenNames = new Set();\n      const members = {\n        booleanMembers: [],\n        numberMembers: [],\n        stringMembers: [],\n        defaultedMembers: []\n      };\n\n      while (!this.match(types.braceR)) {\n        const memberNode = this.startNode();\n        const {\n          id,\n          init\n        } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n\n        if (memberName === \"\") {\n          continue;\n        }\n\n        if (/^[a-z]/.test(memberName)) {\n          this.flowEnumErrorInvalidMemberName(id.start, {\n            enumName,\n            memberName\n          });\n        }\n\n        if (seenNames.has(memberName)) {\n          this.flowEnumErrorDuplicateMemberName(id.start, {\n            enumName,\n            memberName\n          });\n        }\n\n        seenNames.add(memberName);\n        const context = {\n          enumName,\n          explicitType,\n          memberName\n        };\n        memberNode.id = id;\n\n        switch (init.type) {\n          case \"boolean\":\n            {\n              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"boolean\");\n              memberNode.init = init.value;\n              members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n              break;\n            }\n\n          case \"number\":\n            {\n              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"number\");\n              memberNode.init = init.value;\n              members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n              break;\n            }\n\n          case \"string\":\n            {\n              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"string\");\n              memberNode.init = init.value;\n              members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n              break;\n            }\n\n          case \"invalid\":\n            {\n              throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);\n            }\n\n          case \"none\":\n            {\n              switch (explicitType) {\n                case \"boolean\":\n                  this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);\n                  break;\n\n                case \"number\":\n                  this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);\n                  break;\n\n                default:\n                  members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n              }\n            }\n        }\n\n        if (!this.match(types.braceR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      return members;\n    }\n\n    flowEnumStringMembers(initializedMembers, defaultedMembers, {\n      enumName\n    }) {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (let _i = 0; _i < initializedMembers.length; _i++) {\n          const member = initializedMembers[_i];\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n            enumName\n          });\n        }\n\n        return defaultedMembers;\n      } else {\n        for (let _i2 = 0; _i2 < defaultedMembers.length; _i2++) {\n          const member = defaultedMembers[_i2];\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n            enumName\n          });\n        }\n\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName\n    }) {\n      if (this.eatContextual(\"of\")) {\n        if (!this.match(types.name)) {\n          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: null\n          });\n        }\n\n        const {\n          value\n        } = this.state;\n        this.next();\n\n        if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n          this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: value\n          });\n        }\n\n        return value;\n      }\n\n      return null;\n    }\n\n    flowEnumBody(node, {\n      enumName,\n      nameLoc\n    }) {\n      const explicitType = this.flowEnumParseExplicitType({\n        enumName\n      });\n      this.expect(types.braceL);\n      const members = this.flowEnumMembers({\n        enumName,\n        explicitType\n      });\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n            enumName\n          });\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(types.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n\n        default:\n          {\n            const empty = () => {\n              node.members = [];\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumStringBody\");\n            };\n\n            node.explicitType = false;\n            const boolsLen = members.booleanMembers.length;\n            const numsLen = members.numberMembers.length;\n            const strsLen = members.stringMembers.length;\n            const defaultedLen = members.defaultedMembers.length;\n\n            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n              return empty();\n            } else if (!boolsLen && !numsLen) {\n              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n                enumName\n              });\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumStringBody\");\n            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n              for (let _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {\n                const member = _members$defaultedMem[_i3];\n                this.flowEnumErrorBooleanMemberNotInitialized(member.start, {\n                  enumName,\n                  memberName: member.id.name\n                });\n              }\n\n              node.members = members.booleanMembers;\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumBooleanBody\");\n            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n              for (let _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {\n                const member = _members$defaultedMem2[_i4];\n                this.flowEnumErrorNumberMemberNotInitialized(member.start, {\n                  enumName,\n                  memberName: member.id.name\n                });\n              }\n\n              node.members = members.numberMembers;\n              this.expect(types.braceR);\n              return this.finishNode(node, \"EnumNumberBody\");\n            } else {\n              this.flowEnumErrorInconsistentMemberValues(nameLoc, {\n                enumName\n              });\n              return empty();\n            }\n          }\n      }\n    }\n\n    flowParseEnumDeclaration(node) {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), {\n        enumName: id.name,\n        nameLoc: id.start\n      });\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    updateContext(prevType) {\n      if (this.match(types.name) && this.state.value === \"of\" && prevType === types.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === \"interface\") {\n        this.state.exprAllowed = false;\n      } else {\n        super.updateContext(prevType);\n      }\n    }\n\n    isLookaheadToken_lt() {\n      const next = this.nextTokenStart();\n\n      if (this.input.charCodeAt(next) === 60) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return afterNext !== 60 && afterNext !== 61;\n      }\n\n      return false;\n    }\n\n    maybeUnwrapTypeCastExpression(node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n\n  }, _temp;\n});\n\nconst entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\nconst JsxErrors = Object.freeze({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression\",\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>\",\n  MissingClosingTagElement: \"Expected corresponding JSX closing tag for <%0>\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text\",\n  UnterminatedJsxContent: \"Unterminated JSX contents\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", {\n  beforeExpr: true\n});\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", {\n  startsExpr: true\n});\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr);\n  this.state.context.push(types$1.j_oTag);\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  const out = this.state.context.pop();\n\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsx = (superClass => class extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.exprAllowed) {\n              ++this.state.pos;\n              return this.finishToken(types.jsxTagStart);\n            }\n\n            return super.getTokenFromCode(ch);\n          }\n\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(types.jsxText, out);\n\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n\n        case 62:\n        case 125:\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n\n      }\n    }\n  }\n\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(types.string, out);\n  }\n\n  jsxReadEntity() {\n    let str = \"\";\n    let count = 0;\n    let entity;\n    let ch = this.input[this.state.pos];\n    const startPos = ++this.state.pos;\n\n    while (this.state.pos < this.length && count++ < 10) {\n      ch = this.input[this.state.pos++];\n\n      if (ch === \";\") {\n        if (str[0] === \"#\") {\n          if (str[1] === \"x\") {\n            str = str.substr(2);\n\n            if (HEX_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 16));\n            }\n          } else {\n            str = str.substr(1);\n\n            if (DECIMAL_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 10));\n            }\n          }\n        } else {\n          entity = entities[str];\n        }\n\n        break;\n      }\n\n      str += ch;\n    }\n\n    if (!entity) {\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    return entity;\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n\n    return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n\n    if (this.match(types.jsxName)) {\n      node.name = this.state.value;\n    } else if (this.state.type.keyword) {\n      node.name = this.state.type.keyword;\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(types.colon)) return name;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n\n    while (this.eat(types.dot)) {\n      const newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n\n    switch (this.state.type) {\n      case types.braceL:\n        node = this.startNode();\n        this.next();\n        node = this.jsxParseExpressionContainer(node);\n\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(node.start, JsxErrors.AttributeIsEmpty);\n        }\n\n        return node;\n\n      case types.jsxTagStart:\n      case types.string:\n        return this.parseExprAtom();\n\n      default:\n        throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node) {\n    if (this.match(types.braceR)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n\n    if (this.eat(types.braceL)) {\n      this.expect(types.ellipsis);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.expect(types.braceR);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n\n    while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n\n    node.attributes = attributes;\n    node.selfClosing = this.eat(types.slash);\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n    let closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case types.jsxTagStart:\n            startPos = this.state.start;\n            startLoc = this.state.startLoc;\n            this.next();\n\n            if (this.eat(types.slash)) {\n              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n\n            children.push(this.jsxParseElementAt(startPos, startLoc));\n            break;\n\n          case types.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case types.braceL:\n            {\n              const node = this.startNode();\n              this.next();\n\n              if (this.match(types.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node));\n              }\n\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      if (isFragment(openingElement) && !isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n        }\n      }\n    }\n\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n\n    node.children = children;\n\n    if (this.isRelational(\"<\")) {\n      throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);\n    }\n\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startPos, startLoc);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(types.jsxText)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(types.jsxTagStart)) {\n      return this.jsxParseElement();\n    } else if (this.isRelational(\"<\") && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.finishToken(types.jsxTagStart);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inPropertyName) return super.getTokenFromCode(code);\n    const context = this.curContext();\n\n    if (context === types$1.j_expr) {\n      return this.jsxReadToken();\n    }\n\n    if (context === types$1.j_oTag || context === types$1.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(types.jsxTagEnd);\n      }\n\n      if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n\n    if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(types.jsxTagStart);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  updateContext(prevType) {\n    if (this.match(types.braceL)) {\n      const curContext = this.curContext();\n\n      if (curContext === types$1.j_oTag) {\n        this.state.context.push(types$1.braceExpression);\n      } else if (curContext === types$1.j_expr) {\n        this.state.context.push(types$1.templateQuasi);\n      } else {\n        super.updateContext(prevType);\n      }\n\n      this.state.exprAllowed = true;\n    } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n      this.state.context.length -= 2;\n      this.state.context.push(types$1.j_cTag);\n      this.state.exprAllowed = false;\n    } else {\n      return super.updateContext(prevType);\n    }\n  }\n\n});\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = [];\n    this.enums = [];\n    this.constEnums = [];\n    this.classes = [];\n    this.exportOnlyBindings = [];\n  }\n\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        this.maybeExportDefined(scope, name);\n      }\n\n      scope.types.push(name);\n    }\n\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.indexOf(name) > -1) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.indexOf(name) > -1;\n        return isConst !== wasConst;\n      }\n\n      return true;\n    }\n\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {\n      if (scope.lexical.indexOf(name) > -1) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nconst PARAM = 0b0000,\n      PARAM_YIELD = 0b0001,\n      PARAM_AWAIT = 0b0010,\n      PARAM_RETURN = 0b0100,\n      PARAM_IN = 0b1000;\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n  get hasIn() {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nconst TSErrors = Object.freeze({\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateModifier: \"Duplicate modifier: '%0'\",\n  DuplicateAccessibilityModifier: \"Accessibility modifier already seen.\",\n  EmptyHeritageClauseType: \"'%0' list cannot be empty.\",\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier\",\n  IndexSignatureHasAccessibility: \"Index signatures cannot have an accessibility modifier ('%0')\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier\",\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier\",\n  InvalidModifierOnTypeMember: \"'%0' modifier cannot appear on a type member.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MixedLabeledAndUnlabeledElements: \"Tuple members must all have names or all not have names.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: \"Private elements cannot have an accessibility modifier ('%0')\",\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0\"\n});\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\n\nvar typescript = (superClass => class extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n\n  tsIsIdentifier() {\n    return this.match(types.name);\n  }\n\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return (this.match(types.bracketL) || this.match(types.braceL) || this.match(types.star) || this.match(types.ellipsis) || this.match(types.hash) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n\n  tsParseModifier(allowedModifiers) {\n    if (!this.match(types.name)) {\n      return undefined;\n    }\n\n    const modifier = this.state.value;\n\n    if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n      return modifier;\n    }\n\n    return undefined;\n  }\n\n  tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate) {\n    for (;;) {\n      const startPos = this.state.start;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []));\n      if (!modifier) break;\n\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);\n        } else {\n          modified.accessibility = modifier;\n        }\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(startPos, TSErrors.DuplicateModifier, modifier);\n        }\n\n        modified[modifier] = true;\n      }\n\n      if (disallowedModifiers == null ? void 0 : disallowedModifiers.includes(modifier)) {\n        this.raise(startPos, errorTemplate, modifier);\n      }\n    }\n  }\n\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(types.braceR);\n\n      case \"HeritageClauseElement\":\n        return this.match(types.braceL);\n\n      case \"TupleElementTypes\":\n        return this.match(types.bracketR);\n\n      case \"TypeParametersOrArguments\":\n        return this.isRelational(\">\");\n    }\n\n    throw new Error(\"Unreachable\");\n  }\n\n  tsParseList(kind, parseElement) {\n    const result = [];\n\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n\n    return result;\n  }\n\n  tsParseDelimitedList(kind, parseElement) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {\n    const result = [];\n\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      const element = parseElement();\n\n      if (element == null) {\n        return undefined;\n      }\n\n      result.push(element);\n\n      if (this.eat(types.comma)) {\n        continue;\n      }\n\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      if (expectSuccess) {\n        this.expect(types.comma);\n      }\n\n      return undefined;\n    }\n\n    return result;\n  }\n\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(types.bracketL);\n      } else {\n        this.expectRelational(\"<\");\n      }\n    }\n\n    const result = this.tsParseDelimitedList(kind, parseElement);\n\n    if (bracket) {\n      this.expect(types.bracketR);\n    } else {\n      this.expectRelational(\">\");\n    }\n\n    return result;\n  }\n\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(types._import);\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);\n    }\n\n    node.argument = this.parseExprAtom();\n    this.expect(types.parenR);\n\n    if (this.eat(types.dot)) {\n      node.qualifier = this.tsParseEntityName(true);\n    }\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSImportType\");\n  }\n\n  tsParseEntityName(allowReservedWords) {\n    let entity = this.parseIdentifier();\n\n    while (this.eat(types.dot)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n\n    return entity;\n  }\n\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(false);\n\n    if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(types._typeof);\n\n    if (this.match(types._import)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName(true);\n    }\n\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n\n  tsParseTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsEatThenParseType(types._extends);\n    node.default = this.tsEatThenParseType(types.eq);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsTryParseTypeParameters() {\n    if (this.isRelational(\"<\")) {\n      return this.tsParseTypeParameters();\n    }\n  }\n\n  tsParseTypeParameters() {\n    const node = this.startNode();\n\n    if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), false, true);\n\n    if (node.params.length === 0) {\n      this.raise(node.start, TSErrors.EmptyTypeParameters);\n    }\n\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsTryNextParseConstantContext() {\n    if (this.lookahead().type === types._const) {\n      this.next();\n      return this.tsParseTypeReference();\n    }\n\n    return null;\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === types.arrow;\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(types.parenL);\n    signature.parameters = this.tsParseBindingListForSignature();\n\n    if (returnTokenRequired) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n\n  tsParseBindingListForSignature() {\n    return this.parseBindingList(types.parenR, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);\n      }\n\n      return pattern;\n    });\n  }\n\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(types.comma)) {\n      this.semicolon();\n    }\n  }\n\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(types.colon, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    return this.eat(types.name) && this.match(types.colon);\n  }\n\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n\n    this.expect(types.bracketL);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(types.bracketR);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(types.question)) node.optional = true;\n    const nodeAny = node;\n\n    if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      if (readonly) {\n        this.raise(node.start, TSErrors.ReadonlyForMethodSignature);\n      }\n\n      const method = nodeAny;\n      this.tsFillSignature(types.colon, method);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n\n  tsParseTypeMember() {\n    const node = this.startNode();\n\n    if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n\n    if (this.match(types._new)) {\n      const id = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n\n    this.tsParseModifiers(node, [\"readonly\"], [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\"], TSErrors.InvalidModifierOnTypeMember);\n    const idx = this.tsTryParseIndexSignature(node);\n\n    if (idx) {\n      return idx;\n    }\n\n    this.parsePropertyName(node, false);\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n\n  tsParseObjectTypeMembers() {\n    this.expect(types.braceL);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(types.braceR);\n    return members;\n  }\n\n  tsIsStartOfMappedType() {\n    this.next();\n\n    if (this.eat(types.plusMin)) {\n      return this.isContextual(\"readonly\");\n    }\n\n    if (this.isContextual(\"readonly\")) {\n      this.next();\n    }\n\n    if (!this.match(types.bracketL)) {\n      return false;\n    }\n\n    this.next();\n\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n\n    this.next();\n    return this.match(types._in);\n  }\n\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsExpectThenParseType(types._in);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(types.braceL);\n\n    if (this.match(types.plusMin)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(\"readonly\");\n    } else if (this.eatContextual(\"readonly\")) {\n      node.readonly = true;\n    }\n\n    this.expect(types.bracketL);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(\"as\") ? this.tsParseType() : null;\n    this.expect(types.bracketR);\n\n    if (this.match(types.plusMin)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(types.question);\n    } else if (this.eat(types.question)) {\n      node.optional = true;\n    }\n\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    let labeledElements = null;\n    node.elementTypes.forEach(elementNode => {\n      var _labeledElements;\n\n      let {\n        type\n      } = elementNode;\n\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);\n      }\n\n      seenOptionalElement = seenOptionalElement || type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\";\n\n      if (type === \"TSRestType\") {\n        elementNode = elementNode.typeAnnotation;\n        type = elementNode.type;\n      }\n\n      const isLabeled = type === \"TSNamedTupleMember\";\n      labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;\n\n      if (labeledElements !== isLabeled) {\n        this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n\n  tsParseTupleElementType() {\n    const {\n      start: startPos,\n      startLoc\n    } = this.state;\n    const rest = this.eat(types.ellipsis);\n    let type = this.tsParseType();\n    const optional = this.eat(types.question);\n    const labeled = this.eat(types.colon);\n\n    if (labeled) {\n      const labeledNode = this.startNodeAtNode(type);\n      labeledNode.optional = optional;\n\n      if (type.type === \"TSTypeReference\" && !type.typeParameters && type.typeName.type === \"Identifier\") {\n        labeledNode.label = type.typeName;\n      } else {\n        this.raise(type.start, TSErrors.InvalidTupleMemberLabel);\n        labeledNode.label = type;\n      }\n\n      labeledNode.elementType = this.tsParseType();\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n\n    if (rest) {\n      const restNode = this.startNodeAt(startPos, startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n\n    return type;\n  }\n\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(types.parenL);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n\n  tsParseFunctionOrConstructorType(type) {\n    const node = this.startNode();\n\n    if (type === \"TSConstructorType\") {\n      this.expect(types._new);\n    }\n\n    this.tsFillSignature(types.arrow, node);\n    return this.finishNode(node, type);\n  }\n\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n\n    node.literal = (() => {\n      switch (this.state.type) {\n        case types.num:\n        case types.bigint:\n        case types.string:\n        case types._true:\n        case types._false:\n          return this.parseExprAtom();\n\n        default:\n          throw this.unexpected();\n      }\n    })();\n\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = this.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case types.name:\n      case types._void:\n      case types._null:\n        {\n          const type = this.match(types._void) ? \"TSVoidKeyword\" : this.match(types._null) ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n          if (type !== undefined && this.lookaheadCharCode() !== 46) {\n            const node = this.startNode();\n            this.next();\n            return this.finishNode(node, type);\n          }\n\n          return this.tsParseTypeReference();\n        }\n\n      case types.string:\n      case types.num:\n      case types.bigint:\n      case types._true:\n      case types._false:\n        return this.tsParseLiteralTypeNode();\n\n      case types.plusMin:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n\n          if (nextToken.type !== types.num && nextToken.type !== types.bigint) {\n            throw this.unexpected();\n          }\n\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n\n        break;\n\n      case types._this:\n        return this.tsParseThisTypeOrThisTypePredicate();\n\n      case types._typeof:\n        return this.tsParseTypeQuery();\n\n      case types._import:\n        return this.tsParseImportType();\n\n      case types.braceL:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n      case types.bracketL:\n        return this.tsParseTupleType();\n\n      case types.parenL:\n        return this.tsParseParenthesizedType();\n\n      case types.backQuote:\n        return this.tsParseTemplateLiteralType();\n    }\n\n    throw this.unexpected();\n  }\n\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n\n    while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {\n      if (this.match(types.bracketR)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n\n    return type;\n  }\n\n  tsParseTypeOperator(operator) {\n    const node = this.startNode();\n    this.expectContextual(operator);\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n\n      default:\n        this.raise(node.start, TSErrors.UnexpectedReadonly);\n    }\n  }\n\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(\"infer\");\n    const typeParameter = this.startNode();\n    typeParameter.name = this.parseIdentifierName(typeParameter.start);\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n\n  tsParseTypeOperatorOrHigher() {\n    const operator = [\"keyof\", \"unique\", \"readonly\"].find(kw => this.isContextual(kw));\n    return operator ? this.tsParseTypeOperator(operator) : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n  }\n\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);\n  }\n\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);\n  }\n\n  tsIsStartOfFunctionType() {\n    if (this.isRelational(\"<\")) {\n      return true;\n    }\n\n    return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n\n  tsSkipParameterStart() {\n    if (this.match(types.name) || this.match(types._this)) {\n      this.next();\n      return true;\n    }\n\n    if (this.match(types.braceL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.braceL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.braceR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    if (this.match(types.bracketL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.bracketL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.bracketR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n\n    if (this.match(types.parenR) || this.match(types.ellipsis)) {\n      return true;\n    }\n\n    if (this.tsSkipParameterStart()) {\n      if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {\n        return true;\n      }\n\n      if (this.match(types.parenR)) {\n        this.next();\n\n        if (this.match(types.arrow)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n      if (asserts && this.match(types._this)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;\n  }\n\n  tsTryParseTypeAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;\n  }\n\n  tsTryParseType() {\n    return this.tsEatThenParseType(types.colon);\n  }\n\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n\n  tsParseTypePredicateAsserts() {\n    if (!this.match(types.name) || this.state.value !== \"asserts\" || this.hasPrecedingLineBreak()) {\n      return false;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.next();\n\n    if (!this.match(types.name) && !this.match(types._this)) {\n      return false;\n    }\n\n    if (containsEsc) {\n      this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, \"asserts\");\n    }\n\n    return true;\n  }\n\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(types.colon);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n\n    if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {\n      return type;\n    }\n\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsParseNonConditionalType();\n    this.expect(types.question);\n    node.trueType = this.tsParseType();\n    this.expect(types.colon);\n    node.falseType = this.tsParseType();\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n\n    if (this.match(types._new)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    }\n\n    return this.tsParseUnionTypeOrHigher();\n  }\n\n  tsParseTypeAssertion() {\n    const node = this.startNode();\n\n    const _const = this.tsTryNextParseConstantContext();\n\n    node.typeAnnotation = _const || this.tsNextThenParseType();\n    this.expectRelational(\">\");\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n\n  tsParseHeritageClause(descriptor) {\n    const originalStart = this.state.start;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n\n    if (!delimitedList.length) {\n      this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);\n    }\n\n    return delimitedList;\n  }\n\n  tsParseExpressionWithTypeArguments() {\n    const node = this.startNode();\n    node.expression = this.tsParseEntityName(false);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n  }\n\n  tsParseInterfaceDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript interface declaration\", BIND_TS_INTERFACE);\n    node.typeParameters = this.tsTryParseTypeParameters();\n\n    if (this.eat(types._extends)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript type alias\", BIND_TS_TYPE);\n    node.typeParameters = this.tsTryParseTypeParameters();\n    node.typeAnnotation = this.tsInType(() => {\n      this.expect(types.eq);\n\n      if (this.isContextual(\"intrinsic\") && this.lookahead().type !== types.dot) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n\n    if (this.eat(types.eq)) {\n      node.initializer = this.parseMaybeAssignAllowIn();\n    }\n\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n\n  tsParseEnumDeclaration(node, isConst) {\n    if (isConst) node.const = true;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"typescript enum declaration\", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);\n    this.expect(types.braceL);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.braceL);\n    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n\n    if (!nested) {\n      this.checkLVal(node.id, \"module or namespace declaration\", BIND_TS_NAMESPACE);\n    }\n\n    if (this.eat(types.dot)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(\"global\")) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(types.string)) {\n      node.id = this.parseExprAtom();\n    } else {\n      this.unexpected();\n    }\n\n    if (this.match(types.braceL)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, \"import equals declaration\", BIND_LEXICAL);\n    this.expect(types.eq);\n    node.moduleReference = this.tsParseModuleReference();\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n\n  tsIsExternalModuleReference() {\n    return this.isContextual(\"require\") && this.lookaheadCharCode() === 40;\n  }\n\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(\"require\");\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      throw this.unexpected();\n    }\n\n    node.expression = this.parseExprAtom();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n\n    let starttype = this.state.type;\n    let kind;\n\n    if (this.isContextual(\"let\")) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    return this.tsInDeclareContext(() => {\n      switch (starttype) {\n        case types._function:\n          nany.declare = true;\n          return this.parseFunctionStatement(nany, false, true);\n\n        case types._class:\n          nany.declare = true;\n          return this.parseClass(nany, true, false);\n\n        case types._const:\n          if (this.match(types._const) && this.isLookaheadContextual(\"enum\")) {\n            this.expect(types._const);\n            this.expectContextual(\"enum\");\n            return this.tsParseEnumDeclaration(nany, true);\n          }\n\n        case types._var:\n          kind = kind || this.state.value;\n          return this.parseVarStatement(nany, kind);\n\n        case types.name:\n          {\n            const value = this.state.value;\n\n            if (value === \"global\") {\n              return this.tsParseAmbientExternalModuleDeclaration(nany);\n            } else {\n              return this.tsParseDeclaration(nany, value, true);\n            }\n          }\n      }\n    });\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n  }\n\n  tsParseExpressionStatement(node, expr) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n\n          break;\n        }\n\n      case \"global\":\n        if (this.match(types.braceL)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n\n        break;\n\n      default:\n        return this.tsParseDeclaration(node, expr.name, false);\n    }\n  }\n\n  tsParseDeclaration(node, value, next) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(types._class) || this.match(types.name))) {\n          return this.tsParseAbstractDeclaration(node);\n        }\n\n        break;\n\n      case \"enum\":\n        if (next || this.match(types.name)) {\n          if (next) this.next();\n          return this.tsParseEnumDeclaration(node, false);\n        }\n\n        break;\n\n      case \"interface\":\n        if (this.tsCheckLineTerminator(next) && this.match(types.name)) {\n          return this.tsParseInterfaceDeclaration(node);\n        }\n\n        break;\n\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(types.string)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (this.match(types.name)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n\n        break;\n\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && this.match(types.name)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && this.match(types.name)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n\n        break;\n    }\n  }\n\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n\n    return !this.isLineTerminator();\n  }\n\n  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n    if (!this.isRelational(\"<\")) {\n      return undefined;\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(types.arrow);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    if (!res) {\n      return undefined;\n    }\n\n    return this.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expectRelational(\"<\");\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n\n    if (node.params.length === 0) {\n      this.raise(node.start, TSErrors.EmptyTypeArguments);\n    }\n\n    this.state.exprAllowed = false;\n    this.expectRelational(\">\");\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n\n  tsIsDeclarationStart() {\n    if (this.match(types.name)) {\n      switch (this.state.value) {\n        case \"abstract\":\n        case \"declare\":\n        case \"enum\":\n        case \"interface\":\n        case \"module\":\n        case \"namespace\":\n        case \"type\":\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n\n    if (allowModifiers !== undefined) {\n      accessibility = this.parseAccessModifier();\n      readonly = !!this.tsParseModifier([\"readonly\"]);\n\n      if (allowModifiers === false && (accessibility || readonly)) {\n        this.raise(startPos, TSErrors.UnexpectedParameterModifier);\n      }\n    }\n\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (accessibility || readonly) {\n      const pp = this.startNodeAt(startPos, startLoc);\n\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);\n      }\n\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n    }\n\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" ? \"TSDeclareMethod\" : undefined;\n\n    if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {\n      this.finishNode(node, bodilessType);\n      return;\n    }\n\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isDeclareContext) {\n      this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);\n\n      if (node.declare) {\n        super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n        return;\n      }\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkLVal(node.id, \"function name\", BIND_TS_AMBIENT);\n    } else {\n      super.registerFunctionStatementId(...arguments);\n    }\n  }\n\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);\n      }\n    });\n  }\n\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n\n  parseArrayLike(...args) {\n    const node = super.parseArrayLike(...args);\n\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {\n      this.state.exprAllowed = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startPos, startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n\n    if (this.isRelational(\"<\")) {\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const typeArguments = this.tsParseTypeArguments();\n\n        if (typeArguments) {\n          if (!noCalls && this.eat(types.parenL)) {\n            node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n            this.tsCheckForInvalidTypeCasts(node.arguments);\n            node.typeParameters = typeArguments;\n\n            if (state.optionalChainMember) {\n              node.optional = false;\n            }\n\n            return this.finishCallExpression(node, state.optionalChainMember);\n          } else if (this.match(types.backQuote)) {\n            const result = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n            result.typeParameters = typeArguments;\n            return result;\n          }\n        }\n\n        this.unexpected();\n      });\n      if (result) return result;\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n  }\n\n  parseNewArguments(node) {\n    if (this.isRelational(\"<\")) {\n      const typeParameters = this.tsTryParseAndCatch(() => {\n        const args = this.tsParseTypeArguments();\n        if (!this.match(types.parenL)) this.unexpected();\n        return args;\n      });\n\n      if (typeParameters) {\n        node.typeParameters = typeParameters;\n      }\n    }\n\n    super.parseNewArguments(node);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(\"as\")) {\n      const node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.expression = left;\n\n      const _const = this.tsTryNextParseConstantContext();\n\n      if (_const) {\n        node.typeAnnotation = _const;\n      } else {\n        node.typeAnnotation = this.tsNextThenParseType();\n      }\n\n      this.finishNode(node, \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n    }\n\n    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}\n\n  checkDuplicateExports() {}\n\n  parseImport(node) {\n    if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {\n      const ahead = this.lookahead();\n\n      if (this.match(types.name) && ahead.type === types.eq) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n\n      if (this.isContextual(\"type\") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === \"from\")) {\n        node.importKind = \"type\";\n        this.next();\n      }\n    }\n\n    if (!node.importKind) {\n      node.importKind = \"value\";\n    }\n\n    const importNode = super.parseImport(node);\n\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(importNode.start, \"A type-only import can specify a default import or named bindings, but not both.\");\n    }\n\n    return importNode;\n  }\n\n  parseExport(node) {\n    if (this.match(types._import)) {\n      this.expect(types._import);\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(types.eq)) {\n      const assign = node;\n      assign.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(\"as\")) {\n      const decl = node;\n      this.expectContextual(\"namespace\");\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(\"type\") && this.lookahead().type === types.braceL) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n\n      return super.parseExport(node);\n    }\n  }\n\n  isAbstractClass() {\n    return this.isContextual(\"abstract\") && this.lookahead().type === types._class;\n  }\n\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      this.parseClass(cls, true, true);\n      return cls;\n    }\n\n    if (this.state.value === \"interface\") {\n      const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);\n      if (result) return result;\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseStatementContent(context, topLevel) {\n    if (this.state.type === types._const) {\n      const ahead = this.lookahead();\n\n      if (ahead.type === types.name && ahead.value === \"enum\") {\n        const node = this.startNode();\n        this.expect(types._const);\n        this.expectContextual(\"enum\");\n        return this.tsParseEnumDeclaration(node, true);\n      }\n    }\n\n    return super.parseStatementContent(context, topLevel);\n  }\n\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n\n  parseClassMember(classBody, member, state) {\n    this.tsParseModifiers(member, [\"declare\", \"private\", \"public\", \"protected\"]);\n\n    const callParseClassMember = () => {\n      super.parseClassMember(classBody, member, state);\n    };\n\n    if (member.declare) {\n      this.tsInDeclareContext(callParseClassMember);\n    } else {\n      callParseClassMember();\n    }\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    this.tsParseModifiers(member, [\"abstract\", \"readonly\", \"declare\"]);\n    const idx = this.tsTryParseIndexSignature(member);\n\n    if (idx) {\n      classBody.body.push(idx);\n\n      if (member.abstract) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAbstract);\n      }\n\n      if (isStatic) {\n        this.raise(member.start, TSErrors.IndexSignatureHasStatic);\n      }\n\n      if (member.accessibility) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);\n      }\n\n      if (member.declare) {\n        this.raise(member.start, TSErrors.IndexSignatureHasDeclare);\n      }\n\n      return;\n    }\n\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(types.question);\n    if (optional) methodOrProp.optional = true;\n\n    if (methodOrProp.readonly && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);\n    }\n\n    if (methodOrProp.declare && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n    return decl || super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {\n    if (!refNeedsArrowPos || !this.match(types.question)) {\n      return super.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);\n    }\n\n    const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));\n\n    if (!result.node) {\n      refNeedsArrowPos.start = result.error.pos || this.state.start;\n      return expr;\n    }\n\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(types.question)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(types.colon)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  parseExportDeclaration(node) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(\"declare\");\n\n    if (isDeclare && (this.isContextual(\"declare\") || !this.shouldParseExportDeclaration())) {\n      throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);\n    }\n\n    let declaration;\n\n    if (this.match(types.name)) {\n      declaration = this.tsTryParseExportDeclaration();\n    }\n\n    if (!declaration) {\n      declaration = super.parseExportDeclaration(node);\n    }\n\n    if (declaration && (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare)) {\n      node.exportKind = \"type\";\n    }\n\n    if (declaration && isDeclare) {\n      this.resetStartLocation(declaration, startPos, startLoc);\n      declaration.declare = true;\n    }\n\n    return declaration;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\n      return;\n    }\n\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(types.bang)) {\n      node.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n\n    if (this.state.isDeclareContext && this.match(types.eq)) {\n      this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(node.start, TSErrors.PrivateElementHasAbstract);\n    }\n\n    if (node.accessibility) {\n      this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);\n    }\n\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n\n    if (typeParameters && isConstructor) {\n      this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);\n    }\n\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.tsParseTypeArguments();\n    }\n\n    if (this.eatContextual(\"implements\")) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n\n  parseObjPropValue(prop, ...args) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    super.parseObjPropValue(prop, ...args);\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (decl.id.type === \"Identifier\" && this.eat(types.bang)) {\n      decl.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  parseMaybeAssign(...args) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;\n\n    let state;\n    let jsx;\n    let typeCast;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(types.jsxTagStart) || this.isRelational(\"<\"))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types$1.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types$1.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (!((_jsx = jsx) == null ? void 0 : _jsx.error) && !this.isRelational(\"<\")) {\n      return super.parseMaybeAssign(...args);\n    }\n\n    let typeParameters;\n    state = state || this.state.clone();\n    const arrow = this.tryParse(abort => {\n      var _typeParameters;\n\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(...args);\n\n      if (expr.type !== \"ArrowFunctionExpression\" || expr.extra && expr.extra.parenthesized) {\n        abort();\n      }\n\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) return arrow.node;\n\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n\n    if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n\n    if (arrow.node) {\n      this.state = arrow.failState;\n      return arrow.node;\n    }\n\n    if ((_typeCast = typeCast) == null ? void 0 : _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n\n    if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.thrown) throw typeCast.error;\n    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (!this.hasPlugin(\"jsx\") && this.isRelational(\"<\")) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors);\n    }\n  }\n\n  parseArrow(node) {\n    if (this.match(types.colon)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n        if (this.canInsertSemicolon() || !this.match(types.arrow)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(types.question)) {\n      if (param.type !== \"Identifier\" && !this.state.isDeclareContext && !this.state.inType) {\n        this.raise(param.start, TSErrors.PatternIsOptional);\n      }\n\n      param.optional = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return super.toAssignable(this.typeCastToParameter(node), isLHS);\n\n      case \"TSParameterProperty\":\n        return super.toAssignable(node, isLHS);\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        node.expression = this.toAssignable(node.expression, isLHS);\n        return node;\n\n      default:\n        return super.toAssignable(node, isLHS);\n    }\n  }\n\n  checkLVal(expr, contextDescription, ...args) {\n    switch (expr.type) {\n      case \"TSTypeCastExpression\":\n        return;\n\n      case \"TSParameterProperty\":\n        this.checkLVal(expr.parameter, \"parameter property\", ...args);\n        return;\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        this.checkLVal(expr.expression, contextDescription, ...args);\n        return;\n\n      default:\n        super.checkLVal(expr, contextDescription, ...args);\n        return;\n    }\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types._this:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsParseTypeArguments();\n\n      if (this.match(types.parenL)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n\n      this.unexpected(this.state.start, types.parenL);\n    }\n\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();\n  }\n\n  parseMaybeDefault(...args) {\n    const node = super.parseMaybeDefault(...args);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);\n    }\n\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(types.relational, 1);\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  reScan_lt_gt() {\n    if (this.match(types.relational)) {\n      const code = this.input.charCodeAt(this.state.start);\n\n      if (code === 60 || code === 62) {\n        this.state.pos -= 1;\n        this.readToken_lt_gt(code);\n      }\n    }\n  }\n\n  toAssignableList(exprList) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if (!expr) continue;\n\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          exprList[i] = this.typeCastToParameter(expr);\n          break;\n\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n          if (!this.state.maybeInArrowParameters) {\n            exprList[i] = this.typeCastToParameter(expr);\n          } else {\n            this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);\n          }\n\n          break;\n      }\n    }\n\n    return super.toAssignableList(...arguments);\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  shouldParseArrow() {\n    return this.match(types.colon) || super.shouldParseArrow();\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.colon) || super.shouldParseAsyncArrow();\n  }\n\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && firstParam.type === \"Identifier\" && firstParam.name === \"this\";\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n\n    return param;\n  }\n\n  tsInDeclareContext(cb) {\n    const oldIsDeclareContext = this.state.isDeclareContext;\n    this.state.isDeclareContext = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.isDeclareContext = oldIsDeclareContext;\n    }\n  }\n\n  parseClass(node, ...args) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n\n    try {\n      return super.parseClass(node, ...args);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n\n  tsParseAbstractDeclaration(node) {\n    if (this.match(types._class)) {\n      node.abstract = true;\n      return this.parseClass(node, true, false);\n    } else if (this.isContextual(\"interface\")) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(node.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);\n        this.next();\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, types._class);\n    }\n  }\n\n});\n\ntypes.placeholder = new TokenType(\"%%\", {\n  startsExpr: true\n});\nvar placeholders = (superClass => class extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(types.placeholder)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      this.expect(types.placeholder);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(types.placeholder, 2);\n    }\n\n    return super.getTokenFromCode(...arguments);\n  }\n\n  parseExprAtom() {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments);\n  }\n\n  parseIdentifier() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(...arguments);\n  }\n\n  checkReservedWord(word) {\n    if (word !== undefined) super.checkReservedWord(...arguments);\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments);\n  }\n\n  checkLVal(expr) {\n    if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\n  }\n\n  toAssignable(node) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n      return node;\n    }\n\n    return super.toAssignable(...arguments);\n  }\n\n  isLet(context) {\n    if (super.isLet(context)) {\n      return true;\n    }\n\n    if (!this.isContextual(\"let\")) {\n      return false;\n    }\n\n    if (context) return false;\n    const nextToken = this.lookahead();\n\n    if (nextToken.type === types.placeholder) {\n      return true;\n    }\n\n    return false;\n  }\n\n  verifyBreakContinue(node) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(...arguments);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(...arguments);\n    }\n\n    if (this.match(types.colon)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = this.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n\n  parseBlock() {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(...arguments);\n  }\n\n  parseFunctionId() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(...arguments);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n\n    if (placeholder) {\n      if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        this.unexpected(null, \"A class name is required\");\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n\n    this.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n\n  parseExport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(...arguments);\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types._default)) {\n      const next = this.nextTokenStart();\n\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(types.placeholder.label, this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n\n    return super.maybeParseExportDefaultSpecifier(...arguments);\n  }\n\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n\n    if (specifiers == null ? void 0 : specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(...arguments);\n    node.specifiers = [];\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    this.finishNode(specifier, \"ImportDefaultSpecifier\");\n    node.specifiers.push(specifier);\n\n    if (this.eat(types.comma)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n\n    this.expectContextual(\"from\");\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource(...arguments);\n  }\n\n});\n\nvar v8intrinsic = (superClass => class extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(types.modulo)) {\n      const v8IntrinsicStart = this.state.start;\n      const node = this.startNode();\n      this.eat(types.modulo);\n\n      if (this.match(types.name)) {\n        const name = this.parseIdentifierName(this.state.start);\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n\n        if (this.match(types.parenL)) {\n          return identifier;\n        }\n      }\n\n      this.unexpected(v8IntrinsicStart);\n    }\n  }\n\n  parseExprAtom() {\n    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n  }\n\n});\n\nfunction hasPlugin(plugins, name) {\n  return plugins.some(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"smart\", \"fsharp\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you are migrating from\" + \" Babylon/Babel 6 or want to use the old decorators proposal, you\" + \" should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, \"pipelineOperator\", \"proposal\"))) {\n    throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \" + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(\", \"));\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    if (hasPlugin(plugins, \"importAssertions\")) {\n      throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");\n    }\n\n    const moduleAttributesVerionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n\n    if (moduleAttributesVerionPluginOption !== \"may-2020\") {\n      throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"recordAndTuple\") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false\n};\nfunction getOptions(opts) {\n  const options = {};\n\n  for (let _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {\n    const key = _Object$keys[_i];\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nclass State {\n  constructor() {\n    this.strict = void 0;\n    this.curLine = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.maybeInArrowParameters = false;\n    this.inPipeline = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.inPropertyName = false;\n    this.hasFlowComment = false;\n    this.isIterator = false;\n    this.isDeclareContext = false;\n    this.inAbstractClass = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.comments = [];\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = [];\n    this.commentPreviousNode = null;\n    this.pos = 0;\n    this.lineStart = 0;\n    this.type = types.eof;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.lastTokEnd = 0;\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n    this.containsEsc = false;\n    this.strictErrors = new Map();\n    this.exportedIdentifiers = [];\n    this.tokensLength = 0;\n  }\n\n  init(options) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n    this.curLine = options.startLine;\n    this.startLoc = this.endLoc = this.curPosition();\n  }\n\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n\n    return state;\n  }\n\n}\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst VALID_REGEX_FLAGS = new Set([\"g\", \"m\", \"s\", \"i\", \"y\", \"u\"]);\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n  hex: [46, 88, 95, 120]\n};\nconst allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [48, 49];\nallowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];\nallowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];\nallowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n}\nclass Tokenizer extends ParserError {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  next() {\n    if (!this.isLookahead) {\n      this.checkKeywordEscapes();\n\n      if (this.options.tokens) {\n        this.pushToken(new Token(this.state));\n      }\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = old.clone(true);\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    const skip = skipWhiteSpace.exec(this.input);\n    return pos + skip[0].length;\n  }\n\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n\n    if (strict) {\n      this.state.strictErrors.forEach((message, pos) => this.raise(pos, message));\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    const curContext = this.curContext();\n    if (!(curContext == null ? void 0 : curContext.preserveSpace)) this.skipSpace();\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.length) {\n      this.finishToken(types.eof);\n      return;\n    }\n\n    const override = curContext == null ? void 0 : curContext.override;\n\n    if (override) {\n      override(this);\n    } else {\n      this.getTokenFromCode(this.input.codePointAt(this.state.pos));\n    }\n  }\n\n  pushComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    this.state.comments.push(comment);\n    this.addComment(comment);\n  }\n\n  skipBlockComment() {\n    const startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", this.state.pos + 2);\n    if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    let match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipSpace() {\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) this.updateContext(prevType);\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.input.charCodeAt(nextPos);\n\n    if (next >= 48 && next <= 57) {\n      throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);\n    }\n\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);\n      }\n\n      if (next === 123) {\n        this.finishToken(types.braceHashL);\n      } else {\n        this.finishToken(types.bracketHashL);\n      }\n\n      this.state.pos += 2;\n    } else {\n      this.finishOp(types.hash, 1);\n    }\n  }\n\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.dot);\n    }\n  }\n\n  readToken_slash() {\n    if (this.state.exprAllowed && !this.state.inType) {\n      ++this.state.pos;\n      this.readRegexp();\n      return;\n    }\n\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.slash, 1);\n    }\n  }\n\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(types.interpreterDirective, value);\n    return true;\n  }\n\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? types.star : types.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    const exprAllowed = this.state.exprAllowed;\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61 && !exprAllowed) {\n      width++;\n      type = types.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n      }\n\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(types.pipeline, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.bracketBarR, 2);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  }\n\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())) {\n        this.skipLineComment(3);\n        this.skipSpace();\n        this.nextToken();\n        return;\n      }\n\n      this.finishOp(types.incDec, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.plusMin, 1);\n    }\n  }\n\n  readToken_lt_gt(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    let size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.state.pos + size) === 61) {\n        this.finishOp(types.assign, size + 1);\n        return;\n      }\n\n      this.finishOp(types.bitShift, size);\n      return;\n    }\n\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      this.skipLineComment(4);\n      this.skipSpace();\n      this.nextToken();\n      return;\n    }\n\n    if (next === 61) {\n      size = 2;\n    }\n\n    this.finishOp(types.relational, size);\n  }\n\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(types.arrow);\n      return;\n    }\n\n    this.finishOp(code === 61 ? types.eq : types.bang, 1);\n  }\n\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(types.nullishCoalescing, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(types.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.question);\n    }\n  }\n\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(types.parenL);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(types.parenR);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(types.semi);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(types.comma);\n        return;\n\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.bracketBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.bracketL);\n        }\n\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(types.bracketR);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.braceBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.braceL);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(types.braceR);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.colon);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 96:\n        ++this.state.pos;\n        this.finishToken(types.backQuote);\n        return;\n\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n      case 62:\n        this.readToken_lt_gt(code);\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(types.tilde, 1);\n        return;\n\n      case 64:\n        ++this.state.pos;\n        this.finishToken(types.at);\n        return;\n\n      case 35:\n        this.readToken_numberSign();\n        return;\n\n      case 92:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord();\n          return;\n        }\n\n    }\n\n    throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));\n  }\n\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp() {\n    const start = this.state.pos;\n    let escaped, inClass;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(start, ErrorMessages.UnterminatedRegExp);\n      }\n\n      const ch = this.input.charAt(this.state.pos);\n\n      if (lineBreak.test(ch)) {\n        throw this.raise(start, ErrorMessages.UnterminatedRegExp);\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n\n        escaped = ch === \"\\\\\";\n      }\n\n      ++this.state.pos;\n    }\n\n    const content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n    let mods = \"\";\n\n    while (this.state.pos < this.length) {\n      const char = this.input[this.state.pos];\n      const charCode = this.input.codePointAt(this.state.pos);\n\n      if (VALID_REGEX_FLAGS.has(char)) {\n        if (mods.indexOf(char) > -1) {\n          this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags);\n        }\n      } else if (isIdentifierChar(charCode) || charCode === 92) {\n        this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);\n      } else {\n        break;\n      }\n\n      ++this.state.pos;\n      mods += char;\n    }\n\n    this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen, allowNumSeparator = true) {\n    const start = this.state.pos;\n    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (code === 95) {\n        const prev = this.input.charCodeAt(this.state.pos - 1);\n        const next = this.input.charCodeAt(this.state.pos + 1);\n\n        if (allowedSiblings.indexOf(next) === -1) {\n          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);\n        } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {\n          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);\n        }\n\n        if (!allowNumSeparator) {\n          this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);\n        }\n\n        ++this.state.pos;\n        continue;\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } else if (code >= 65) {\n        val = code - 65 + 10;\n      } else if (_isDigit(code)) {\n        val = code - 48;\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) {\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);\n    }\n\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(start, ErrorMessages.InvalidDecimal);\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    this.finishToken(types.num, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, ErrorMessages.InvalidNumber);\n    }\n\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);\n\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n\n        if (underscorePos > 0) {\n          this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);\n        }\n      }\n\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) {\n        this.raise(start, ErrorMessages.InvalidOrMissingExponent);\n      }\n\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(start, ErrorMessages.InvalidBigIntLiteral);\n      }\n\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.pos);\n\n      if (hasExponent || hasLeadingZero) {\n        this.raise(start, ErrorMessages.InvalidDecimal);\n      }\n\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(types.decimal, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(types.num, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === 123) {\n      const codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, true, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code !== null && code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, ErrorMessages.InvalidCodePoint);\n        } else {\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n\n    return code;\n  }\n\n  readString(quote) {\n    let out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (ch === 8232 || ch === 8233) {\n        ++this.state.pos;\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(types.string, out);\n  }\n\n  readTmplToken() {\n    let out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            this.finishToken(types.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(types.backQuote);\n            return;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(types.template, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) {\n              ++this.state.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  recordStrictModeErrors(pos, message) {\n    if (this.state.strict && !this.state.strictErrors.has(pos)) {\n      this.raise(pos, message);\n    } else {\n      this.state.strictErrors.set(pos, message);\n    }\n  }\n\n  readEscapedChar(inTemplate) {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n\n      case 114:\n        return \"\\r\";\n\n      case 120:\n        {\n          const code = this.readHexChar(2, false, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          const code = this.readCodePoint(throwOnInvalid);\n          return code === null ? null : String.fromCodePoint(code);\n        }\n\n      case 116:\n        return \"\\t\";\n\n      case 98:\n        return \"\\b\";\n\n      case 118:\n        return \"\\u000b\";\n\n      case 102:\n        return \"\\f\";\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n        }\n\n      case 10:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n\n      case 8232:\n      case 8233:\n        return \"\";\n\n      case 56:\n      case 57:\n        if (inTemplate) {\n          return null;\n        } else {\n          this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);\n        }\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          const codePos = this.state.pos - 1;\n          const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);\n          let octalStr = match[0];\n          let octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n\n          if (octalStr !== \"0\" || next === 56 || next === 57) {\n            if (inTemplate) {\n              return null;\n            } else {\n              this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  readHexChar(len, forceLen, throwOnInvalid) {\n    const codePos = this.state.pos;\n    const n = this.readInt(16, len, forceLen, false);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, ErrorMessages.InvalidEscapeSequence);\n      } else {\n        this.state.pos = codePos - 1;\n      }\n    }\n\n    return n;\n  }\n\n  readWord1() {\n    let word = \"\";\n    this.state.containsEsc = false;\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    while (this.state.pos < this.length) {\n      const ch = this.input.codePointAt(this.state.pos);\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (this.state.isIterator && ch === 64) {\n        ++this.state.pos;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.pos;\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  isIterator(word) {\n    return word === \"@@iterator\" || word === \"@@asyncIterator\";\n  }\n\n  readWord() {\n    const word = this.readWord1();\n    const type = keywords.get(word) || types.name;\n\n    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {\n      this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word);\n    }\n\n    this.finishToken(type, word);\n  }\n\n  checkKeywordEscapes() {\n    const kw = this.state.type.keyword;\n\n    if (kw && this.state.containsEsc) {\n      this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);\n    }\n  }\n\n  braceIsBlock(prevType) {\n    const parent = this.curContext();\n\n    if (parent === types$1.functionExpression || parent === types$1.functionStatement) {\n      return true;\n    }\n\n    if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {\n      return !parent.isExpr;\n    }\n\n    if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {\n      return this.hasPrecedingLineBreak();\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return parent === types$1.braceStatement;\n    }\n\n    if (prevType === types._var || prevType === types._const || prevType === types.name) {\n      return false;\n    }\n\n    if (prevType === types.relational) {\n      return true;\n    }\n\n    return !this.state.exprAllowed;\n  }\n\n  updateContext(prevType) {\n    const type = this.state.type;\n    let update;\n\n    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  }\n\n}\n\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, val) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    extra[key] = val;\n  }\n\n  isRelational(op) {\n    return this.match(types.relational) && this.state.value === op;\n  }\n\n  expectRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, types.relational);\n    }\n  }\n\n  isContextual(name) {\n    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));\n  }\n\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(name) {\n    return this.isContextual(name) && this.eat(types.name);\n  }\n\n  expectContextual(name, message) {\n    if (!this.eatContextual(name)) this.unexpected(null, message);\n  }\n\n  canInsertSemicolon() {\n    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();\n  }\n\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n  }\n\n  hasFollowingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.end, this.nextTokenStart()));\n  }\n\n  isLineTerminator() {\n    return this.eat(types.semi) || this.canInsertSemicolon();\n  }\n\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(types.semi)) return;\n    this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);\n  }\n\n  expect(type, pos) {\n    this.eat(type) || this.unexpected(pos, type);\n  }\n\n  assertNoSpace(message = \"Unexpected space.\") {\n    if (this.state.start > this.state.lastTokEnd) {\n      this.raise(this.state.lastTokEnd, message);\n    }\n  }\n\n  unexpected(pos, messageOrType = \"Unexpected token\") {\n    if (typeof messageOrType !== \"string\") {\n      messageOrType = `Unexpected token, expected \"${messageOrType.label}\"`;\n    }\n\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n  }\n\n  expectPlugin(name, pos) {\n    if (!this.hasPlugin(name)) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: [name]\n      }, `This experimental syntax requires enabling the parser plugin: '${name}'`);\n    }\n\n    return true;\n  }\n\n  expectOnePlugin(names, pos) {\n    if (!names.some(n => this.hasPlugin(n))) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: names\n      }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\", \")}'`);\n    }\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssign,\n      doubleProto\n    } = refExpressionErrors;\n    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;\n\n    if (shorthandAssign >= 0) {\n      this.unexpected(shorthandAssign);\n    }\n\n    if (doubleProto >= 0) {\n      this.raise(doubleProto, ErrorMessages.DuplicateProto);\n    }\n  }\n\n  isLiteralPropertyName() {\n    return this.match(types.name) || !!this.state.type.keyword || this.match(types.string) || this.match(types.num) || this.match(types.bigint) || this.match(types.decimal);\n  }\n\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssign = -1;\n    this.doubleProto = -1;\n  }\n\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.loc = void 0;\n    this.range = void 0;\n    this.leadingComments = void 0;\n    this.trailingComments = void 0;\n    this.innerComments = void 0;\n    this.extra = void 0;\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser == null ? void 0 : parser.options.ranges) this.range = [pos, 0];\n    if (parser == null ? void 0 : parser.filename) this.loc.filename = parser.filename;\n  }\n\n  __clone() {\n    const newNode = new Node();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  }\n\n}\n\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, pos, loc) {\n\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {\n    node.end = end;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = end;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n\n}\n\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\n\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n\n    let parenthesized = undefined;\n\n    if (node.type === \"ParenthesizedExpression\" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {\n      parenthesized = unwrapParenthesizedExpression(node);\n\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n        }\n      } else {\n        this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (isLast && prop.type === \"RestElement\" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {\n            this.raiseRestNotLast(node.extra.trailingComma);\n          }\n        }\n\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value, isLHS);\n        break;\n\n      case \"SpreadElement\":\n        {\n          this.checkToRestConversion(node);\n          node.type = \"RestElement\";\n          const arg = node.argument;\n          this.toAssignable(arg, isLHS);\n          break;\n        }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n\n    return node;\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      const error = prop.kind === \"get\" || prop.kind === \"set\" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;\n      this.raise(prop.key.start, error);\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raiseRestNotLast(prop.start);\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaPos, isLHS) {\n    let end = exprList.length;\n\n    if (end) {\n      const last = exprList[end - 1];\n\n      if ((last == null ? void 0 : last.type) === \"RestElement\") {\n        --end;\n      } else if ((last == null ? void 0 : last.type) === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        let arg = last.argument;\n        this.toAssignable(arg, isLHS);\n        arg = unwrapParenthesizedExpression(arg);\n\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\" && arg.type !== \"ObjectPattern\") {\n          this.unexpected(arg.start);\n        }\n\n        if (trailingCommaPos) {\n          this.raiseTrailingCommaAfterRest(trailingCommaPos);\n        }\n\n        --end;\n      }\n    }\n\n    for (let i = 0; i < end; i++) {\n      const elt = exprList[i];\n\n      if (elt) {\n        this.toAssignable(elt, isLHS);\n\n        if (elt.type === \"RestElement\") {\n          this.raiseRestNotLast(elt.start);\n        }\n      }\n    }\n\n    return exprList;\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (let _i = 0; _i < exprList.length; _i++) {\n      const expr = exprList[_i];\n\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refExpressionErrors, refNeedsArrowPos) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types.bracketL:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(types.bracketR, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case types.braceL:\n        return this.parseObjectLike(types.braceR, true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n      }\n\n      if (allowEmpty && this.match(types.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(types.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        this.checkCommaAfterRest(closeCharCode);\n        this.expect(close);\n        break;\n      } else {\n        const decorators = [];\n\n        if (this.match(types.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);\n        }\n\n        while (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    var _startLoc, _startPos, _left;\n\n    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;\n    startPos = (_startPos = startPos) != null ? _startPos : this.state.start;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(types.eq)) return left;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  checkLVal(expr, contextDescription, bindingType = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged = false) {\n    switch (expr.type) {\n      case \"Identifier\":\n        {\n          const {\n            name\n          } = expr;\n\n          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {\n            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);\n          }\n\n          if (checkClashes) {\n            if (checkClashes.has(name)) {\n              this.raise(expr.start, ErrorMessages.ParamDupe);\n            } else {\n              checkClashes.add(name);\n            }\n          }\n\n          if (disallowLetBinding && name === \"let\") {\n            this.raise(expr.start, ErrorMessages.LetInLexicalBinding);\n          }\n\n          if (!(bindingType & BIND_NONE)) {\n            this.scope.declareName(name, bindingType, expr.start);\n          }\n\n          break;\n        }\n\n      case \"MemberExpression\":\n        if (bindingType !== BIND_NONE) {\n          this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n        for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {\n          let prop = _expr$properties[_i2];\n          if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;\n          this.checkLVal(prop, \"object destructuring pattern\", bindingType, checkClashes, disallowLetBinding);\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {\n          const elem = _expr$elements[_i3];\n\n          if (elem) {\n            this.checkLVal(elem, \"array destructuring pattern\", bindingType, checkClashes, disallowLetBinding);\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, \"assignment pattern\", bindingType, checkClashes);\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, \"rest element\", bindingType, checkClashes);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, \"parenthesized expression\", bindingType, checkClashes);\n        break;\n\n      default:\n        {\n          this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);\n        }\n    }\n  }\n\n  checkToRestConversion(node) {\n    if (node.argument.type !== \"Identifier\" && node.argument.type !== \"MemberExpression\") {\n      this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);\n    }\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.match(types.comma)) {\n      if (this.lookaheadCharCode() === close) {\n        this.raiseTrailingCommaAfterRest(this.state.start);\n      } else {\n        this.raiseRestNotLast(this.state.start);\n      }\n    }\n  }\n\n  raiseRestNotLast(pos) {\n    throw this.raise(pos, ErrorMessages.ElementAfterRest);\n  }\n\n  raiseTrailingCommaAfterRest(pos) {\n    this.raise(pos, ErrorMessages.RestTrailingComma);\n  }\n\n}\n\nconst kExpression = 0,\n      kMaybeArrowParameterDeclaration = 1,\n      kMaybeAsyncArrowParameterDeclaration = 2,\n      kParameterDeclaration = 3;\n\nclass ExpressionScope {\n  constructor(type = kExpression) {\n    this.type = void 0;\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration() {\n    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n\n}\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.errors = new Map();\n  }\n\n  recordDeclarationError(pos, message) {\n    this.errors.set(pos, message);\n  }\n\n  clearDeclarationError(pos) {\n    this.errors.delete(pos);\n  }\n\n  iterateErrors(iterator) {\n    this.errors.forEach(iterator);\n  }\n\n}\n\nclass ExpressionScopeHandler {\n  constructor(raise) {\n    this.stack = [new ExpressionScope()];\n    this.raise = raise;\n  }\n\n  enter(scope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  recordParameterInitializerError(pos, message) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(pos, message);\n      } else {\n        return;\n      }\n\n      scope = stack[--i];\n    }\n\n    this.raise(pos, message);\n  }\n\n  recordParenthesizedIdentifierError(pos, message) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.raise(pos, message);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(pos, message);\n    } else {\n      return;\n    }\n  }\n\n  recordAsyncArrowParametersError(pos, message) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        scope.recordDeclarationError(pos, message);\n      }\n\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors((message, pos) => {\n      this.raise(pos, message);\n      let i = stack.length - 2;\n      let scope = stack[i];\n\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(pos);\n        scope = stack[--i];\n      }\n    });\n  }\n\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\n\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(key.start, ErrorMessages.RecordNoProto);\n        return;\n      }\n\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProto === -1) {\n            refExpressionErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raise(key.start, ErrorMessages.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n\n  getExpression() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    this.nextToken();\n    const expr = this.parseExpression();\n\n    if (!this.match(types.eof)) {\n      this.unexpected();\n    }\n\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    return expr;\n  }\n\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  parseExpressionBase(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n\n    if (this.match(types.comma)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(types.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));\n  }\n\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    if (this.isContextual(\"yield\")) {\n      if (this.prodParam.hasYield) {\n        this.state.exprAllowed = true;\n        let left = this.parseYield();\n\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n\n    if (this.match(types.parenL) || this.match(types.name)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors, refNeedsArrowPos);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (this.state.type.isAssign) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(types.eq)) {\n        node.left = this.toAssignable(left, true);\n        refExpressionErrors.doubleProto = -1;\n      } else {\n        node.left = left;\n      }\n\n      if (refExpressionErrors.shorthandAssign >= node.left.start) {\n        refExpressionErrors.shorthandAssign = -1;\n      }\n\n      this.checkLVal(left, \"assignment expression\");\n      this.next();\n      node.right = this.parseMaybeAssign();\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  parseMaybeConditional(refExpressionErrors, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);\n  }\n\n  parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {\n    if (this.eat(types.question)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprOps(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnary(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    let prec = this.state.type.binop;\n\n    if (prec != null && (this.prodParam.hasIn || !this.match(types._in))) {\n      if (prec > minPrec) {\n        const op = this.state.type;\n\n        if (op === types.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n\n          this.state.inPipeline = true;\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\n        }\n\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n\n        if (op === types.exponent && left.type === \"UnaryExpression\" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {\n          this.raise(left.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);\n        }\n\n        const logical = op === types.logicalOR || op === types.logicalAND;\n        const coalesce = op === types.nullishCoalescing;\n\n        if (coalesce) {\n          prec = types.logicalAND.binop;\n        }\n\n        this.next();\n\n        if (op === types.pipeline && this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\") {\n          if (this.match(types.name) && this.state.value === \"await\" && this.prodParam.hasAwait) {\n            throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n\n        if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {\n          throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);\n        }\n\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n      }\n    }\n\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    switch (op) {\n      case types.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"smart\":\n            return this.withTopicPermittingContext(() => {\n              return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(\"await\");\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      return this.parseAwait(startPos, startLoc);\n    }\n\n    const update = this.match(types.incDec);\n    const node = this.startNode();\n\n    if (this.state.type.prefix) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(types._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      const isDelete = this.match(types._delete);\n      this.next();\n      node.argument = this.parseMaybeUnary();\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(node.start, ErrorMessages.StrictDelete);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(node.start, ErrorMessages.DeletePrivateField);\n        }\n      }\n\n      if (!update) {\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n\n    if (isAwait) {\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(types.modulo);\n\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(startPos, this.hasPlugin(\"topLevelAwait\") ? ErrorMessages.AwaitNotInAsyncContext : ErrorMessages.AwaitNotInAsyncFunction);\n        return this.parseAwait(startPos, startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      this.checkLVal(node.argument, \"prefix operation\");\n      return this.finishNode(node, \"UpdateExpression\");\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.checkLVal(expr, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(node, \"UpdateExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprSubscripts(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n\n    return base;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      return this.parseBind(base, startPos, startLoc, noCalls, state);\n    } else if (this.match(types.backQuote)) {\n      return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (this.match(types.questionDot)) {\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(types.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);\n    } else if (optional || this.match(types.bracketL) || this.eat(types.dot)) {\n      return this.parseMember(base, startPos, startLoc, state, optional);\n    } else {\n      state.stop = true;\n      return base;\n    }\n  }\n\n  parseMember(base, startPos, startLoc, state, optional) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const computed = this.eat(types.bracketL);\n    node.object = base;\n    node.computed = computed;\n    const property = computed ? this.parseExpression() : this.parseMaybePrivateName(true);\n\n    if (this.isPrivateName(property)) {\n      if (node.object.type === \"Super\") {\n        this.raise(startPos, ErrorMessages.SuperPrivateField);\n      }\n\n      this.classScope.usePrivateName(this.getPrivateNameSV(property), property.start);\n    }\n\n    node.property = property;\n\n    if (computed) {\n      this.expect(types.bracketR);\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  parseBind(base, startPos, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n  }\n\n  parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    let node = this.startNodeAt(startPos, startLoc);\n    node.callee = base;\n\n    if (state.maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === \"Import\", base.type !== \"Super\", node);\n    }\n\n    this.finishCallExpression(node, state.optionalChainMember);\n\n    if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);\n    } else {\n      if (state.maybeAsyncArrow) {\n        this.expressionScope.exit();\n      }\n\n      this.toReferencedArguments(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  parseTaggedTemplateExpression(base, startPos, startLoc, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n\n    if (state.optionalChainMember) {\n      this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);\n    }\n\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        if (!this.hasPlugin(\"moduleAttributes\")) {\n          this.expectPlugin(\"importAssertions\");\n        }\n      }\n\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? \"one or two arguments\" : \"one argument\");\n      } else {\n        for (let _i = 0, _node$arguments = node.arguments; _i < _node$arguments.length; _i++) {\n          const arg = _node$arguments[_i];\n\n          if (arg.type === \"SpreadElement\") {\n            this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);\n          }\n        }\n      }\n    }\n\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n\n  parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);\n          }\n\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, allowPlaceholder));\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.state.type === types.slash) this.readRegexp();\n    const canBeArrow = this.state.potentialArrowAt === this.state.start;\n    let node;\n\n    switch (this.state.type) {\n      case types._super:\n        return this.parseSuper();\n\n      case types._import:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(types.dot)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(types.parenL)) {\n          this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case types._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case types.name:\n        {\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            if (this.match(types._function)) {\n              const last = this.state.context.length - 1;\n\n              if (this.state.context[last] !== types$1.functionStatement) {\n                throw new Error(\"Internal error\");\n              }\n\n              this.state.context[last] = types$1.functionExpression;\n              this.next();\n              return this.parseFunction(this.startNodeAtNode(id), undefined, true);\n            } else if (this.match(types.name)) {\n              return this.parseAsyncArrowUnaryFunction(id);\n            }\n          }\n\n          if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n\n          return id;\n        }\n\n      case types._do:\n        {\n          return this.parseDo();\n        }\n\n      case types.regexp:\n        {\n          const value = this.state.value;\n          node = this.parseLiteral(value.value, \"RegExpLiteral\");\n          node.pattern = value.pattern;\n          node.flags = value.flags;\n          return node;\n        }\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n      case types.decimal:\n        return this.parseLiteral(this.state.value, \"DecimalLiteral\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n      case types._null:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"NullLiteral\");\n\n      case types._true:\n      case types._false:\n        return this.parseBooleanLiteral();\n\n      case types.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case types.bracketBarL:\n      case types.bracketHashL:\n        {\n          return this.parseArrayLike(this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR, false, true, refExpressionErrors);\n        }\n\n      case types.bracketL:\n        {\n          return this.parseArrayLike(types.bracketR, true, false, refExpressionErrors);\n        }\n\n      case types.braceBarL:\n      case types.braceHashL:\n        {\n          return this.parseObjectLike(this.state.type === types.braceBarL ? types.braceBarR : types.braceR, false, true, refExpressionErrors);\n        }\n\n      case types.braceL:\n        {\n          return this.parseObjectLike(types.braceR, false, false, refExpressionErrors);\n        }\n\n      case types._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case types.at:\n        this.parseDecorators();\n\n      case types._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case types._new:\n        return this.parseNewOrNewTarget();\n\n      case types.backQuote:\n        return this.parseTemplate(false);\n\n      case types.doubleColon:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(callee.start, ErrorMessages.UnsupportedBind);\n          }\n        }\n\n      case types.hash:\n        {\n          if (this.state.inPipeline) {\n            node = this.startNode();\n\n            if (this.getPluginOption(\"pipelineOperator\", \"proposal\") !== \"smart\") {\n              this.raise(node.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);\n            }\n\n            this.next();\n\n            if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {\n              this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed);\n            }\n\n            this.registerTopicReference();\n            return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n          }\n\n          const nextCh = this.input.codePointAt(this.state.end);\n\n          if (isIdentifierStart(nextCh) || nextCh === 92) {\n            const start = this.state.start;\n            node = this.parseMaybePrivateName(true);\n\n            if (this.match(types._in)) {\n              this.expectPlugin(\"privateIn\");\n              this.classScope.usePrivateName(node.id.name, node.start);\n            } else if (this.hasPlugin(\"privateIn\")) {\n              this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, node.id.name);\n            } else {\n              throw this.unexpected(start);\n            }\n\n            return node;\n          }\n        }\n\n      case types.relational:\n        {\n          if (this.state.value === \"<\") {\n            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n\n            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n                this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n              }\n          }\n        }\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseAsyncArrowUnaryFunction(id) {\n    const node = this.startNodeAtNode(id);\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);\n    }\n\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, params, true);\n    return node;\n  }\n\n  parseDo() {\n    this.expectPlugin(\"doExpressions\");\n    const node = this.startNode();\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    node.body = this.parseBlock();\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(node.start, ErrorMessages.SuperNotAllowed);\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(node.start, ErrorMessages.UnexpectedSuper);\n    }\n\n    if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n      this.raise(node.start, ErrorMessages.UnsupportedSuper);\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parseBooleanLiteral() {\n    const node = this.startNode();\n    node.value = this.match(types._true);\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseMaybePrivateName(isPrivateNameAllowed) {\n    const isPrivate = this.match(types.hash);\n\n    if (isPrivate) {\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n\n      if (!isPrivateNameAllowed) {\n        this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);\n      }\n\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space between # and identifier\");\n      node.id = this.parseIdentifier(true);\n      return this.finishNode(node, \"PrivateName\");\n    } else {\n      return this.parseIdentifier(true);\n    }\n  }\n\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.prodParam.hasYield && this.match(types.dot)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n\n    if (meta.name === \"function\" && propertyName === \"sent\") {\n      if (this.isContextual(propertyName)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n    }\n\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n\n    if (this.isContextual(\"meta\")) {\n      if (!this.inModule) {\n        this.raiseWithData(id.start, {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        }, ErrorMessages.ImportMetaOutsideModule);\n      }\n\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    const node = this.startNodeAt(startPos, startLoc);\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    const refNeedsArrowPos = {\n      start: 0\n    };\n    let first = true;\n    let spreadStart;\n    let optionalCommaStart;\n\n    while (!this.match(types.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma, refNeedsArrowPos.start || null);\n\n        if (this.match(types.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(types.ellipsis)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));\n        this.checkCommaAfterRest(41);\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos));\n      }\n    }\n\n    const innerEndPos = this.state.lastTokEnd;\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(types.parenR);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n    this.toReferencedListDeep(exprList, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(val, \"parenthesized\", true);\n      this.addExtra(val, \"parenStart\", startPos);\n      return val;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = val;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  shouldParseArrow() {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node) {\n    if (this.eat(types.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    return node;\n  }\n\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(types.dot)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        let error = ErrorMessages.UnexpectedNewTarget;\n\n        if (this.hasPlugin(\"classProperties\")) {\n          error += \" or class properties\";\n        }\n\n        this.raise(metaProp.start, error);\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node);\n  }\n\n  parseNew(node) {\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"Import\") {\n      this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);\n    } else if (this.eat(types.questionDot)) {\n      this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewArguments(node) {\n    if (this.eat(types.parenL)) {\n      const args = this.parseExprList(types.parenR);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const elem = this.startNode();\n\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);\n      }\n    }\n\n    elem.value = {\n      raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value\n    };\n    this.next();\n    elem.tail = this.match(types.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    this.next();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n          break;\n        }\n      }\n\n      const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);\n\n      if (!isPattern) {\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(prop.start, ErrorMessages.InvalidRecordProperty);\n      }\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    this.state.exprAllowed = false;\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n\n    return this.finishNode(node, type);\n  }\n\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(types.bracketL) || this.match(types.star));\n  }\n\n  parsePropertyDefinition(isPattern, refExpressionErrors) {\n    let decorators = [];\n\n    if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);\n      }\n\n      while (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isGenerator = false;\n    let isAsync = false;\n    let isAccessor = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(types.ellipsis)) {\n      if (decorators.length) this.unexpected();\n\n      if (isPattern) {\n        this.next();\n        prop.argument = this.parseIdentifier();\n        this.checkCommaAfterRest(125);\n        return this.finishNode(prop, \"RestElement\");\n      }\n\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (isPattern || refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, false);\n\n    if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        isGenerator = this.eat(types.star);\n        this.parsePropertyName(prop, false);\n      }\n\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        prop.kind = keyName;\n\n        if (this.match(types.star)) {\n          isGenerator = true;\n          this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);\n          this.next();\n        }\n\n        this.parsePropertyName(prop, false);\n      }\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    return prop;\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n\n  checkGetterSetterParams(method) {\n    var _params;\n\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const start = method.start;\n\n    if (params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, ErrorMessages.BadGetterArity);\n      } else {\n        this.raise(start, ErrorMessages.BadSetterArity);\n      }\n    }\n\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(start, ErrorMessages.BadSetterRestParameter);\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n\n    if (isAsync || isGenerator || this.match(types.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else if (this.match(types.eq) && refExpressionErrors) {\n        if (refExpressionErrors.shorthandAssign === -1) {\n          refExpressionErrors.shorthandAssign = this.state.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else {\n        prop.value = prop.key.__clone();\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop, isPrivateNameAllowed) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(types.bracketR);\n    } else {\n      const oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true;\n      prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) || this.match(types.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);\n\n      if (!this.isPrivateName(prop.key)) {\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return node;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaPos) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n\n    if (!this.match(types.bracketL) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaPos);\n    }\n\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(node, params, trailingCommaPos) {\n    node.params = this.toAssignableList(params, trailingCommaPos, false);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(types.braceL);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n\n        if (hasStrictModeDirective && nonSimple) {\n          const errorPos = (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.end : node.start;\n          this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);\n        }\n\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n\n        if (this.state.strict && node.id) {\n          this.checkLVal(node.id, \"function name\", BIND_OUTSIDE, undefined, undefined, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.expressionScope.exit();\n      this.state.labels = oldLabels;\n    }\n  }\n\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (params[i].type !== \"Identifier\") return false;\n    }\n\n    return true;\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = new Set();\n\n    for (let _i2 = 0, _node$params = node.params; _i2 < _node$params.length; _i2++) {\n      const param = _node$params[_i2];\n      this.checkLVal(param, \"function parameter list\", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);\n    }\n  }\n\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n\n    return elts;\n  }\n\n  parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {\n    let elt;\n\n    if (this.match(types.comma)) {\n      if (!allowEmpty) {\n        this.raise(this.state.pos, ErrorMessages.UnexpectedToken, \",\");\n      }\n\n      elt = null;\n    } else if (this.match(types.ellipsis)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);\n    } else if (this.match(types.question)) {\n      this.expectPlugin(\"partialApplication\");\n\n      if (!allowPlaceholder) {\n        this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);\n      }\n\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos);\n    }\n\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos, liberal) {\n    let name;\n    const {\n      start,\n      type\n    } = this.state;\n\n    if (type === types.name) {\n      name = this.state.value;\n    } else if (type.keyword) {\n      name = type.keyword;\n      const curContext = this.curContext();\n\n      if ((type === types._class || type === types._function) && (curContext === types$1.functionStatement || curContext === types$1.functionExpression)) {\n        this.state.context.pop();\n      }\n    } else {\n      throw this.unexpected();\n    }\n\n    if (liberal) {\n      this.state.type = types.name;\n    } else {\n      this.checkReservedWord(name, start, !!type.keyword, false);\n    }\n\n    this.next();\n    return name;\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (this.prodParam.hasYield && word === \"yield\") {\n      this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);\n      return;\n    }\n\n    if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);\n        return;\n      } else if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction) {\n        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);\n        return;\n      } else {\n        this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);\n      }\n    }\n\n    if (this.scope.inClass && !this.scope.inNonArrowFunction && word === \"arguments\") {\n      this.raise(startLoc, ErrorMessages.ArgumentsInClass);\n      return;\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);\n      return;\n    }\n\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);\n    }\n  }\n\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait) return true;\n\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n\n    return false;\n  }\n\n  parseAwait(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);\n\n    if (this.eat(types.star)) {\n      this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary();\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait() {\n    return this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin(\"v8intrinsic\") && this.match(types.modulo);\n  }\n\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);\n    this.next();\n\n    if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartPos) {\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);\n      }\n    }\n  }\n\n  parseSmartPipelineBody(childExpression, startPos, startLoc) {\n    this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);\n    return this.parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc);\n  }\n\n  checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {\n    if (this.match(types.arrow)) {\n      throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);\n    } else if (childExpression.type === \"SequenceExpression\") {\n      this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n    const isSimpleReference = this.isSimpleReference(childExpression);\n\n    if (isSimpleReference) {\n      bodyNode.callee = childExpression;\n    } else {\n      if (!this.topicReferenceWasUsedInCurrentTopicContext()) {\n        this.raise(startPos, ErrorMessages.PipelineTopicUnused);\n      }\n\n      bodyNode.expression = childExpression;\n    }\n\n    return this.finishNode(bodyNode, isSimpleReference ? \"PipelineBareFunction\" : \"PipelineTopicExpression\");\n  }\n\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  withTopicPermittingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withTopicForbiddingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  primaryTopicReferenceIsAllowedInCurrentTopicContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentTopicContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n\n  parseFSharpPipelineBody(prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n}\n\nconst loopLabel = {\n  kind: \"loop\"\n},\n      switchLabel = {\n  kind: \"switch\"\n};\nconst FUNC_NO_FLAGS = 0b000,\n      FUNC_STATEMENT = 0b001,\n      FUNC_HANGING_STATEMENT = 0b010,\n      FUNC_NULLABLE_ID = 0b100;\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    program.sourceType = this.options.sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, types.eof);\n\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (let _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {\n        const [name] = _Array$from[_i];\n        const pos = this.scope.undefinedExports.get(name);\n        this.raise(pos, ErrorMessages.ModuleExportUndefined, name);\n      }\n    }\n\n    file.program = this.finishNode(program, \"Program\");\n    file.comments = this.state.comments;\n    if (this.options.tokens) file.tokens = this.tokens;\n    return this.finishNode(file, \"File\");\n  }\n\n  stmtToDirective(stmt) {\n    const expr = stmt.expression;\n    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n    const directive = this.startNodeAt(stmt.start, stmt.loc.start);\n    const raw = this.input.slice(expr.start, expr.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n  }\n\n  parseInterpreterDirective() {\n    if (!this.match(types.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context) {\n    if (!this.isContextual(\"let\")) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const nextCh = this.input.charCodeAt(next);\n    if (nextCh === 91) return true;\n    if (context) return false;\n    if (nextCh === 123) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      let pos = next + 1;\n\n      while (isIdentifierChar(this.input.charCodeAt(pos))) {\n        ++pos;\n      }\n\n      const ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) return true;\n    }\n\n    return false;\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.match(types.at)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context, topLevel) {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case types._break:\n      case types._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case types._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case types._do:\n        return this.parseDoStatement(node);\n\n      case types._for:\n        return this.parseForStatement(node);\n\n      case types._function:\n        if (this.lookaheadCharCode() === 46) break;\n\n        if (context) {\n          if (this.state.strict) {\n            this.raise(this.state.start, ErrorMessages.StrictFunction);\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(this.state.start, ErrorMessages.SloppyFunction);\n          }\n        }\n\n        return this.parseFunctionStatement(node, false, !context);\n\n      case types._class:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case types._if:\n        return this.parseIfStatement(node);\n\n      case types._return:\n        return this.parseReturnStatement(node);\n\n      case types._switch:\n        return this.parseSwitchStatement(node);\n\n      case types._throw:\n        return this.parseThrowStatement(node);\n\n      case types._try:\n        return this.parseTryStatement(node);\n\n      case types._const:\n      case types._var:\n        kind = kind || this.state.value;\n\n        if (context && kind !== \"var\") {\n          this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case types._while:\n        return this.parseWhileStatement(node);\n\n      case types._with:\n        return this.parseWithStatement(node);\n\n      case types.braceL:\n        return this.parseBlock();\n\n      case types.semi:\n        return this.parseEmptyStatement(node);\n\n      case types._import:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n              break;\n            }\n        }\n\n      case types._export:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);\n          }\n\n          this.next();\n          let result;\n\n          if (starttype === types._import) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);\n            }\n\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raiseWithData(node.start, {\n        code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n      }, ErrorMessages.ImportOutsideModule);\n    }\n  }\n\n  takeDecorators(node) {\n    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator() {\n    return this.match(types._class);\n  }\n\n  parseDecorators(allowExport) {\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(types.at)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(types._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, ErrorMessages.DecoratorExportClass);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);\n    }\n  }\n\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      this.state.decoratorStack.push([]);\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr;\n\n      if (this.eat(types.parenL)) {\n        expr = this.parseExpression();\n        this.expect(types.parenR);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(types.dot)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(types.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(node, keyword) {\n    const isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, keyword);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n\n  verifyBreakContinue(node, keyword) {\n    const isBreak = keyword === \"break\";\n    let i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);\n    }\n  }\n\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression() {\n    this.expect(types.parenL);\n    const val = this.parseExpression();\n    this.expect(types.parenR);\n    return val;\n  }\n\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(types.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = -1;\n\n    if (this.isAwaitAllowed() && this.eatContextual(\"await\")) {\n      awaitAt = this.state.lastTokStart;\n    }\n\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.parenL);\n\n    if (this.match(types.semi)) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    const isLet = this.isLet();\n\n    if (this.match(types._var) || this.match(types._const) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if ((this.match(types._in) || this.isContextual(\"of\")) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init);\n    }\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      this.toAssignable(init, true);\n      const description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n      this.checkLVal(init, description);\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, ErrorMessages.IllegalReturn);\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(types.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n\n    for (let sawDefault; !this.match(types.braceR);) {\n      if (this.match(types._case) || this.match(types._default)) {\n        const isCase = this.match(types._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(types.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node) {\n    this.next();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, \"catch clause\", BIND_LEXICAL);\n    return param;\n  }\n\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(types._catch)) {\n      const clause = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL)) {\n        this.expect(types.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(types.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, ErrorMessages.NoCatchOrFinally);\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(this.state.start, ErrorMessages.StrictWith);\n    }\n\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (let _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {\n      const label = _this$state$labels[_i2];\n\n      if (label.name === maybeName) {\n        this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);\n      }\n    }\n\n    const kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n\n    this.expect(types.braceL);\n\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n\n    this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);\n\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(types.semi) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(types.parenR) ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(types._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt > -1) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt > -1;\n    }\n\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? \"for-in\" : \"for-of\");\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, ErrorMessages.InvalidLhs, \"for-loop\");\n    }\n\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind) {\n    const declarations = node.declarations = [];\n    const isTypescript = this.hasPlugin(\"typescript\");\n    node.kind = kind;\n\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n\n      if (this.eat(types.eq)) {\n        decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      } else {\n        if (kind === \"const\" && !(this.match(types._in) || this.isContextual(\"of\"))) {\n          if (!isTypescript) {\n            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, \"Const declarations\");\n          }\n        } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n          this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, \"Complex binding patterns\");\n        }\n\n        decl.init = null;\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) break;\n    }\n\n    return node;\n  }\n\n  parseVarId(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, \"variable declaration\", kind === \"var\" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== \"var\");\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n\n    if (this.match(types.star) && isHangingStatement) {\n      this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);\n    }\n\n    node.generator = this.eat(types.star);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, false);\n    this.withTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  parseFunctionId(requireId) {\n    return requireId || this.match(types.name) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    this.expect(types.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n\n  isClassProperty() {\n    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n  }\n\n  isClassMethod() {\n    return this.match(types.parenL);\n  }\n\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n\n  parseClassBody(constructorAllowsSuper, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      constructorAllowsSuper,\n      hadConstructor: false,\n      hadStaticBlock: false\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(types.braceL);\n    this.withTopicForbiddingContext(() => {\n      while (!this.match(types.braceR)) {\n        if (this.eat(types.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);\n          }\n\n          continue;\n        }\n\n        if (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(member.start, ErrorMessages.DecoratorConstructor);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n\n    if (decorators.length) {\n      throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);\n    }\n\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n\n    return false;\n  }\n\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(\"static\");\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      if (this.eat(types.braceL)) {\n        this.parseClassStaticBlock(classBody, member, state);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n\n    if (this.eat(types.star)) {\n      method.kind = \"method\";\n      this.parseClassElementName(method);\n\n      if (this.isPrivateName(method.key)) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parseClassElementName(member);\n    const isPrivate = this.isPrivateName(key);\n    const isSimple = key.type === \"Identifier\";\n    const maybeQuestionTokenStart = this.state.start;\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, ErrorMessages.DuplicateConstructor);\n        }\n\n        state.hadConstructor = true;\n        allowsDirectSuper = state.constructorAllowsSuper;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isSimple && key.name === \"async\" && !containsEsc && !this.isLineTerminator()) {\n      const isGenerator = this.eat(types.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStart);\n      }\n\n      method.kind = \"method\";\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (this.isPrivateName(method.key)) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isSimple && (key.name === \"get\" || key.name === \"set\") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {\n      method.kind = key.name;\n      this.parseClassElementName(publicMethod);\n\n      if (this.isPrivateName(method.key)) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassElementName(member) {\n    const key = this.parsePropertyName(member, true);\n\n    if (!member.computed && member.static && (key.name === \"prototype\" || key.value === \"prototype\")) {\n      this.raise(key.start, ErrorMessages.StaticPrototype);\n    }\n\n    if (this.isPrivateName(key) && this.getPrivateNameSV(key) === \"constructor\") {\n      this.raise(key.start, ErrorMessages.ConstructorClassPrivateField);\n    }\n\n    return key;\n  }\n\n  parseClassStaticBlock(classBody, member, state) {\n    var _member$decorators;\n\n    this.expectPlugin(\"classStaticBlock\", member.start);\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(PARAM);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, types.braceR);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n\n    if (state.hadStaticBlock) {\n      this.raise(member.start, ErrorMessages.DuplicateStaticBlock);\n    }\n\n    if ((_member$decorators = member.decorators) == null ? void 0 : _member$decorators.length) {\n      this.raise(member.start, ErrorMessages.DecoratorStaticBlock);\n    }\n\n    state.hadStaticBlock = true;\n  }\n\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(prop.key.start, ErrorMessages.ConstructorClassField);\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(classBody, prop) {\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {}\n\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    if (!node.typeAnnotation || this.match(types.eq)) {\n      this.expectPlugin(\"classProperties\");\n    }\n\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseInitializer(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(types.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (this.match(types.name)) {\n      node.id = this.parseIdentifier();\n\n      if (isStatement) {\n        this.checkLVal(node.id, \"class name\", bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, ErrorMessages.MissingClassName);\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(types.comma);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, types.braceL);\n    }\n\n    let hasDeclaration;\n\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(types._default)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, types.braceL);\n  }\n\n  eatExportStar(node) {\n    return this.eat(types.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(\"as\")) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(types.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      node.specifiers.push(...this.parseExportSpecifiers());\n      node.source = null;\n      node.declaration = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  isAsyncFunction() {\n    if (!this.isContextual(\"async\")) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(types._function) || isAsync) {\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    } else if (this.match(types._class)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);\n      }\n\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {\n      throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);\n    } else {\n      const res = this.parseMaybeAssignAllowIn();\n      this.semicolon();\n      return res;\n    }\n  }\n\n  parseExportDeclaration(node) {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types.name)) {\n      const value = this.state.value;\n\n      if (value === \"async\" && !this.state.containsEsc || value === \"let\") {\n        return false;\n      }\n\n      if ((value === \"type\" || value === \"interface\") && !this.state.containsEsc) {\n        const l = this.lookahead();\n\n        if (l.type === types.name && l.value !== \"from\" || l.type === types.braceL) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(types._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n\n    if (this.input.charCodeAt(next) === 44 || this.match(types.name) && hasFrom) {\n      return true;\n    }\n\n    if (this.match(types._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n\n    return false;\n  }\n\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(\"from\")) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n\n      if (assertions) {\n        node.assertions = assertions;\n      }\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.match(types.at)) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isLet() || this.isAsyncFunction();\n  }\n\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n\n          const declaration = node.declaration;\n\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) == null ? void 0 : _declaration$extra.parenthesized)) {\n            this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        for (let _i3 = 0, _node$specifiers = node.specifiers; _i3 < _node$specifiers.length; _i3++) {\n          const specifier = _node$specifiers[_i3];\n          const {\n            exported\n          } = specifier;\n          const exportedName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportedName);\n\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n\n            if (local.type === \"StringLiteral\") {\n              this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);\n            } else {\n              this.checkReservedWord(local.name, local.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (let _i4 = 0, _node$declaration$dec = node.declaration.declarations; _i4 < _node$declaration$dec.length; _i4++) {\n            const declaration = _node$declaration$dec[_i4];\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);\n    }\n  }\n\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (let _i5 = 0, _node$properties = node.properties; _i5 < _node$properties.length; _i5++) {\n        const prop = _node$properties[_i5];\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (let _i6 = 0, _node$elements = node.elements; _i6 < _node$elements.length; _i6++) {\n        const elem = _node$elements[_i6];\n\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(node, name) {\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n      this.raise(node.start, name === \"default\" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);\n    }\n\n    this.state.exportedIdentifiers.push(name);\n  }\n\n  parseExportSpecifiers() {\n    const nodes = [];\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local.__clone();\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }\n\n  parseModuleExportName() {\n    if (this.match(types.string)) {\n      this.expectPlugin(\"moduleStringNames\");\n      const result = this.parseLiteral(this.state.value, \"StringLiteral\");\n      const surrogate = result.value.match(loneSurrogate);\n\n      if (surrogate) {\n        this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));\n      }\n\n      return result;\n    }\n\n    return this.parseIdentifier(true);\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n\n    if (!this.match(types.string)) {\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(types.comma);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(\"from\");\n    }\n\n    node.source = this.parseImportSource();\n    const assertions = this.maybeParseImportAssertions();\n\n    if (assertions) {\n      node.assertions = assertions;\n    } else {\n        const attributes = this.maybeParseModuleAttributes();\n\n        if (attributes) {\n          node.attributes = attributes;\n        }\n      }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    if (!this.match(types.string)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return this.match(types.name);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  parseAssertEntries() {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(types.braceR)) {\n        break;\n      }\n\n      const node = this.startNode();\n      const keyName = this.state.value;\n\n      if (this.match(types.string)) {\n        node.key = this.parseLiteral(keyName, \"StringLiteral\");\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n\n      this.expect(types.colon);\n\n      if (keyName !== \"type\") {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, keyName);\n      }\n\n      if (attrNames.has(keyName)) {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);\n      }\n\n      attrNames.add(keyName);\n\n      if (!this.match(types.string)) {\n        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);\n      }\n\n      node.value = this.parseLiteral(this.state.value, \"StringLiteral\");\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(types.comma));\n\n    return attrs;\n  }\n\n  maybeParseModuleAttributes() {\n    if (this.match(types._with) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n\n    const attrs = [];\n    const attributes = new Set();\n\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);\n      }\n\n      attributes.add(node.key.name);\n      this.expect(types.colon);\n\n      if (!this.match(types.string)) {\n        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);\n      }\n\n      node.value = this.parseLiteral(this.state.value, \"StringLiteral\");\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(types.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    if (this.isContextual(\"assert\") && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n\n    this.eat(types.braceL);\n    const attrs = this.parseAssertEntries();\n    this.eat(types.braceR);\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(types.star)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(types.colon)) {\n          throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);\n        }\n\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    specifier.imported = this.parseModuleExportName();\n\n    if (this.eatContextual(\"as\")) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n\n      if (imported.type === \"StringLiteral\") {\n        throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);\n      }\n\n      this.checkReservedWord(imported.name, specifier.start, true, true);\n      specifier.local = imported.__clone();\n    }\n\n    this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n}\n\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n\n}\nclass ClassScopeHandler {\n  constructor(raise) {\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n  }\n\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n\n    for (let _i = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i < _Array$from.length; _i++) {\n      const [name, pos] = _Array$from[_i];\n\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, pos);\n        }\n      } else {\n        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);\n      }\n    }\n  }\n\n  declarePrivateName(name, elementType, pos) {\n    const classScope = this.current();\n    let redefined = classScope.privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && classScope.loneAccessors.get(name);\n\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) classScope.loneAccessors.delete(name);\n      } else if (!redefined) {\n        classScope.loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);\n    }\n\n    classScope.privateNames.add(name);\n    classScope.undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name, pos) {\n    let classScope;\n\n    for (let _i2 = 0, _this$stack = this.stack; _i2 < _this$stack.length; _i2++) {\n      classScope = _this$stack[_i2];\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, pos);\n    } else {\n      this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);\n    }\n  }\n\n}\n\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    const ScopeHandler = this.getScopeHandler();\n    this.options = options;\n    this.inModule = this.options.sourceType === \"module\";\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\n    this.prodParam = new ProductionParameterHandler();\n    this.classScope = new ClassScopeHandler(this.raise.bind(this));\n    this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n\n  parse() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n\n}\n\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n\n  for (let _i = 0; _i < plugins.length; _i++) {\n    const plugin = plugins[_i];\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  var _options;\n\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\n\nfunction getParser(options, input) {\n  let cls = Parser;\n\n  if (options == null ? void 0 : options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (let _i = 0; _i < pluginList.length; _i++) {\n      const plugin = pluginList[_i];\n      cls = mixinPlugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n//# sourceMappingURL=index.js.map\n"]}}